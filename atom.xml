<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Vaibhav Sagar's blog</title>
    <link href="https://vaibhavsagar.com/atom.xml" rel="self" />
    <link href="https://vaibhavsagar.com" />
    <id>https://vaibhavsagar.com/atom.xml</id>
    <author>
        <name>Vaibhav Sagar</name>
        <email>vaibhavsagar@gmail.com</email>
    </author>
    <updated>2019-02-12T00:00:00Z</updated>
    <entry>
    <title>Refactoring Haskell: A Case Study</title>
    <link href="https://vaibhavsagar.com/blog/2019/02/12/refactoring-haskell/index.html" />
    <id>https://vaibhavsagar.com/blog/2019/02/12/refactoring-haskell/index.html</id>
    <published>2019-02-12T00:00:00Z</published>
    <updated>2019-02-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 12 February 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>
    
</div>

<p>Many people claim that <a href="https://twitter.com/search?q=haskell%20refactoring">refactoring Haskell is a joy</a>. I’ve certainly found this to be the case, but what does that mean in practice? I thought it might be useful to demonstrate by refactoring some of my own code.</p>
<p>The code we’re looking at today is an implementation of <a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Tarjan’s Strongly Connected Components algorithm</a> used to determine whether a given <a href="https://en.wikipedia.org/wiki/2-satisfiability">2-SAT problem</a> is satisfiable or not, and was written to complete <a href="https://online.stanford.edu/course/algorithms-design-and-analysis-part-1">an online course</a> that is now offered in a different form. I’ve <a href="http://vaibhavsagar.com/blog/2017/06/10/dag-toolkit/">written about Tarjan’s algorithm previously</a> and it can be used to determine the satisfiability of a 2-SAT problem by checking if any SCC contains both a variable and its negation. If it does, we have a contradiction and the problem is unsatisfiable, otherwise the problem is satisfiable.</p>
<p>This code isn’t particularly elegant or easy to follow, and it’s lousy with mutable state. Despite these drawbacks, it is still relatively straightforward to refactor.</p>
<p>If you’d like to follow along, I have the code (and some test data) available <a href="https://gist.github.com/vaibhavsagar/2418c9dd79da431065ad0d80e690b12f">at this gist</a> with each revision representing a refactoring step.</p>
<p>The initial version of the code is as follows:</p>
<details>
<p><summary style="cursor: pointer">Initial 2SAT.hs</summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span>      <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">M</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span>        <span class="kw">as</span> <span class="dt">S</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span>      <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>         <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_, when)</a>
<a class="sourceLine" id="cb1-14" title="14"><span class="kw">import</span> <span class="dt">Data.Maybe</span> (isJust, isNothing, fromJust)</a>
<a class="sourceLine" id="cb1-15" title="15"></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb1-17" title="17">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-19" title="19">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb1-20" title="20">    stackSet <span class="ot">&lt;-</span> newSTRef S.empty</a>
<a class="sourceLine" id="cb1-21" title="21">    indices  <span class="ot">&lt;-</span> newSTRef M.empty</a>
<a class="sourceLine" id="cb1-22" title="22">    lowlinks <span class="ot">&lt;-</span> newSTRef M.empty</a>
<a class="sourceLine" id="cb1-23" title="23">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb1-24" title="24"></a>
<a class="sourceLine" id="cb1-25" title="25">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-26" title="26">        vIndex <span class="ot">&lt;-</span> M.lookup v <span class="op">&lt;$&gt;</span> readSTRef indices</a>
<a class="sourceLine" id="cb1-27" title="27">        when (isNothing vIndex) <span class="op">$</span></a>
<a class="sourceLine" id="cb1-28" title="28">            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb1-29" title="29"></a>
<a class="sourceLine" id="cb1-30" title="30">    readSTRef output</a>
<a class="sourceLine" id="cb1-31" title="31"></a>
<a class="sourceLine" id="cb1-32" title="32">strongConnect</a>
<a class="sourceLine" id="cb1-33" title="33"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-34" title="34">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-35" title="35">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb1-36" title="36">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-37" title="37">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb1-38" title="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-39" title="39">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-40" title="40">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-41" title="41">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb1-42" title="42">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb1-43" title="43">strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-44" title="44">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb1-45" title="45">    insert v i indices</a>
<a class="sourceLine" id="cb1-46" title="46">    insert v i lowlinks</a>
<a class="sourceLine" id="cb1-47" title="47">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-48" title="48">    push stack stackSet v</a>
<a class="sourceLine" id="cb1-49" title="49"></a>
<a class="sourceLine" id="cb1-50" title="50">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">lookup</span> w indices <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb1-51" title="51">        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-52" title="52">            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb1-53" title="53">            vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</a>
<a class="sourceLine" id="cb1-54" title="54">            wLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> w lowlinks</a>
<a class="sourceLine" id="cb1-55" title="55">            insert v (<span class="fu">min</span> vLowLink wLowLink) lowlinks</a>
<a class="sourceLine" id="cb1-56" title="56">        <span class="dt">Just</span> wIndex <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-57" title="57">            wOnStack <span class="ot">&lt;-</span> S.member w <span class="op">&lt;$&gt;</span> readSTRef stackSet</a>
<a class="sourceLine" id="cb1-58" title="58">            when wOnStack <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-59" title="59">                vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</a>
<a class="sourceLine" id="cb1-60" title="60">                insert v (<span class="fu">min</span> vLowLink wIndex) lowlinks</a>
<a class="sourceLine" id="cb1-61" title="61"></a>
<a class="sourceLine" id="cb1-62" title="62">    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</a>
<a class="sourceLine" id="cb1-63" title="63">    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v indices</a>
<a class="sourceLine" id="cb1-64" title="64">    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-65" title="65">        scc <span class="ot">&lt;-</span> addSCC n v S.empty stack stackSet</a>
<a class="sourceLine" id="cb1-66" title="66">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb1-67" title="67">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-68" title="68">        <span class="fu">lookup</span> value hashMap     <span class="ot">=</span> M.lookup value <span class="op">&lt;$&gt;</span> readSTRef hashMap</a>
<a class="sourceLine" id="cb1-69" title="69">        insert key value hashMap <span class="ot">=</span> modifySTRef&#39; hashMap (M.insert key value)</a>
<a class="sourceLine" id="cb1-70" title="70"></a>
<a class="sourceLine" id="cb1-71" title="71"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> (<span class="dt">S.Set</span> <span class="dt">Int</span>))</a>
<a class="sourceLine" id="cb1-72" title="72">addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`S.member`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb1-73" title="73">    <span class="kw">let</span> scc&#39; <span class="ot">=</span> S.insert w scc</a>
<a class="sourceLine" id="cb1-74" title="74">    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</a>
<a class="sourceLine" id="cb1-75" title="75"></a>
<a class="sourceLine" id="cb1-76" title="76"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb1-77" title="77">push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-78" title="78">    modifySTRef&#39; stack    (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb1-79" title="79">    modifySTRef&#39; stackSet (S.insert e)</a>
<a class="sourceLine" id="cb1-80" title="80"></a>
<a class="sourceLine" id="cb1-81" title="81"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-82" title="82">pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-83" title="83">    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb1-84" title="84">    modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb1-85" title="85">    modifySTRef&#39; stackSet (S.delete e)</a>
<a class="sourceLine" id="cb1-86" title="86">    <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb1-87" title="87"></a>
<a class="sourceLine" id="cb1-88" title="88">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb1-89" title="89">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb1-90" title="90">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb1-91" title="91">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb1-92" title="92"></a>
<a class="sourceLine" id="cb1-93" title="93"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-94" title="94">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-95" title="95">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb1-96" title="96">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb1-97" title="97">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb1-98" title="98">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb1-99" title="99">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>I’ve included 2SAT-specific functionality for completeness, but I’ll only be changing the <code>tarjan</code> function and the functions it depends on (<code>strongConnect</code>, <code>addSCC</code>, <code>push</code>, and <code>pop</code>).</p>
<p>The first change is using more suitable data structures. Tarjan’s algorithm is only linear in the size of the graph when operations, such as checking if <code>w</code> is on the stack and looking up indices, happen in constant time (<span class="math inline"><em>O</em>(1)</span>). I’m currently using <code>Data.Map</code> and <code>Data.Set</code> which are both implemented with trees and are <span class="math inline"><em>O</em>(log <em>n</em>)</span> in these operations. A better choice would be <a href="http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html"><code>Data.Vector.Mutable</code></a> from the <code>vector</code> package, which does have constant-time operations.</p>
<p>This refactoring mostly consists of initialising vectors with a known length and replacing calls to <code>lookup</code> and <code>insert</code> with calls to <code>read</code> and <code>write</code>.</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>vector</code></summary></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_, when)</a>
<a class="sourceLine" id="cb2-12" title="12"><span class="kw">import</span> <span class="dt">Data.Maybe</span>          (isJust, isNothing, fromJust)</a>
<a class="sourceLine" id="cb2-13" title="13"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb2-14" title="14"></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb2-16" title="16">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-17" title="17">    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-18" title="18">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb2-19" title="19">    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-20" title="20">    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-21" title="21">    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-22" title="22">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb2-23" title="23"></a>
<a class="sourceLine" id="cb2-24" title="24">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-25" title="25">        vIndex <span class="ot">&lt;-</span> <span class="fu">read</span> indices v</a>
<a class="sourceLine" id="cb2-26" title="26">        when (isNothing vIndex) <span class="op">$</span></a>
<a class="sourceLine" id="cb2-27" title="27">            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb2-28" title="28"></a>
<a class="sourceLine" id="cb2-29" title="29">    readSTRef output</a>
<a class="sourceLine" id="cb2-30" title="30">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-31" title="31">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-32" title="32"></a>
<a class="sourceLine" id="cb2-33" title="33">strongConnect</a>
<a class="sourceLine" id="cb2-34" title="34"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-35" title="35">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-36" title="36">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb2-37" title="37">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-38" title="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb2-39" title="39">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-40" title="40">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb2-41" title="41">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb2-42" title="42">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb2-43" title="43">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb2-44" title="44">strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-45" title="45">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb2-46" title="46">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb2-47" title="47">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb2-48" title="48">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb2-49" title="49">    push stack stackSet v</a>
<a class="sourceLine" id="cb2-50" title="50"></a>
<a class="sourceLine" id="cb2-51" title="51">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb2-52" title="52">        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-53" title="53">            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb2-54" title="54">            vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</a>
<a class="sourceLine" id="cb2-55" title="55">            wLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks w</a>
<a class="sourceLine" id="cb2-56" title="56">            write lowlinks v (<span class="dt">Just</span> (<span class="fu">min</span> vLowLink wLowLink))</a>
<a class="sourceLine" id="cb2-57" title="57">        <span class="dt">Just</span> wIndex <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-58" title="58">            wOnStack <span class="ot">&lt;-</span> <span class="fu">read</span> stackSet w</a>
<a class="sourceLine" id="cb2-59" title="59">            when wOnStack <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-60" title="60">                vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</a>
<a class="sourceLine" id="cb2-61" title="61">                write lowlinks v (<span class="dt">Just</span> (<span class="fu">min</span> vLowLink wIndex))</a>
<a class="sourceLine" id="cb2-62" title="62"></a>
<a class="sourceLine" id="cb2-63" title="63">    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</a>
<a class="sourceLine" id="cb2-64" title="64">    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices  v</a>
<a class="sourceLine" id="cb2-65" title="65">    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-66" title="66">        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</a>
<a class="sourceLine" id="cb2-67" title="67">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb2-68" title="68"></a>
<a class="sourceLine" id="cb2-69" title="69"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb2-70" title="70">addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb2-71" title="71">    <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb2-72" title="72">    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</a>
<a class="sourceLine" id="cb2-73" title="73"></a>
<a class="sourceLine" id="cb2-74" title="74"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb2-75" title="75">push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-76" title="76">    modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb2-77" title="77">    write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb2-78" title="78"></a>
<a class="sourceLine" id="cb2-79" title="79"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-80" title="80">pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-81" title="81">    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb2-82" title="82">    modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb2-83" title="83">    write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-84" title="84">    <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb2-85" title="85"></a>
<a class="sourceLine" id="cb2-86" title="86">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb2-87" title="87">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb2-88" title="88">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb2-89" title="89">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb2-90" title="90"></a>
<a class="sourceLine" id="cb2-91" title="91"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-92" title="92">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-93" title="93">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb2-94" title="94">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb2-95" title="95">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb2-96" title="96">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb2-97" title="97">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>I didn’t notice a significant difference in speed on my inputs, but it’s good to know that the algorithm has been implemented with the correct asymptotics now!</p>
<p><em>Sidenote: A <code>Vector</code> of <code>Bool</code>s can be much more compactly represented as a sequence of 0s and 1s, which are just machine words. For implementations of this in Haskell, see the <a href="https://hackage.haskell.org/package/bv">bv</a> or <a href="https://hackage.haskell.org/package/bv-little">bv-little</a> packages. Using these could be another possible refactoring.</em></p>
<p>Looking at the code again, I notice some repetition of the form</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">x <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorX i</a>
<a class="sourceLine" id="cb3-2" title="2">y <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorY j</a>
<a class="sourceLine" id="cb3-3" title="3">write vectorZ k (<span class="dt">Just</span> (operation x y))</a></code></pre></div>
<p>and with the judicious use of <code>(=&lt;&lt;)</code> and <code>(&lt;*&gt;)</code> this can instead be</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">write vectorZ k <span class="op">=&lt;&lt;</span> (operation <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorX i <span class="op">&lt;*&gt;</span> <span class="fu">lookup</span> vectorY j)</a></code></pre></div>
<p>There are a couple of other places we could use <code>(&lt;*&gt;)</code>:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>(&lt;*&gt;)</code></summary></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_, when)</a>
<a class="sourceLine" id="cb5-12" title="12"><span class="kw">import</span> <span class="dt">Data.Maybe</span>          (isJust, isNothing, fromJust)</a>
<a class="sourceLine" id="cb5-13" title="13"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb5-16" title="16">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-18" title="18">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb5-19" title="19">    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb5-20" title="20">    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb5-21" title="21">    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb5-22" title="22">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb5-23" title="23"></a>
<a class="sourceLine" id="cb5-24" title="24">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-25" title="25">        vIndex <span class="ot">&lt;-</span> <span class="fu">read</span> indices v</a>
<a class="sourceLine" id="cb5-26" title="26">        when (isNothing vIndex) <span class="op">$</span></a>
<a class="sourceLine" id="cb5-27" title="27">            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb5-28" title="28"></a>
<a class="sourceLine" id="cb5-29" title="29">    readSTRef output</a>
<a class="sourceLine" id="cb5-30" title="30">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-31" title="31">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-32" title="32"></a>
<a class="sourceLine" id="cb5-33" title="33">strongConnect</a>
<a class="sourceLine" id="cb5-34" title="34"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-35" title="35">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-36" title="36">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb5-37" title="37">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-38" title="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb5-39" title="39">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-40" title="40">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb5-41" title="41">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb5-42" title="42">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb5-43" title="43">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb5-44" title="44">strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-45" title="45">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb5-46" title="46">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb5-47" title="47">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb5-48" title="48">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-49" title="49">    push stack stackSet v</a>
<a class="sourceLine" id="cb5-50" title="50"></a>
<a class="sourceLine" id="cb5-51" title="51">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb5-52" title="52">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-53" title="53">            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb5-54" title="54">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</a>
<a class="sourceLine" id="cb5-55" title="55">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-56" title="56">            wOnStack <span class="ot">&lt;-</span> <span class="fu">read</span> stackSet w</a>
<a class="sourceLine" id="cb5-57" title="57">            when wOnStack <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-58" title="58">                write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices w)</a>
<a class="sourceLine" id="cb5-59" title="59"></a>
<a class="sourceLine" id="cb5-60" title="60">    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</a>
<a class="sourceLine" id="cb5-61" title="61">    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices  v</a>
<a class="sourceLine" id="cb5-62" title="62">    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-63" title="63">        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</a>
<a class="sourceLine" id="cb5-64" title="64">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb5-65" title="65"></a>
<a class="sourceLine" id="cb5-66" title="66"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb5-67" title="67">addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb5-68" title="68">    <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb5-69" title="69">    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</a>
<a class="sourceLine" id="cb5-70" title="70"></a>
<a class="sourceLine" id="cb5-71" title="71"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb5-72" title="72">push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-73" title="73">    modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb5-74" title="74">    write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb5-75" title="75"></a>
<a class="sourceLine" id="cb5-76" title="76"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-77" title="77">pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-78" title="78">    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb5-79" title="79">    modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb5-80" title="80">    write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb5-81" title="81">    <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb5-82" title="82"></a>
<a class="sourceLine" id="cb5-83" title="83">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb5-84" title="84">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb5-85" title="85">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb5-86" title="86">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb5-87" title="87"></a>
<a class="sourceLine" id="cb5-88" title="88"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-89" title="89">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-90" title="90">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb5-91" title="91">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb5-92" title="92">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb5-93" title="93">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb5-94" title="94">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>This is much nicer with the applicative combinators.</p>
<p>I would like to clean up that <code>when</code> as well, and for that I’d need a function like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a></code></pre></div>
<p>which is <a href="hackage.haskell.org/package/extra/docs/Control-Monad-Extra.html#v:whenM">available in Neil Mitchell’s <code>extra</code> package</a>.</p>
<p>I don’t think it’s worth pulling in that dependency though, so I’ll just copy that definition:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>whenM</code></summary></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb7-12" title="12"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb7-15" title="15">whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb7-16" title="16"></a>
<a class="sourceLine" id="cb7-17" title="17"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb7-18" title="18">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-19" title="19">    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-20" title="20">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb7-21" title="21">    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb7-22" title="22">    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-23" title="23">    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-24" title="24">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb7-25" title="25"></a>
<a class="sourceLine" id="cb7-26" title="26">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-27" title="27">        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span></a>
<a class="sourceLine" id="cb7-28" title="28">            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb7-29" title="29"></a>
<a class="sourceLine" id="cb7-30" title="30">    readSTRef output</a>
<a class="sourceLine" id="cb7-31" title="31">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-32" title="32">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-33" title="33"></a>
<a class="sourceLine" id="cb7-34" title="34">strongConnect</a>
<a class="sourceLine" id="cb7-35" title="35"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-36" title="36">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-37" title="37">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb7-38" title="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-39" title="39">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb7-40" title="40">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-41" title="41">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-42" title="42">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-43" title="43">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb7-44" title="44">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb7-45" title="45">strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-46" title="46">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb7-47" title="47">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb7-48" title="48">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb7-49" title="49">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb7-50" title="50">    push stack stackSet v</a>
<a class="sourceLine" id="cb7-51" title="51"></a>
<a class="sourceLine" id="cb7-52" title="52">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb7-53" title="53">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-54" title="54">            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb7-55" title="55">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</a>
<a class="sourceLine" id="cb7-56" title="56">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></a>
<a class="sourceLine" id="cb7-57" title="57">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</a>
<a class="sourceLine" id="cb7-58" title="58"></a>
<a class="sourceLine" id="cb7-59" title="59">    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-60" title="60">        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</a>
<a class="sourceLine" id="cb7-61" title="61">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb7-62" title="62"></a>
<a class="sourceLine" id="cb7-63" title="63"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb7-64" title="64">addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb7-65" title="65">    <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb7-66" title="66">    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</a>
<a class="sourceLine" id="cb7-67" title="67"></a>
<a class="sourceLine" id="cb7-68" title="68"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb7-69" title="69">push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-70" title="70">    modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb7-71" title="71">    write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb7-72" title="72"></a>
<a class="sourceLine" id="cb7-73" title="73"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-74" title="74">pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-75" title="75">    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb7-76" title="76">    modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb7-77" title="77">    write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb7-78" title="78">    <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb7-79" title="79"></a>
<a class="sourceLine" id="cb7-80" title="80">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb7-81" title="81">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb7-82" title="82">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb7-83" title="83">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb7-84" title="84"></a>
<a class="sourceLine" id="cb7-85" title="85"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-86" title="86">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-87" title="87">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb7-88" title="88">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb7-89" title="89">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb7-90" title="90">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb7-91" title="91">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>Now I don’t actually even need <code>when</code> anymore!</p>
<p>Since most of the auxiliary functions aren’t used outside <code>strongConnect</code>, it might make sense to put them under a <code>where</code> clause. This would also make the parameters passed to <code>strongConnect</code> available to these functions. This is one place that the <code>ScopedTypeVariables</code> language extension is necessary, otherwise GHC can’t tell that the <code>s</code> in the type signature of <code>strongConnect</code> is the same <code>s</code> as the one in each type signature under the <code>where</code> clause.</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>where</code></summary></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb8-9" title="9"></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb8-13" title="13"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb8-14" title="14"></a>
<a class="sourceLine" id="cb8-15" title="15"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb8-16" title="16">whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb8-17" title="17"></a>
<a class="sourceLine" id="cb8-18" title="18"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb8-19" title="19">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-20" title="20">    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-21" title="21">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb8-22" title="22">    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb8-23" title="23">    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb8-24" title="24">    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb8-25" title="25">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb8-26" title="26"></a>
<a class="sourceLine" id="cb8-27" title="27">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-28" title="28">        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span></a>
<a class="sourceLine" id="cb8-29" title="29">            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb8-30" title="30"></a>
<a class="sourceLine" id="cb8-31" title="31">    readSTRef output</a>
<a class="sourceLine" id="cb8-32" title="32">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-33" title="33">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-34" title="34"></a>
<a class="sourceLine" id="cb8-35" title="35">strongConnect</a>
<a class="sourceLine" id="cb8-36" title="36"><span class="ot">    ::</span> <span class="kw">forall</span> s</a>
<a class="sourceLine" id="cb8-37" title="37">    <span class="op">.</span>  <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-38" title="38">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-39" title="39">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb8-40" title="40">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-41" title="41">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb8-42" title="42">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb8-43" title="43">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb8-44" title="44">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb8-45" title="45">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb8-46" title="46">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb8-47" title="47">strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-48" title="48">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb8-49" title="49">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb8-50" title="50">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb8-51" title="51">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-52" title="52">    push v</a>
<a class="sourceLine" id="cb8-53" title="53"></a>
<a class="sourceLine" id="cb8-54" title="54">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb8-55" title="55">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-56" title="56">            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb8-57" title="57">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</a>
<a class="sourceLine" id="cb8-58" title="58">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></a>
<a class="sourceLine" id="cb8-59" title="59">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</a>
<a class="sourceLine" id="cb8-60" title="60"></a>
<a class="sourceLine" id="cb8-61" title="61">    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-62" title="62">        scc <span class="ot">&lt;-</span> addSCC n v []</a>
<a class="sourceLine" id="cb8-63" title="63">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb8-64" title="64">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-65" title="65"><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb8-66" title="66">        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb8-67" title="67">            <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb8-68" title="68">            <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39;</a>
<a class="sourceLine" id="cb8-69" title="69"><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb8-70" title="70">        push e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-71" title="71">            modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb8-72" title="72">            write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb8-73" title="73"><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-74" title="74">        pop <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-75" title="75">            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb8-76" title="76">            modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb8-77" title="77">            write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb8-78" title="78">            <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb8-79" title="79"></a>
<a class="sourceLine" id="cb8-80" title="80">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb8-81" title="81">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb8-82" title="82">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb8-83" title="83">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb8-84" title="84"></a>
<a class="sourceLine" id="cb8-85" title="85"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb8-86" title="86">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-87" title="87">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb8-88" title="88">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb8-89" title="89">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb8-90" title="90">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb8-91" title="91">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>I think the logic is clearer now that the auxiliary functions take fewer arguments.</p>
<p>Instead of a large number of implictly related variables, it might be nice to define a single product type containing our entire environment and pass just one value around. With <code>NamedFieldPuns</code> only minimal code changes are required:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>NamedFieldPuns</code></summary></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb9-10" title="10"></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb9-12" title="12"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb9-13" title="13"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb9-14" title="14"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb9-15" title="15"></a>
<a class="sourceLine" id="cb9-16" title="16"><span class="kw">data</span> <span class="dt">TarjanEnv</span> s <span class="ot">=</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb9-17" title="17">    {<span class="ot"> index    ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-18" title="18">    ,<span class="ot"> stack    ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb9-19" title="19">    ,<span class="ot"> stackSet ::</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb9-20" title="20">    ,<span class="ot"> indices  ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb9-21" title="21">    ,<span class="ot"> lowlinks ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb9-22" title="22">    ,<span class="ot"> output   ::</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb9-23" title="23">    }</a>
<a class="sourceLine" id="cb9-24" title="24"></a>
<a class="sourceLine" id="cb9-25" title="25"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb9-26" title="26">whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb9-27" title="27"></a>
<a class="sourceLine" id="cb9-28" title="28"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb9-29" title="29">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-30" title="30">    tarjanEnv <span class="ot">&lt;-</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb9-31" title="31">        <span class="op">&lt;$&gt;</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb9-32" title="32">        <span class="op">&lt;*&gt;</span> newSTRef []</a>
<a class="sourceLine" id="cb9-33" title="33">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb9-34" title="34">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-35" title="35">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-36" title="36">        <span class="op">&lt;*&gt;</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb9-37" title="37"></a>
<a class="sourceLine" id="cb9-38" title="38">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-39" title="39">        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> (indices tarjanEnv) v) <span class="op">$</span></a>
<a class="sourceLine" id="cb9-40" title="40">            strongConnect n v graph tarjanEnv</a>
<a class="sourceLine" id="cb9-41" title="41"></a>
<a class="sourceLine" id="cb9-42" title="42">    readSTRef (output tarjanEnv)</a>
<a class="sourceLine" id="cb9-43" title="43">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-44" title="44">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-45" title="45"></a>
<a class="sourceLine" id="cb9-46" title="46"><span class="ot">strongConnect ::</span> <span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">TarjanEnv</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb9-47" title="47">strongConnect n v graph tarjanEnv<span class="op">@</span><span class="dt">TarjanEnv</span>{ <span class="fu">index</span>, stack, stackSet, indices, lowlinks, output } <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-48" title="48">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb9-49" title="49">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb9-50" title="50">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb9-51" title="51">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb9-52" title="52">    push v</a>
<a class="sourceLine" id="cb9-53" title="53"></a>
<a class="sourceLine" id="cb9-54" title="54">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb9-55" title="55">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-56" title="56">            strongConnect n w graph tarjanEnv</a>
<a class="sourceLine" id="cb9-57" title="57">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</a>
<a class="sourceLine" id="cb9-58" title="58">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></a>
<a class="sourceLine" id="cb9-59" title="59">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</a>
<a class="sourceLine" id="cb9-60" title="60"></a>
<a class="sourceLine" id="cb9-61" title="61">    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-62" title="62">        scc <span class="ot">&lt;-</span> addSCC n v []</a>
<a class="sourceLine" id="cb9-63" title="63">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb9-64" title="64">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-65" title="65"><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb9-66" title="66">        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb9-67" title="67">            <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb9-68" title="68">            <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39;</a>
<a class="sourceLine" id="cb9-69" title="69"><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb9-70" title="70">        push e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-71" title="71">            modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb9-72" title="72">            write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb9-73" title="73"><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-74" title="74">        pop <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-75" title="75">            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb9-76" title="76">            modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb9-77" title="77">            write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb9-78" title="78">            <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb9-79" title="79"></a>
<a class="sourceLine" id="cb9-80" title="80">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb9-81" title="81">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb9-82" title="82">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb9-83" title="83">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb9-84" title="84"></a>
<a class="sourceLine" id="cb9-85" title="85"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb9-86" title="86">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-87" title="87">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb9-88" title="88">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb9-89" title="89">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb9-90" title="90">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb9-91" title="91">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>Let’s pause here. Although more refactoring is certainly possible, my last two steps did not reduce the line count and may have in fact made the code harder to understand.</p>
<p>How have we benefited from this refactoring? Aside from the code being shorter and better structured, it’s now easier to make meaningful improvements. For example, this implementation is more inefficient than it needs to be, because it doesn’t short-circuit when it finds that the current problem is unsatisfiable. Instead it works through the rest of the problem, only to throw all that work away. A sophisticated solution to this problem might involve the use of the <a href="https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-Except.html"><code>ExceptT</code></a> monad transformer to throw an exception and exit early, but there is a simpler approach: we can store an extra boolean variable denoting whether or not the current problem is possibly satisfiable, and only continue working if it is. I’ll call this variable <code>possible</code>, update it in <code>addSCC</code>, and check for it before each call to <code>strongConnect</code> in <code>tarjan</code>. It takes more effort to reformat the code than to make this change:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs with short-circuiting</summary></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb10-4" title="4"></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb10-10" title="10"></a>
<a class="sourceLine" id="cb10-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb10-12" title="12"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb10-13" title="13"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb10-14" title="14"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb10-15" title="15"></a>
<a class="sourceLine" id="cb10-16" title="16"><span class="kw">data</span> <span class="dt">TarjanEnv</span> s <span class="ot">=</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb10-17" title="17">    {<span class="ot"> index    ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-18" title="18">    ,<span class="ot"> stack    ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb10-19" title="19">    ,<span class="ot"> stackSet ::</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-20" title="20">    ,<span class="ot"> indices  ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb10-21" title="21">    ,<span class="ot"> lowlinks ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb10-22" title="22">    ,<span class="ot"> output   ::</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb10-23" title="23">    ,<span class="ot"> possible ::</span> <span class="dt">STRef</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-24" title="24">    }</a>
<a class="sourceLine" id="cb10-25" title="25"></a>
<a class="sourceLine" id="cb10-26" title="26"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb10-27" title="27">whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb10-28" title="28"></a>
<a class="sourceLine" id="cb10-29" title="29"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb10-30" title="30">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-31" title="31">    tarjanEnv <span class="ot">&lt;-</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb10-32" title="32">        <span class="op">&lt;$&gt;</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb10-33" title="33">        <span class="op">&lt;*&gt;</span> newSTRef []</a>
<a class="sourceLine" id="cb10-34" title="34">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb10-35" title="35">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-36" title="36">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-37" title="37">        <span class="op">&lt;*&gt;</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb10-38" title="38">        <span class="op">&lt;*&gt;</span> newSTRef <span class="dt">True</span></a>
<a class="sourceLine" id="cb10-39" title="39"></a>
<a class="sourceLine" id="cb10-40" title="40">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-41" title="41">        whenM ((<span class="op">&amp;&amp;</span>)</a>
<a class="sourceLine" id="cb10-42" title="42">            <span class="op">&lt;$&gt;</span> ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> (indices tarjanEnv) v)</a>
<a class="sourceLine" id="cb10-43" title="43">            <span class="op">&lt;*&gt;</span> readSTRef (possible tarjanEnv)) <span class="op">$</span></a>
<a class="sourceLine" id="cb10-44" title="44">                strongConnect n v graph tarjanEnv</a>
<a class="sourceLine" id="cb10-45" title="45"></a>
<a class="sourceLine" id="cb10-46" title="46">    readSTRef (output tarjanEnv)</a>
<a class="sourceLine" id="cb10-47" title="47">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-48" title="48">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb10-49" title="49"></a>
<a class="sourceLine" id="cb10-50" title="50"><span class="ot">strongConnect ::</span> <span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">TarjanEnv</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb10-51" title="51">strongConnect n v graph tarjanEnv<span class="op">@</span><span class="dt">TarjanEnv</span>{ <span class="fu">index</span>, stack, stackSet, indices, lowlinks, output, possible } <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-52" title="52">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb10-53" title="53">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb10-54" title="54">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb10-55" title="55">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-56" title="56">    push v</a>
<a class="sourceLine" id="cb10-57" title="57"></a>
<a class="sourceLine" id="cb10-58" title="58">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb10-59" title="59">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-60" title="60">            strongConnect n w graph tarjanEnv</a>
<a class="sourceLine" id="cb10-61" title="61">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</a>
<a class="sourceLine" id="cb10-62" title="62">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></a>
<a class="sourceLine" id="cb10-63" title="63">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</a>
<a class="sourceLine" id="cb10-64" title="64"></a>
<a class="sourceLine" id="cb10-65" title="65">    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-66" title="66">        scc <span class="ot">&lt;-</span> addSCC n v []</a>
<a class="sourceLine" id="cb10-67" title="67">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb10-68" title="68">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-69" title="69"><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb10-70" title="70">        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc)</a>
<a class="sourceLine" id="cb10-71" title="71">            <span class="kw">then</span> writeSTRef possible <span class="dt">False</span> <span class="op">&gt;&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-72" title="72">            <span class="kw">else</span></a>
<a class="sourceLine" id="cb10-73" title="73">                <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb10-74" title="74">                <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39;</a>
<a class="sourceLine" id="cb10-75" title="75"><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb10-76" title="76">        push e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-77" title="77">            modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb10-78" title="78">            write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb10-79" title="79"><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-80" title="80">        pop <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-81" title="81">            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb10-82" title="82">            modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb10-83" title="83">            write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb10-84" title="84">            <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb10-85" title="85"></a>
<a class="sourceLine" id="cb10-86" title="86">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb10-87" title="87">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb10-88" title="88">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb10-89" title="89">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb10-90" title="90"></a>
<a class="sourceLine" id="cb10-91" title="91"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-92" title="92">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-93" title="93">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb10-94" title="94">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb10-95" title="95">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb10-96" title="96">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb10-97" title="97">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>This change does seem to make a significant difference, and it’s good to know we’re not doing useless work.</p>
<p>I think this is a good place to stop, and I hope I’ve been able to demonstrate some of Haskell’s strengths when it comes to refactoring. In my experience, it’s not usually necessary to deeply understand Haskell code in order to attempt a refactoring, especially if it’s backed by well-chosen types and a good test suite. I also find that I’m able to be more daring when writing new code, because bad up-front design is less costly and even the jankiest working code can be gently massaged into something presentable.</p>
<p><em>Thanks to <a href="https://joelburget.com/">Joel Burget</a>, <a href="http://www.matfournier.com/">Mat Fournier</a>, <a href="https://eskimor.gonimo.com/">Robert Klotzner</a>, <a href="https://github.com/L8D">Tenor</a>, <a href="http://www.tomharding.me/">Tom Harding</a>, and <a href="http://www.tylerweir.com/">Tyler Weir</a> for suggestions and feedback.</em></p>
]]></summary>
</entry>
<entry>
    <title>Moving Towards Dialogue</title>
    <link href="https://vaibhavsagar.com/blog/2018/11/03/moving-towards-dialogue/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/11/03/moving-towards-dialogue/index.html</id>
    <published>2018-11-03T00:00:00Z</published>
    <updated>2018-11-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on  3 November 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/idris/index.html">idris</a>
    
</div>

<p><em>This blog post is essentially a transcript of <a href="https://www.youtube.com/watch?v=0oo8wIi2qBE">a 10-minute talk I gave at !!Con</a>, the slides for which are available <a href="https://vaibhavsagar.com/presentations/typed-holes/">here</a>.</em></p>
<p>Let’s talk about typed holes. What’s a typed hole? A definition I like is <em>“a placeholder for an expression with a known type and an unknown value”</em>.</p>
<p>Why are typed holes useful? Because they allow the language to help us write programs! To demonstrate, let’s look at some code in Python, a language that lacks this feature.</p>
<p>Suppose I want to write a function that takes another function and a list and applies the function to each element of that list. A first stab might look like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): <span class="cf">return</span> []</a></code></pre></div>
<p>This is obviously wrong: this function ignores its arguments and gives us an empty list each time. This is no good, but what’s worse is that Python will accept this definition without complaint. It doesn’t seem to know (or care).</p>
<p>Let’s try again. I hear the way to do things with lists in Python is to use a list comprehension, so I make sure to use one of those this time:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): [f(e) <span class="cf">for</span> e <span class="kw">in</span> ls]</a>
<a class="sourceLine" id="cb2-2" title="2">...</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="op">&gt;&gt;&gt;</span> plusOne <span class="op">=</span> <span class="kw">lambda</span> i: i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(<span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]))</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="va">None</span></a></code></pre></div>
<p>But this definition is still wrong, because I forgot to put a <code>return</code> statement in! Again, Python will happily accept this.</p>
<p>I’m getting a bit frustrated at this point, so I look at how <code>map</code> is actually implemented. It uses a generator comprehension instead of a list comprehension, which makes it more general somehow, so I make sure to use that, and I remember to put a <code>return</code> statement in this time:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): <span class="cf">return</span> (f(e) <span class="cf">for</span> e <span class="kw">in</span> ls)</a>
<a class="sourceLine" id="cb3-2" title="2">...</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(<span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]))</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="op">&lt;</span>generator <span class="bu">object</span> <span class="bu">map</span>.<span class="op">&lt;</span><span class="bu">locals</span><span class="op">&gt;</span>.<span class="op">&lt;</span>genexpr<span class="op">&gt;</span> at <span class="bn">0x7ffb92103ca8</span><span class="op">&gt;</span></a></code></pre></div>
<p>And now instead of giving me something useful, this function gives me an address in memory, which seems especially pointless.</p>
<p>I give up. This example seems contrived, but over the course of my relationship with Python, which is more than a decade long now, I’ve seen the same dynamic play out embarrassingly many times. How do I write programs that work? Surely this is a simple question with a straightforward answer.</p>
<p>Indeed, the most common response I get when I ask this question is to write tests. That sounds reasonable, so let’s do that:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls):</a>
<a class="sourceLine" id="cb4-2" title="2">...     <span class="bu">print</span>(<span class="st">&quot;Where are your tests now?&quot;</span>)</a>
<a class="sourceLine" id="cb4-3" title="3">...     <span class="cf">return</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb4-4" title="4">...</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb4-6" title="6">Where are your tests now?</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="va">True</span></a></code></pre></div>
<p>Okay, my test passes, so everything must be good, right?</p>
<p>I contend that tests are necessary, but not sufficient. They are problematic for at least two reasons:</p>
<ol type="1">
<li>They are only as good as the specification they imply for how a program should behave. If that specification is incomplete or wrong, no amount of tests will guarantee software that works.</li>
<li>The language doesn’t understand tests, by which I mean that it’s extremely difficult to automatically go from a failing test to the part of the code where the error lives. The programmer has to do the legwork of tracking down the bug based on essentially one bit of information in many cases.</li>
</ol>
<p>Fortunately, tests aren’t the only specification of how a program should behave. Types can also serve as specifications, and they have the advantage that they are extremely well integrated into the language in a way tests usually are not.</p>
<p>What does this mean in practice? Let’s look at Haskell. Haskell is statically typed, which means it expects to know the types of all the expressions in your program at compile time. This is nothing special though, lots of other languages also claim to be statically typed. What is special about Haskell though is that it has type inference, which means that you don’t have to annotate expressions with their types most of the time because the compiler can figure it out. If you put these two features together, you get typed holes!</p>
<p>Let’s try to write that same program in Haskell with typed holes. To start, let’s create a file called <code>Main.hs</code> with the following contents:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="fu">map</span> f ls <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-7" title="7">plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-10" title="10">main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>To automate the cycle of loading this file into GHCi every time we make a change, we’re going to use <a href="https://github.com/ndmitchell/ghcid"><code>ghcid</code></a>, which does essentially that and not much else. This is the result of running <code>ghcid Main.hs</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb6-1" title="1">Main.hs:4:12: error:</a>
<a class="sourceLine" id="cb6-2" title="2">    • Found hole: _ :: [b]</a>
<a class="sourceLine" id="cb6-3" title="3">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb6-4" title="4">               the type signature for:</a>
<a class="sourceLine" id="cb6-5" title="5">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb6-6" title="6">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb6-7" title="7">    • In the expression: _</a>
<a class="sourceLine" id="cb6-8" title="8">      In an equation for ‘map’: map f ls = _</a>
<a class="sourceLine" id="cb6-9" title="9">    • Relevant bindings include</a>
<a class="sourceLine" id="cb6-10" title="10">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb6-11" title="11">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb6-12" title="12">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb6-13" title="13">  |</a>
<a class="sourceLine" id="cb6-14" title="14">4 | map f ls = _</a>
<a class="sourceLine" id="cb6-15" title="15">  |            ^</a></code></pre></div>
<p>I’d suggest ignoring the middle and instead focusing on the top, which tells us the type of the hole, and the bottom, which tells us which bindings are in scope that we can use to fill in the hole.</p>
<p>In this case we aren’t learning anything new, and we already know that the hole is of type <code>[b]</code>, but it’s useful to know that our view of the world agrees with GHC’s. Of the bindings available to us, <code>ls</code> looks like the most promising, and we can split it into one of two cases: an empty list, or some element and the rest of the list. We can put a typed hole on the right hand side of each case alternative:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb7-4" title="4"><span class="fu">map</span> f ls <span class="ot">=</span> <span class="kw">case</span> ls <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-5" title="5">    [] <span class="ot">-&gt;</span> _1</a>
<a class="sourceLine" id="cb7-6" title="6">    x<span class="op">:</span>xs <span class="ot">-&gt;</span> _2</a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-9" title="9">plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-12" title="12">main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>And our <code>ghcid</code> output changes:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb8-1" title="1">Main.hs:5:11-12: error:</a>
<a class="sourceLine" id="cb8-2" title="2">    • Found hole: _1 :: [b]</a>
<a class="sourceLine" id="cb8-3" title="3">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb8-4" title="4">               the type signature for:</a>
<a class="sourceLine" id="cb8-5" title="5">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb8-6" title="6">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb8-7" title="7">      Or perhaps ‘_1’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb8-8" title="8">    • In the expression: _1</a>
<a class="sourceLine" id="cb8-9" title="9">      In a case alternative: [] -&gt; _1</a>
<a class="sourceLine" id="cb8-10" title="10">      In the expression:</a>
<a class="sourceLine" id="cb8-11" title="11">        case ls of</a>
<a class="sourceLine" id="cb8-12" title="12">          [] -&gt; _1</a>
<a class="sourceLine" id="cb8-13" title="13">          x : xs -&gt; _2</a>
<a class="sourceLine" id="cb8-14" title="14">    • Relevant bindings include</a>
<a class="sourceLine" id="cb8-15" title="15">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb8-16" title="16">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb8-17" title="17">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb8-18" title="18">  |</a>
<a class="sourceLine" id="cb8-19" title="19">5 |     [] -&gt; _1</a>
<a class="sourceLine" id="cb8-20" title="20">  |           ^^</a>
<a class="sourceLine" id="cb8-21" title="21">Main.hs:6:13-14: error:</a>
<a class="sourceLine" id="cb8-22" title="22">    • Found hole: _2 :: [b]</a>
<a class="sourceLine" id="cb8-23" title="23">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb8-24" title="24">               the type signature for:</a>
<a class="sourceLine" id="cb8-25" title="25">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb8-26" title="26">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb8-27" title="27">      Or perhaps ‘_2’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb8-28" title="28">    • In the expression: _2</a>
<a class="sourceLine" id="cb8-29" title="29">      In a case alternative: x : xs -&gt; _2</a>
<a class="sourceLine" id="cb8-30" title="30">      In the expression:</a>
<a class="sourceLine" id="cb8-31" title="31">        case ls of</a>
<a class="sourceLine" id="cb8-32" title="32">          [] -&gt; _1</a>
<a class="sourceLine" id="cb8-33" title="33">          x : xs -&gt; _2</a>
<a class="sourceLine" id="cb8-34" title="34">    • Relevant bindings include</a>
<a class="sourceLine" id="cb8-35" title="35">        xs :: [a] (bound at Main.hs:6:7)</a>
<a class="sourceLine" id="cb8-36" title="36">        x :: a (bound at Main.hs:6:5)</a>
<a class="sourceLine" id="cb8-37" title="37">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb8-38" title="38">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb8-39" title="39">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb8-40" title="40">  |</a>
<a class="sourceLine" id="cb8-41" title="41">6 |     x:xs -&gt; _2</a>
<a class="sourceLine" id="cb8-42" title="42">  |             ^^</a></code></pre></div>
<p>We haven’t learned anything new about the types, but we can make progress another way. The only sensible thing to put on the right hand side when given an empty list is another empty list, and after splitting a list apart the most reasonable thing to do is to combine two other things into a new list:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb9-4" title="4"><span class="fu">map</span> f ls <span class="ot">=</span> <span class="kw">case</span> ls <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-5" title="5">    [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb9-6" title="6">    x<span class="op">:</span>xs <span class="ot">-&gt;</span> _1<span class="op">:</span>_2</a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-9" title="9">plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-10" title="10"></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-12" title="12">main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Now the output gets a little more interesting:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb10-1" title="1">Main.hs:6:13-14: error:</a>
<a class="sourceLine" id="cb10-2" title="2">    • Found hole: _1 :: b</a>
<a class="sourceLine" id="cb10-3" title="3">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb10-4" title="4">               the type signature for:</a>
<a class="sourceLine" id="cb10-5" title="5">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb10-6" title="6">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb10-7" title="7">      Or perhaps ‘_1’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb10-8" title="8">    • In the first argument of ‘(:)’, namely ‘_1’</a>
<a class="sourceLine" id="cb10-9" title="9">      In the expression: _1 : _2</a>
<a class="sourceLine" id="cb10-10" title="10">      In a case alternative: x : xs -&gt; _1 : _2</a>
<a class="sourceLine" id="cb10-11" title="11">    • Relevant bindings include</a>
<a class="sourceLine" id="cb10-12" title="12">        xs :: [a] (bound at Main.hs:6:7)</a>
<a class="sourceLine" id="cb10-13" title="13">        x :: a (bound at Main.hs:6:5)</a>
<a class="sourceLine" id="cb10-14" title="14">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb10-15" title="15">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb10-16" title="16">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb10-17" title="17">  |</a>
<a class="sourceLine" id="cb10-18" title="18">6 |     x:xs -&gt; _1:_2</a>
<a class="sourceLine" id="cb10-19" title="19">  |             ^^</a>
<a class="sourceLine" id="cb10-20" title="20">Main.hs:6:16-17: error:</a>
<a class="sourceLine" id="cb10-21" title="21">    • Found hole: _2 :: [b]</a>
<a class="sourceLine" id="cb10-22" title="22">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb10-23" title="23">               the type signature for:</a>
<a class="sourceLine" id="cb10-24" title="24">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb10-25" title="25">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb10-26" title="26">      Or perhaps ‘_2’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb10-27" title="27">    • In the second argument of ‘(:)’, namely ‘_2’</a>
<a class="sourceLine" id="cb10-28" title="28">      In the expression: _1 : _2</a>
<a class="sourceLine" id="cb10-29" title="29">      In a case alternative: x : xs -&gt; _1 : _2</a>
<a class="sourceLine" id="cb10-30" title="30">    • Relevant bindings include</a>
<a class="sourceLine" id="cb10-31" title="31">        xs :: [a] (bound at Main.hs:6:7)</a>
<a class="sourceLine" id="cb10-32" title="32">        x :: a (bound at Main.hs:6:5)</a>
<a class="sourceLine" id="cb10-33" title="33">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb10-34" title="34">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb10-35" title="35">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb10-36" title="36">  |</a>
<a class="sourceLine" id="cb10-37" title="37">6 |     x:xs -&gt; _1:_2</a>
<a class="sourceLine" id="cb10-38" title="38">  |                ^^</a></code></pre></div>
<p>Our first hole is now of type <code>b</code>, and we see that it’s possible to get a value of this type by applying <code>f</code> to <code>x</code>. The second hole is still of type <code>[b]</code>, and we see that the most reasonable way to get a value of this type is to recurse, using <code>map</code> with <code>f</code> and <code>xs</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb11-2" title="2"></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb11-4" title="4"><span class="fu">map</span> f ls <span class="ot">=</span> <span class="kw">case</span> ls <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-5" title="5">    [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb11-6" title="6">    x<span class="op">:</span>xs <span class="ot">-&gt;</span> f x<span class="op">:</span> <span class="fu">map</span> f xs</a>
<a class="sourceLine" id="cb11-7" title="7"></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-9" title="9">plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-10" title="10"></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-12" title="12">main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>And <code>ghcid</code> is satisfied:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb12-1" title="1">All good (1 module, at &lt;time&gt;)</a></code></pre></div>
<p>It compiles! But does it work?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" title="1">$ <span class="ex">runhaskell</span> Main.hs</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ex">True</span></a></code></pre></div>
<p>Fantastic! We were able to ask the compiler for hints and get useful answers back. This is a gigantic improvement over anything I’m aware of in Python land.</p>
<p>Unfortunately, there is a catch: this program is too easy to break. Let me demonstrate my favourite way:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb14-4" title="4"><span class="fu">map</span> f ls <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb14-5" title="5"></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb14-7" title="7">plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-8" title="8"></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb14-10" title="10">main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>The astute reader will notice that this is the Haskell equivalent of the obviously broken Python program we started with. Here is what <code>ghcid</code> has to say:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb15-1" title="1">All good (1 module, at &lt;time&gt;)</a></code></pre></div>
<p>So what’s going on here? It turns out an empty list is a valid list of any type. Is it a list of Strings? Yup. Is it a list of Ints? Sure!</p>
<p>One way of avoiding this class of incorrect program is to specify that the input and the output lists should be of the same length. It’s possible to do this in Haskell, but it is a lot of work. Can we do better?</p>
<p>Enter Idris.</p>
<p>Idris is a functional programming language with a more sophisticated type system than Haskell’s. Unfortunately it trades off some type inference to achieve this, so it’s not strictly better than Haskell in every way. It has excellent built-in editor support, and therefore has fancier typed holes!</p>
<p>Let’s try to implement <code>map</code> again:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb16-4" title="4"></a>
<a class="sourceLine" id="cb16-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb16-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb16-8" title="8"></a>
<a class="sourceLine" id="cb16-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb16-10" title="10"></a>
<a class="sourceLine" id="cb16-11" title="11"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-12" title="12">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-13" title="13"></a>
<a class="sourceLine" id="cb16-14" title="14"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-15" title="15">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Instead of implementing <code>map</code> on lists, we’ll use a more interesting type called <code>Vect</code> which is essentially a list that knows about its length. A <code>Vect</code> can either be <code>Nil</code> of length <code>0</code> or an element on the front of another <code>Vect</code> of some length <code>length</code> giving us a new <code>Vect</code> of length <code>length + 1</code>. I’ve also gone ahead defined equality on these <code>Vect</code>s because I use it in <code>main</code>.</p>
<p>Loading the file into the Idris REPL gives us access to the editor integration:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb17-1" title="1">$ <span class="ex">idris</span> Main.idr</a>
<a class="sourceLine" id="cb17-2" title="2">     <span class="ex">____</span>    __     _</a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="ex">/</span>  _/___/ /____(_)<span class="ex">____</span></a>
<a class="sourceLine" id="cb17-4" title="4">    <span class="ex">/</span> // __  / ___/ / ___/     Version 1.3.0</a>
<a class="sourceLine" id="cb17-5" title="5">  <span class="ex">_/</span> // /_/ / /  / (__  )      <span class="ex">http</span>://www.idris-lang.org/</a>
<a class="sourceLine" id="cb17-6" title="6"> <span class="ex">/___</span>/\<span class="ex">__</span>,_/_/  /_/____/       Type :? for help</a>
<a class="sourceLine" id="cb17-7" title="7"></a>
<a class="sourceLine" id="cb17-8" title="8"><span class="ex">Idris</span> is free software with ABSOLUTELY NO WARRANTY.</a>
<a class="sourceLine" id="cb17-9" title="9"><span class="ex">For</span> details type :warranty.</a>
<a class="sourceLine" id="cb17-10" title="10"><span class="ex">Type</span> checking ./Main.idr</a>
<a class="sourceLine" id="cb17-11" title="11"><span class="ex">Holes</span>: Main.map</a>
<a class="sourceLine" id="cb17-12" title="12"><span class="ex">*Main</span><span class="op">&gt;</span></a></code></pre></div>
<p>In vim, I can use <code>&lt;localleader&gt;d</code> with the cursor on <code>map</code> to fill in a skeleton definition:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb18-4" title="4"></a>
<a class="sourceLine" id="cb18-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb18-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb18-8" title="8"></a>
<a class="sourceLine" id="cb18-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb18-10" title="10">map f x <span class="fu">=</span> <span class="ot">?map_rhs</span></a>
<a class="sourceLine" id="cb18-11" title="11"></a>
<a class="sourceLine" id="cb18-12" title="12"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-13" title="13">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb18-14" title="14"></a>
<a class="sourceLine" id="cb18-15" title="15"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb18-16" title="16">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Using <code>&lt;localleader&gt;t</code> with the cursor on the typed hole provides a type for us:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb19-1" title="1">  b : Type</a>
<a class="sourceLine" id="cb19-2" title="2">  a : Type</a>
<a class="sourceLine" id="cb19-3" title="3">  f : a -&gt; b</a>
<a class="sourceLine" id="cb19-4" title="4">  length : Nat</a>
<a class="sourceLine" id="cb19-5" title="5">  x : Vect length a</a>
<a class="sourceLine" id="cb19-6" title="6">--------------------------------------</a>
<a class="sourceLine" id="cb19-7" title="7">map_rhs : Vect length b</a></code></pre></div>
<p>But we don’t need to go down this route. We can make Idris do a case-split for us with <code>&lt;localleader&gt;c</code> with the cursor on <code>x</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb20-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb20-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb20-8" title="8"></a>
<a class="sourceLine" id="cb20-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb20-10" title="10">map f [] <span class="fu">=</span> <span class="ot">?map_rhs_1</span></a>
<a class="sourceLine" id="cb20-11" title="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> <span class="ot">?map_rhs_2</span></a>
<a class="sourceLine" id="cb20-12" title="12"></a>
<a class="sourceLine" id="cb20-13" title="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-14" title="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb20-15" title="15"></a>
<a class="sourceLine" id="cb20-16" title="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-17" title="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Again, as with our Haskell example, the only sensible output when the input is an empty <code>Vect</code> is another empty <code>Vect</code>. We think so, but what does Idris think? It has a nifty feature called “proof search” that can search the space of all possible programs that fit and choose the first one. We can use this with <code>&lt;localleader&gt;o</code> (‘o’ is for obvious):</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb21-4" title="4"></a>
<a class="sourceLine" id="cb21-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb21-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb21-8" title="8"></a>
<a class="sourceLine" id="cb21-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb21-10" title="10">map f [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb21-11" title="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> <span class="ot">?map_rhs_2</span></a>
<a class="sourceLine" id="cb21-12" title="12"></a>
<a class="sourceLine" id="cb21-13" title="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb21-14" title="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb21-15" title="15"></a>
<a class="sourceLine" id="cb21-16" title="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb21-17" title="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>And we get the result we expect. This works for the simple case, but does it work for the more complex one?</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb22-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb22-4" title="4"></a>
<a class="sourceLine" id="cb22-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb22-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb22-8" title="8"></a>
<a class="sourceLine" id="cb22-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb22-10" title="10">map f [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb22-11" title="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> f x <span class="ot">::</span> map f y</a>
<a class="sourceLine" id="cb22-12" title="12"></a>
<a class="sourceLine" id="cb22-13" title="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb22-14" title="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-15" title="15"></a>
<a class="sourceLine" id="cb22-16" title="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb22-17" title="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>It does!</p>
<p>What happens when we try to break this like we broke our Haskell program?</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb23-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb23-4" title="4"></a>
<a class="sourceLine" id="cb23-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb23-8" title="8"></a>
<a class="sourceLine" id="cb23-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb23-10" title="10">map f [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb23-11" title="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb23-12" title="12"></a>
<a class="sourceLine" id="cb23-13" title="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb23-14" title="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb23-15" title="15"></a>
<a class="sourceLine" id="cb23-16" title="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb23-17" title="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>This is what Idris has to say:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb24-1" title="1">*Main&gt; :r</a>
<a class="sourceLine" id="cb24-2" title="2">Type checking ./Main.idr</a>
<a class="sourceLine" id="cb24-3" title="3">Main.idr:11:18-19:</a>
<a class="sourceLine" id="cb24-4" title="4">   |</a>
<a class="sourceLine" id="cb24-5" title="5">11 | map f (x :: y) = []</a>
<a class="sourceLine" id="cb24-6" title="6">   |                  ~~</a>
<a class="sourceLine" id="cb24-7" title="7">When checking right hand side of Main.map with expected type</a>
<a class="sourceLine" id="cb24-8" title="8">        Vect (1 + length) b</a>
<a class="sourceLine" id="cb24-9" title="9"></a>
<a class="sourceLine" id="cb24-10" title="10">Type mismatch between</a>
<a class="sourceLine" id="cb24-11" title="11">        Vect 0 a (Type of [])</a>
<a class="sourceLine" id="cb24-12" title="12">and</a>
<a class="sourceLine" id="cb24-13" title="13">        Vect (S length) b (Expected type)</a>
<a class="sourceLine" id="cb24-14" title="14"></a>
<a class="sourceLine" id="cb24-15" title="15">Specifically:</a>
<a class="sourceLine" id="cb24-16" title="16">        Type mismatch between</a>
<a class="sourceLine" id="cb24-17" title="17">                0</a>
<a class="sourceLine" id="cb24-18" title="18">        and</a>
<a class="sourceLine" id="cb24-19" title="19">                S length</a>
<a class="sourceLine" id="cb24-20" title="20"></a>
<a class="sourceLine" id="cb24-21" title="21">Holes: Main.map</a></code></pre></div>
<p>We get a useful and informative error message.</p>
<p>And we’ve done it! You can download and use these languages today. When using other languages with static types, I always felt that they existed merely as busywork and I essentially had to shove them down the compiler’s throat in order to get it to accept my program, and I feel the opposite way about these languages. In other words, types are friends, not food! They can help you design your program, write that program, and even debug it if necessary.</p>
<p>One aspect of programming that always bothered me was my perception of the compiler (or interpreter) as some sort of gatekeeper whose job was to dismiss my program until it met some arbitrary standard. Even worse, I would find myself writing a program that passed but was subtly incorrect, and I would iterate on this process, writing a series of subtly incorrect programs without any guidance from my tools. Discovering typed holes and the style of programming they enable has shown me a different approach, where I can open up a dialogue with my language and collaborate on writing a program whose correctness I am more confident of.</p>
<p>That’s all I have to say about typed holes, but there’s recently been interesting work on untyped holes that I would like to mention briefly. Suppose you like the idea of holes but not the idea of types, or you work in a language that isn’t statically typed and you want some of these benefits. What you could do is:</p>
<ol type="1">
<li>Write a program with gaps where you’re unsure what should happen (we’ll call this a <em>sketch</em>)</li>
<li>Write some test cases that the correct program should satisfy</li>
<li>Feed both these things to a SAT/SMT solver (a clever program with a bag of tricks)</li>
<li>???</li>
<li>Profit!!!</li>
</ol>
<p>The solver churns through the space of all prossible programs and picks the one that passes the tests, giving us the correct program we wanted!</p>
<p>This sounds great in theory, so why aren’t we doing this yet? There is (predictably) a catch, which is that this is still a research topic for now. You can read <a href="https://people.csail.mit.edu/asolar/papers/thesis.pdf">Armando Solar-Lezama’s PhD thesis on this</a>, and systems like <a href="http://comcom.csail.mit.edu/comcom/#Synquid">Synquid</a> and <a href="https://github.com/webyrd/Barliman">Barliman</a> demonstrate the current state of the art. I think it’s especially interesting that Synquid has both typed and untyped holes, which suggests to me that it is the most promising approach.</p>
<p>I’ll leave you with some resources about typed holes, particularly Conor McBride’s presentations at <a href="https://www.youtube.com/watch?v=3U3lV5VPmOU">YOW! Lambda Jam</a> and <a href="https://skillsmatter.com/skillscasts/8893-is-a-type-a-lifebuoy-or-a-lamp">Haskell eXchange</a> that are rich with insight. There’s also <a href="https://www.shimweasel.com/2015/02/17/typed-holes-for-beginners">a tutorial by Mark Wotton</a>, and finally <a href="http://hazel.org/">Hazel</a>, which is a live functional programming environment with typed holes!</p>
<p>I hope I’ve encouraged you to try this style of programming for yourself. There’s never been a better time to do it.</p>
]]></summary>
</entry>
<entry>
    <title>HAMTs from Scratch</title>
    <link href="https://vaibhavsagar.com/blog/2018/07/29/hamts-from-scratch/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/07/29/hamts-from-scratch/index.html</id>
    <published>2018-07-29T00:00:00Z</published>
    <updated>2018-07-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 29 July 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>
    
</div>

<p><em>This blog post is also an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/hamt/HAMTsFromScratch.ipynb">IHaskell notebook</a> and the source is available <a href="https://github.com/vaibhavsagar/notebooks/tree/master/hamt/hamt">separately</a>. I also <a href="https://www.youtube.com/watch?v=wgMgtgVZdYg">did a talk at NYHUG based on this material</a>.</em></p>
<p>I wanted an explanation for HAMTs (Hash Array Mapped Tries) that was more detailed than <a href="https://idea.popcount.org/2012-07-25-introduction-to-hamt/">Marek Majkowski’s introduction</a> and more approachable than <a href="https://lampwww.epfl.ch/papers/idealhashtrees.pdf"><em>Ideal Hash Trees</em> by Phil Bagwell</a>, the paper that introduced them. If you haven’t heard of them before, HAMTs are a way of efficiently representing a hashtable as a <a href="https://en.wikipedia.org/wiki/Trie">trie</a>, and although they were first envisioned as a mutable data structure they are easily adapted to work as a <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structure</a>. They form the backbone of the <a href="http://hackage.haskell.org/package/unordered-containers"><code>unordered-containers</code></a> library but the <a href="https://github.com/tibbe/unordered-containers/blob/efa43a2ab09dc6eb72893d12676a8e188cb4ca63/Data/HashMap/Base.hs">implementation has been lovingly optimised</a> to the point where I found it impenetrable. <a href="https://github.com/ezyang/hamt/blob/a43559795630980eb16ab832a003d8e6acd21cf6/HAMT.hs">Edward Z. Yang’s implementation</a> is much easier to follow and after adapting it I think I’m in a good place to provide my own take on them.</p>
<p>Let’s start with a few imports! I’ll be using these packages:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/base"><code>base</code></a></li>
<li><a href="http://hackage.haskell.org/package/bytestring"><code>bytestring</code></a></li>
<li><a href="http://hackage.haskell.org/package/memory"><code>memory</code></a></li>
<li><a href="http://hackage.haskell.org/package/pretty-show"><code>pretty-show</code></a></li>
<li><a href="http://hackage.haskell.org/package/timeit"><code>timeit</code></a></li>
<li><a href="http://hackage.haskell.org/package/vector"><code>vector</code></a></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="dt">Data.Bits</span>             (<span class="dt">Bits</span> (bit, complement, popCount, shiftR, (.&amp;.), (.|.)),</a>
<a class="sourceLine" id="cb1-2" title="2">                              <span class="dt">FiniteBits</span> (finiteBitSize))</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="dt">Data.ByteArray.Hash</span>   (<span class="dt">FnvHash32</span> (..), fnv1Hash)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="dt">Data.ByteString.Char8</span> (pack)</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="dt">Data.Char</span>             (intToDigit)</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span> <span class="dt">Data.Semigroup</span>        ((&lt;&gt;))</a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">import</span> <span class="dt">Data.Vector</span>           (<span class="dt">Vector</span>, drop, singleton, take, (!), (//))</a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">import</span> <span class="dt">Data.Word</span>             (<span class="dt">Word16</span>, <span class="dt">Word32</span>)</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">import</span> <span class="dt">Numeric</span>               (showIntAtBase)</a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">import</span> <span class="dt">Prelude</span>               <span class="kw">hiding</span> (drop, lookup, take)</a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">import</span> <span class="dt">System.TimeIt</span>         (timeIt)</a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span>      (pPrint)</a></code></pre></div>
<p>We’re going to be doing some bit twiddling. To make this easier to follow I’m going to define a <code>newtype</code> whose <code>Show</code> instance displays the binary representation.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">newtype</span> <span class="dt">Binary</span> a <span class="ot">=</span> <span class="dt">Binary</span> a</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="kw">deriving</span> (<span class="dt">Enum</span>, <span class="dt">Ord</span>, <span class="dt">Real</span>, <span class="dt">Integral</span>, <span class="dt">Eq</span>, <span class="dt">Num</span>, <span class="dt">Bits</span>, <span class="dt">FiniteBits</span>)</a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="kw">instance</span> (<span class="dt">FiniteBits</span> a, <span class="dt">Show</span> a, <span class="dt">Integral</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Binary</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="fu">show</span> (<span class="dt">Binary</span> n) <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb2-8" title="8">        str <span class="ot">=</span> showIntAtBase <span class="dv">2</span> <span class="fu">intToDigit</span> n <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb2-9" title="9">        size <span class="ot">=</span> finiteBitSize n</a>
<a class="sourceLine" id="cb2-10" title="10">        <span class="kw">in</span> <span class="fu">replicate</span> (size <span class="op">-</span> <span class="fu">length</span> str) <span class="ch">&#39;0&#39;</span> <span class="op">&lt;&gt;</span> str</a></code></pre></div>
<p>Using this <code>newtype</code> we can turn this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="dv">24732</span><span class="ot"> ::</span> <span class="dt">Word16</span></a></code></pre></div>
<pre><code>24732</code></pre>
<p>into this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="dv">24732</span><span class="ot"> ::</span> <span class="dt">Binary</span> <span class="dt">Word16</span></a></code></pre></div>
<pre><code>0110000010011100</code></pre>
<p>I’m going to use 32-bit hashes (because they’re more convenient to display than 64-bit ones) and 16-bit bitmaps.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">type</span> <span class="dt">Hash</span> <span class="ot">=</span> <span class="dt">Binary</span> <span class="dt">Word32</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">type</span> <span class="dt">Bitmap</span> <span class="ot">=</span> <span class="dt">Binary</span> <span class="dt">Word16</span></a></code></pre></div>
<p>The width of bitmaps is <span class="math inline">2<sup><em>n</em></sup></span> where <span class="math inline"><em>n</em></span> is the number of bits of the hash that we use at each level of the tree (more on this below). I’m setting <span class="math inline"><em>n</em> = 4</span> which is what <code>unordered-containers</code> uses (as of this writing), but we could e.g. set <span class="math inline"><em>n</em> = 5</span> and use 32-bit bitmaps if we wanted.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">bitsPerSubkey ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" title="2">bitsPerSubkey <span class="ot">=</span> <span class="dv">4</span></a></code></pre></div>
<p><code>Shift</code> is a multiple of <span class="math inline"><em>n</em></span> that we will use to focus on the correct part of the hash.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">type</span> <span class="dt">Shift</span> <span class="ot">=</span> <span class="dt">Int</span></a></code></pre></div>
<p>I’m also going to define a <code>Hashable</code> class to decouple the choice of a hash function from the implementation of <code>HAMT</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">class</span> <span class="dt">Hashable</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ot">    hash ::</span> a <span class="ot">-&gt;</span> <span class="dt">Hash</span></a></code></pre></div>
<p>For convenience, we’ll use the FNV-1 hash function with strings.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb11-3" title="3"></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">String</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-5" title="5">    hash s <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb11-6" title="6">        <span class="dt">FnvHash32</span> h <span class="ot">=</span> fnv1Hash (<span class="fu">pack</span> s)</a>
<a class="sourceLine" id="cb11-7" title="7">        <span class="kw">in</span> <span class="dt">Binary</span> h</a></code></pre></div>
<p>Here’s what it looks like in practice.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1">hash <span class="st">&quot;1&quot;</span><span class="ot"> ::</span> <span class="dt">Binary</span> <span class="dt">Word32</span></a></code></pre></div>
<pre><code>00000101000011000101110100101110</code></pre>
<p>A HAMT can be</p>
<ul>
<li>empty (<code>None</code>)</li>
<li>a leaf node with the hash, the key, and the value (<code>Leaf</code>)</li>
<li>a node with a bitmap and a (non-empty) vector of child HAMTs (<code>Many</code>)</li>
</ul>
<p>I’ve chosen to ignore the possibility of collisions, but we could handle them by adding an extra constructor, e.g. <code>Colliding</code> with a hash and a vector of key-value pairs.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">data</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb14-2" title="2">    <span class="ot">=</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="op">|</span> <span class="dt">Leaf</span> <span class="dt">Hash</span> key value</a>
<a class="sourceLine" id="cb14-4" title="4">    <span class="op">|</span> <span class="dt">Many</span> <span class="dt">Bitmap</span> (<span class="dt">Vector</span> (<span class="dt">HAMT</span> key value))</a>
<a class="sourceLine" id="cb14-5" title="5">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="ot">empty ::</span> <span class="dt">HAMT</span> k v</a>
<a class="sourceLine" id="cb14-8" title="8">empty <span class="ot">=</span> <span class="dt">None</span></a></code></pre></div>
<p>We’ll need some helper functions for vectors:</p>
<ul>
<li><code>insertAt</code> inserts an element at a specified index, shifting elements to the right forwards</li>
<li><code>updateAt</code> replaces an element at a specified index with a new element</li>
<li><code>deleteAt</code> removes an element at an index, shifting elements to the right backwards</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">insertAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</a>
<a class="sourceLine" id="cb15-2" title="2">insertAt vector <span class="fu">index</span> a <span class="ot">=</span> <span class="fu">take</span> <span class="fu">index</span> vector <span class="op">&lt;&gt;</span> singleton a <span class="op">&lt;&gt;</span> <span class="fu">drop</span> <span class="fu">index</span> vector</a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="ot">updateAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</a>
<a class="sourceLine" id="cb15-5" title="5">updateAt vector <span class="fu">index</span> a <span class="ot">=</span> vector <span class="op">//</span> [(<span class="fu">index</span>, a)]</a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="ot">deleteAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</a>
<a class="sourceLine" id="cb15-8" title="8">deleteAt vector <span class="fu">index</span> <span class="ot">=</span> <span class="fu">take</span> <span class="fu">index</span> vector <span class="op">&lt;&gt;</span> <span class="fu">drop</span> (<span class="fu">index</span><span class="op">+</span><span class="dv">1</span>) vector</a></code></pre></div>
<h3 id="insert">Insert</h3>
<p>I think the bit manipulation functions are crucial to understanding what’s going on, so I’m going to motivate them by trying to define <code>insert</code> without them and coming up with them as they are needed. This initial definition won’t be quite right so I’ll call it <code>insert_</code> to differentiate it from the correct <code>insert'</code> function I present later. The type signature for <code>insert_</code> is</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">insert_ ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a></code></pre></div>
<p>Inserting a key-value pair into an empty HAMT gives us a single leaf node:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1">insert_ hash key value <span class="dt">None</span> <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</a></code></pre></div>
<p>Inserting a key-value pair into a single leaf node where the hashes match gives us an updated leaf node (because we’re pretending collisions don’t exist):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">insert_ hash key value (<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</a></code></pre></div>
<p>Inserting into a HAMT consisting of a single leaf node where the hashes don’t match upgrades that leaf node to a <code>Many</code> node and inserts the key-value pair into that <code>Many</code> node:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1">insert_ hash key value leaf<span class="op">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb19-2" title="2">    <span class="op">|</span> hash <span class="op">/=</span> leafHash <span class="ot">=</span> insert_ key value (<span class="dt">Many</span> someBitmap (singleton leaf))</a>
<a class="sourceLine" id="cb19-3" title="3">    <span class="kw">where</span> someBitmap <span class="ot">=</span> <span class="fu">undefined</span></a></code></pre></div>
<h4 id="bit-masking">Bit Masking</h4>
<p>Where does <code>someBitmap</code> come from? Time for an example! Let’s start with a <code>Leaf (hash "1") "1" 1</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1">h <span class="ot">=</span> hash <span class="st">&quot;1&quot;</span></a>
<a class="sourceLine" id="cb20-2" title="2">leaf <span class="ot">=</span> <span class="dt">Leaf</span> h <span class="st">&quot;1&quot;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb20-3" title="3"></a>
<a class="sourceLine" id="cb20-4" title="4">leaf</a></code></pre></div>
<pre><code>Leaf 00000101000011000101110100101110 &quot;1&quot; 1</code></pre>
<p><code>someBitMap</code> is a 16-bit bitmap where the number of bits set (the <code>popCount</code>) is the length of the vector, which in this case is <span class="math inline">1</span>. We want to set one bit, but which bit? We carve off the last <span class="math inline"><em>n</em></span> bits using a mask:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="ot">subkeyMask ::</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb22-2" title="2">subkeyMask <span class="ot">=</span> (bit bitsPerSubkey) <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-3" title="3"></a>
<a class="sourceLine" id="cb22-4" title="4">subkeyMask</a></code></pre></div>
<pre><code>0000000000001111</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="co">--     0101110100101110</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="co">-- .&amp;. 0000000000001111</span></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="co">-----------------------</span></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="co">--     0000000000001110</span></a>
<a class="sourceLine" id="cb24-5" title="5"></a>
<a class="sourceLine" id="cb24-6" title="6">fragment <span class="ot">=</span> <span class="fu">fromIntegral</span> h <span class="op">.&amp;.</span> subkeyMask</a>
<a class="sourceLine" id="cb24-7" title="7"></a>
<a class="sourceLine" id="cb24-8" title="8">fragment</a></code></pre></div>
<pre><code>0000000000001110</code></pre>
<p>Then we interpret that fragment as a number:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="dt">Binary</span> position <span class="ot">=</span> fragment</a>
<a class="sourceLine" id="cb26-2" title="2"></a>
<a class="sourceLine" id="cb26-3" title="3">position</a></code></pre></div>
<pre><code>14</code></pre>
<p>Finally, we set that bit and we have our bitmap:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="ot">someBitmap ::</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb28-2" title="2">someBitmap <span class="ot">=</span> <span class="dt">Binary</span> <span class="op">$</span> bit <span class="op">$</span> <span class="fu">fromIntegral</span> position</a>
<a class="sourceLine" id="cb28-3" title="3"></a>
<a class="sourceLine" id="cb28-4" title="4">someBitmap</a></code></pre></div>
<pre><code>0100000000000000</code></pre>
<p>We’re going to be doing this a lot, so I’ll define this as <code>bitMask_</code>. The extra <code>_</code> is because it isn’t quite right for the same reason as <code>insert_</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="ot">bitMask_ ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb30-2" title="2">bitMask_ hash <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb30-3" title="3">    fragment <span class="ot">=</span> <span class="fu">fromIntegral</span> hash <span class="op">.&amp;.</span> subkeyMask</a>
<a class="sourceLine" id="cb30-4" title="4">    <span class="dt">Binary</span> position <span class="ot">=</span> fragment</a>
<a class="sourceLine" id="cb30-5" title="5">    <span class="kw">in</span> <span class="dt">Binary</span> (bit (<span class="fu">fromIntegral</span> position))</a></code></pre></div>
<p>Let’s look at the <code>Many</code> case. If we try inserting into a node where the bit in the bitmap corresponding to the mask is <code>0</code>, this means that there is an empty slot in the vector. We can insert a leaf node into this slot and set the corresponding bit in the bitmap to <code>1</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1">insert_ hash key value (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb31-2" title="2">    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb31-3" title="3">        leaf <span class="ot">=</span> <span class="dt">Leaf</span> (hash key) key value</a>
<a class="sourceLine" id="cb31-4" title="4">        vector&#39; <span class="ot">=</span> insertAt vector <span class="fu">index</span> leaf</a>
<a class="sourceLine" id="cb31-5" title="5">        bitmap&#39; <span class="ot">=</span> bitmap <span class="op">.|.</span> mask</a>
<a class="sourceLine" id="cb31-6" title="6">        <span class="kw">in</span> <span class="dt">Many</span> bitmap&#39; vector&#39;</a>
<a class="sourceLine" id="cb31-7" title="7">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-8" title="8">        mask <span class="ot">=</span> bitMask_ hash</a>
<a class="sourceLine" id="cb31-9" title="9">        <span class="fu">index</span> <span class="ot">=</span> <span class="fu">undefined</span></a></code></pre></div>
<h4 id="mask-indexing">Mask Indexing</h4>
<p>What <code>index</code> do we use? This is where <code>popCount</code> makes an appearance. Let’s demonstrate by inserting <code>("10", 2)</code> into our example. First we get the mask corresponding to <code>hash "10"</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1">mask <span class="ot">=</span> bitMask_ (hash <span class="st">&quot;10&quot;</span>)</a>
<a class="sourceLine" id="cb32-2" title="2"></a>
<a class="sourceLine" id="cb32-3" title="3">mask</a></code></pre></div>
<pre><code>0000010000000000</code></pre>
<p>Next we want to find the number of lower bits that have been set. We use <code>mask - 1</code> as a mask:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1">mask <span class="op">-</span> <span class="dv">1</span></a></code></pre></div>
<pre><code>0000001111111111</code></pre>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="co">--     0100000000000000</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="co">-- .&amp;. 0000001111111111</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="co">-----------------------</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="co">--     0000000000000000</span></a>
<a class="sourceLine" id="cb36-5" title="5"></a>
<a class="sourceLine" id="cb36-6" title="6">masked <span class="ot">=</span> someBitmap <span class="op">.&amp;.</span> (mask <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb36-7" title="7"></a>
<a class="sourceLine" id="cb36-8" title="8">masked</a></code></pre></div>
<pre><code>0000000000000000</code></pre>
<p>Then we count the number of bits set with <code>popCount</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="fu">index</span> <span class="ot">=</span> popCount masked</a>
<a class="sourceLine" id="cb38-2" title="2"></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="fu">index</span></a></code></pre></div>
<pre><code>0</code></pre>
<p>And this is the index we need to insert at! We’ll call this <code>maskIndex</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1"><span class="ot">maskIndex ::</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb40-2" title="2">maskIndex bitmap mask <span class="ot">=</span> popCount (bitmap <span class="op">.&amp;.</span> (mask <span class="op">-</span> <span class="dv">1</span>))</a></code></pre></div>
<p>The final case is where the bit in the bitmap is already set. We need to recursively update the HAMT at the corresponding index:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" title="1">insert_ hash key value (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb41-2" title="2">    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb41-3" title="3">        subtree&#39; <span class="ot">=</span> insert_ hash key value (vector <span class="op">!</span> <span class="fu">index</span>) <span class="co">-- WRONG!</span></a>
<a class="sourceLine" id="cb41-4" title="4">        vector&#39; <span class="ot">=</span> updateAt vector <span class="fu">index</span> subtree&#39;</a>
<a class="sourceLine" id="cb41-5" title="5">        <span class="kw">in</span> <span class="dt">Many</span> bitmap vector&#39;</a>
<a class="sourceLine" id="cb41-6" title="6">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-7" title="7">        mask <span class="ot">=</span> bitMask_ hash</a>
<a class="sourceLine" id="cb41-8" title="8">        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>But this definition is wrong, because instead of carving off the last <span class="math inline"><em>n</em></span> bits of <code>hash</code>, we want to recursively carve off the next <span class="math inline"><em>n</em></span> bits!</p>
<h4 id="shifting">Shifting</h4>
<p>This is what’s missing from our definition, a <code>shift</code> parameter corresponding to how far up the <code>hash</code> we’re looking. This is why we defined <code>Shift</code> above. Taking this extra parameter into account, our bit manipulation functions now become:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1"><span class="ot">subkeyMask ::</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb42-2" title="2">subkeyMask <span class="ot">=</span> (bit bitsPerSubkey) <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb42-3" title="3"></a>
<a class="sourceLine" id="cb42-4" title="4"><span class="ot">maskIndex ::</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb42-5" title="5">maskIndex bitmap mask <span class="ot">=</span> popCount (bitmap <span class="op">.&amp;.</span> (mask <span class="op">-</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb42-6" title="6"></a>
<a class="sourceLine" id="cb42-7" title="7"><span class="ot">subkey ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb42-8" title="8">subkey hash shift <span class="ot">=</span> <span class="fu">fromIntegral</span> <span class="op">$</span> (<span class="fu">fromIntegral</span> <span class="op">$</span> shiftR hash shift) <span class="op">.&amp;.</span> subkeyMask</a>
<a class="sourceLine" id="cb42-9" title="9"></a>
<a class="sourceLine" id="cb42-10" title="10"><span class="ot">bitMask ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb42-11" title="11">bitMask hash shift <span class="ot">=</span> bit (subkey hash shift)</a></code></pre></div>
<p>We plumb through this <code>shift</code> parameter, only modifying it in the final case, to give us the correct definitions of <code>insert'</code> and <code>insert</code>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1"><span class="ot">insert ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb43-2" title="2">insert key value hamt <span class="ot">=</span> insert&#39; <span class="dv">0</span> (hash key) key value hamt</a>
<a class="sourceLine" id="cb43-3" title="3"></a>
<a class="sourceLine" id="cb43-4" title="4"><span class="ot">insert&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb43-5" title="5">insert&#39; shift hash key value <span class="dt">None</span> <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</a>
<a class="sourceLine" id="cb43-6" title="6"></a>
<a class="sourceLine" id="cb43-7" title="7">insert&#39; shift hash key value leaf<span class="op">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb43-8" title="8">    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</a>
<a class="sourceLine" id="cb43-9" title="9">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> insert&#39; shift hash key value (<span class="dt">Many</span> (bitMask leafHash shift) (singleton leaf))</a>
<a class="sourceLine" id="cb43-10" title="10"></a>
<a class="sourceLine" id="cb43-11" title="11">insert&#39; shift hash key value (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb43-12" title="12">    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb43-13" title="13">        leaf <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</a>
<a class="sourceLine" id="cb43-14" title="14">        vector&#39; <span class="ot">=</span> insertAt vector <span class="fu">index</span> leaf</a>
<a class="sourceLine" id="cb43-15" title="15">        bitmap&#39; <span class="ot">=</span> bitmap <span class="op">.|.</span> mask</a>
<a class="sourceLine" id="cb43-16" title="16">        <span class="kw">in</span> <span class="dt">Many</span> bitmap&#39; vector&#39;</a>
<a class="sourceLine" id="cb43-17" title="17">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb43-18" title="18">        subtree <span class="ot">=</span> vector <span class="op">!</span> <span class="fu">index</span></a>
<a class="sourceLine" id="cb43-19" title="19">        subtree&#39; <span class="ot">=</span> insert&#39; (shift<span class="op">+</span>bitsPerSubkey) hash key value subtree</a>
<a class="sourceLine" id="cb43-20" title="20">        vector&#39; <span class="ot">=</span> updateAt vector <span class="fu">index</span> subtree&#39;</a>
<a class="sourceLine" id="cb43-21" title="21">        <span class="kw">in</span> <span class="dt">Many</span> bitmap vector&#39;</a>
<a class="sourceLine" id="cb43-22" title="22">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-23" title="23">        mask <span class="ot">=</span> bitMask hash shift</a>
<a class="sourceLine" id="cb43-24" title="24">        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>Now we can construct HAMTs and inspect them! I’ll define a <code>fromList</code> function and use <code>pPrint</code> from <code>pretty-show</code> to highlight the tree structure:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1"><span class="ot">fromList ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> [(key, value)] <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb44-2" title="2">fromList <span class="ot">=</span> <span class="fu">foldr</span> (<span class="fu">uncurry</span> insert) empty</a>
<a class="sourceLine" id="cb44-3" title="3"></a>
<a class="sourceLine" id="cb44-4" title="4">example <span class="ot">=</span> fromList [(<span class="st">&quot;1&quot;</span>, <span class="dv">1</span>), (<span class="st">&quot;10&quot;</span>, <span class="dv">2</span>), (<span class="st">&quot;100&quot;</span>, <span class="dv">3</span>), (<span class="st">&quot;1000&quot;</span>, <span class="dv">4</span>)]</a>
<a class="sourceLine" id="cb44-5" title="5"></a>
<a class="sourceLine" id="cb44-6" title="6">pPrint example</a></code></pre></div>
<pre><code>Many
  0100010000000000
  [ Many
      0000000100100000
      [ Leaf 00100000011101101010111101011010 &quot;10&quot; 2
      , Leaf 10001010111100101011011010001010 &quot;1000&quot; 4
      ]
  , Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<h3 id="lookup">Lookup</h3>
<p>Compared to <code>insert</code>, <code>lookup</code> is a walk in the park. It’s implemented along the same lines as <code>insert</code>:</p>
<ul>
<li>on <code>None</code> nodes, it fails</li>
<li>on <code>Leaf</code> nodes, it succeeds if the hashes match</li>
<li>on <code>Many</code> nodes, it fails if the bit isn’t set, and recurses into the child node otherwise</li>
</ul>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1"><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">Maybe</span> value</a>
<a class="sourceLine" id="cb46-2" title="2"><span class="fu">lookup</span> key hamt <span class="ot">=</span> lookup&#39; <span class="dv">0</span> (hash key) hamt</a>
<a class="sourceLine" id="cb46-3" title="3"></a>
<a class="sourceLine" id="cb46-4" title="4"><span class="ot">lookup&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">Maybe</span> value</a>
<a class="sourceLine" id="cb46-5" title="5">lookup&#39; shift hash <span class="dt">None</span> <span class="ot">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb46-6" title="6"></a>
<a class="sourceLine" id="cb46-7" title="7">lookup&#39; shift hash (<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb46-8" title="8">    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">Just</span> leafValue</a>
<a class="sourceLine" id="cb46-9" title="9">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb46-10" title="10"></a>
<a class="sourceLine" id="cb46-11" title="11">lookup&#39; shift hash (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb46-12" title="12">    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb46-13" title="13">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> lookup&#39; (shift<span class="op">+</span>bitsPerSubkey) hash (vector <span class="op">!</span> <span class="fu">index</span>)</a>
<a class="sourceLine" id="cb46-14" title="14">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-15" title="15">        mask <span class="ot">=</span> bitMask hash shift</a>
<a class="sourceLine" id="cb46-16" title="16">        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>Let’s quickly confirm that it works.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1"><span class="fu">lookup</span> <span class="st">&quot;100&quot;</span> example</a></code></pre></div>
<pre><code>Just 3</code></pre>
<h4 id="memoising-fibonacci">Memoising Fibonacci</h4>
<p>We now have enough of an API to use this as a hashtable! Let’s use it to memoise the calculation of the Fibonacci sequence. The naive implementation does a lot of unnecessary recomputation:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" title="1"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb49-2" title="2">fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb49-3" title="3">fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb49-4" title="4">fib n <span class="ot">=</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb49-5" title="5"></a>
<a class="sourceLine" id="cb49-6" title="6">timeIt <span class="op">$</span> <span class="fu">print</span> <span class="op">$</span> fib <span class="dv">30</span></a></code></pre></div>
<pre><code>1346269
CPU time:   1.31s</code></pre>
<p>We can memoise it by storing previously calculated results and using them if they are available:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" title="1"><span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-2" title="2">    hash int <span class="ot">=</span> <span class="dt">Binary</span> (<span class="fu">fromIntegral</span> int)</a>
<a class="sourceLine" id="cb51-3" title="3"></a>
<a class="sourceLine" id="cb51-4" title="4"><span class="ot">fib&#39; ::</span> <span class="dt">HAMT</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">HAMT</span> <span class="dt">Int</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb51-5" title="5">fib&#39; table <span class="dv">0</span> <span class="ot">=</span> (<span class="dv">1</span>, insert <span class="dv">0</span> <span class="dv">1</span> table)</a>
<a class="sourceLine" id="cb51-6" title="6">fib&#39; table <span class="dv">1</span> <span class="ot">=</span> (<span class="dv">1</span>, insert <span class="dv">1</span> <span class="dv">1</span> table)</a>
<a class="sourceLine" id="cb51-7" title="7">fib&#39; table n <span class="ot">=</span> <span class="kw">case</span> <span class="fu">lookup</span> n table <span class="kw">of</span></a>
<a class="sourceLine" id="cb51-8" title="8">    <span class="dt">Just</span> i <span class="ot">-&gt;</span> (i, table)</a>
<a class="sourceLine" id="cb51-9" title="9">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb51-10" title="10">        (i1, table&#39;)  <span class="ot">=</span> fib&#39; table  (n<span class="op">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb51-11" title="11">        (i2, table&#39;&#39;) <span class="ot">=</span> fib&#39; table&#39; (n<span class="op">-</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb51-12" title="12">        <span class="kw">in</span> (i1 <span class="op">+</span> i2, insert n (i1 <span class="op">+</span> i2) table&#39;&#39;)</a>
<a class="sourceLine" id="cb51-13" title="13"></a>
<a class="sourceLine" id="cb51-14" title="14"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb51-15" title="15">fib n <span class="ot">=</span> <span class="fu">fst</span> <span class="op">$</span> fib&#39; empty n</a>
<a class="sourceLine" id="cb51-16" title="16"></a>
<a class="sourceLine" id="cb51-17" title="17">timeIt <span class="op">$</span> <span class="fu">print</span> <span class="op">$</span> fib <span class="dv">30</span></a></code></pre></div>
<pre><code>1346269
CPU time:   0.00s</code></pre>
<h3 id="delete">Delete</h3>
<p>Finally we come to <code>delete</code>, which is only a little more complex than <code>lookup</code>. It needs to make sure that no <code>Many</code> node has a child <code>None</code> node, so if a <code>None</code> node:</p>
<ul>
<li>is an only child, it will replace the parent node</li>
<li>has any sibling nodes, it will be removed from the parent node’s bitmap and vector</li>
</ul>
<p><code>Leaf</code> nodes similarly replace their parents if they are the only child.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" title="1"><span class="ot">delete ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb53-2" title="2">delete key hamt <span class="ot">=</span> delete&#39; <span class="dv">0</span> (hash key) hamt</a>
<a class="sourceLine" id="cb53-3" title="3"></a>
<a class="sourceLine" id="cb53-4" title="4"><span class="ot">delete&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb53-5" title="5">delete&#39; shift hash <span class="dt">None</span> <span class="ot">=</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb53-6" title="6"></a>
<a class="sourceLine" id="cb53-7" title="7">delete&#39; shift hash leaf<span class="op">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb53-8" title="8">    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb53-9" title="9">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> leaf</a>
<a class="sourceLine" id="cb53-10" title="10"></a>
<a class="sourceLine" id="cb53-11" title="11">delete&#39; shift hash many<span class="op">@</span>(<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb53-12" title="12">    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> many</a>
<a class="sourceLine" id="cb53-13" title="13">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb53-14" title="14">        subtree <span class="ot">=</span> vector <span class="op">!</span> <span class="fu">index</span></a>
<a class="sourceLine" id="cb53-15" title="15">        subtree&#39; <span class="ot">=</span> delete&#39; (shift<span class="op">+</span>bitsPerSubkey) hash subtree</a>
<a class="sourceLine" id="cb53-16" title="16">        <span class="kw">in</span> <span class="kw">case</span> subtree&#39; <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-17" title="17">            <span class="dt">None</span> <span class="ot">-&gt;</span> <span class="kw">if</span> <span class="fu">length</span> vector <span class="op">==</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb53-18" title="18">                <span class="kw">then</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb53-19" title="19">                <span class="kw">else</span> <span class="dt">Many</span> (bitmap <span class="op">.&amp;.</span> complement mask) (deleteAt vector <span class="fu">index</span>)</a>
<a class="sourceLine" id="cb53-20" title="20">            <span class="dt">Leaf</span>{} <span class="ot">-&gt;</span> <span class="kw">if</span> <span class="fu">length</span> vector <span class="op">==</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb53-21" title="21">                <span class="kw">then</span> subtree&#39;</a>
<a class="sourceLine" id="cb53-22" title="22">                <span class="kw">else</span>  <span class="dt">Many</span> bitmap (updateAt vector <span class="fu">index</span> subtree&#39;)</a>
<a class="sourceLine" id="cb53-23" title="23">            <span class="dt">Many</span>{} <span class="ot">-&gt;</span> <span class="dt">Many</span> bitmap (updateAt vector <span class="fu">index</span> subtree&#39;)</a>
<a class="sourceLine" id="cb53-24" title="24">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb53-25" title="25">        mask <span class="ot">=</span> bitMask hash shift</a>
<a class="sourceLine" id="cb53-26" title="26">        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>Let’s see this in action.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" title="1">pPrint <span class="op">$</span> delete <span class="st">&quot;1000&quot;</span> example</a></code></pre></div>
<pre><code>Many
  0100010000000000
  [ Many
      0000000000100000 [ Leaf 00100000011101101010111101011010 &quot;10&quot; 2 ]
  , Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<p>It’s possible to have a situation where we have a <code>Many</code> node with only one child, because our replacement behaviour checks the length of the vector before any elements are removed from it. However, removing the last leaf will correctly delete the parent node.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" title="1">pPrint <span class="op">$</span> delete <span class="st">&quot;10&quot;</span> <span class="op">$</span> delete <span class="st">&quot;1000&quot;</span> example</a></code></pre></div>
<pre><code>Many
  0100000000000000
  [ Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<p>And we’re done! I hope you understand HAMTs better than when you started reading this.</p>
<p>If you want to use this for something other than educational purposes, I would recommend adding logic to deal with hash collisions, which I intentionally omitted. There’s also some low-hanging fruit in terms of performance optimisations. The first thing that comes to mind is an additional <code>Full</code> constructor for the case where all bits in the bitmap are set, and the next thing is the use of unsafe vector functions that omit bounds checking.</p>
<p>Thanks to <a href="https://twitter.com/evanborden">Evan Borden</a>, <a href="https://twitter.com/candeira">Javier Candeira</a>, <a href="https://hypirion.com/">Jean Niklas L’orange</a>, <a href="http://mjhopkins.github.io/">Mark Hopkins</a>, and <a href="https://teh.id.au/">Tim Humphries</a> for comments and feedback.</p>
]]></summary>
</entry>
<entry>
    <title>Trees That Shrink</title>
    <link href="https://vaibhavsagar.com/blog/2018/06/19/trees-that-shrink/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/06/19/trees-that-shrink/index.html</id>
    <published>2018-06-19T00:00:00Z</published>
    <updated>2018-06-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 19 June 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p><em>This blog post is also available as an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/trees-that-shrink/TreesThatShrink.ipynb">IHaskell notebook</a>.</em></p>
<p>I read <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf">this paper</a> a while ago and people seemed pretty excited about it, although I couldn’t see why. Fortunately, someone posed me an interesting problem recently and in the process of tackling it I think I understand now.</p>
<p>Suppose we have a simple algebraic data type representing the lambda calculus with <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a>, which are a way of avoiding the messy problem of variable names:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="ot">=</span> <span class="dt">Lit</span> a</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="op">|</span> <span class="dt">Var</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="op">|</span> <span class="dt">Abs</span> (<span class="dt">Expr</span> a)</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="op">|</span> <span class="dt">App</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>So far so good! Now we want to have let bindings in this language, and we’ve decided that we want named variables as well while we’re at it because de Bruijn indices are not so much fun to work with. We dutifully define another data type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">Expr&#39;</span> a</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="ot">=</span> <span class="dt">Lit&#39;</span> a</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="op">|</span> <span class="dt">Var&#39;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="op">|</span> <span class="dt">Abs&#39;</span> (<span class="dt">Expr&#39;</span> a)</a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="op">|</span> <span class="dt">App&#39;</span> (<span class="dt">Expr&#39;</span> a) (<span class="dt">Expr&#39;</span> a)</a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="op">|</span> <span class="dt">Let&#39;</span> <span class="dt">String</span> (<span class="dt">Expr&#39;</span> a) (<span class="dt">Expr&#39;</span> a)</a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>Let bindings can be easily desugared into lambda abstractions as follows:</p>
<pre><code>let &lt;n&gt; = &lt;x&gt; in &lt;y&gt; &lt;=&gt; (\n -&gt; y) x</code></pre>
<p>which will help us to write a simpler evaluator. However, we’d also like to make sure the desugaring has been implemented correctly, perhaps by converting to some intermediate state where both the name and the correct de Bruijn index coexist peacefully. We have a couple of options, none of which are great:</p>
<ol type="1">
<li>Define a third data type and then write an indexing pass that converts <code>Var String</code> to <code>Var (String, Int)</code> and then a desugaring pass that converts that to <code>Expr a</code>.</li>
<li>Work entirely within the bigger data type, forget about indexing, and throw errors whenever a <code>Let</code> is encountered after a desugaring pass.</li>
<li>Combine the desugaring and indexing passes into one, and forget about keeping track of the desugaring.</li>
</ol>
<p>Let’s implement the third:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="ot">desugarAndAnonymise ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr&#39;</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb4-6" title="6">desugarAndAnonymise env expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="dt">Lit&#39;</span> a <span class="ot">-&gt;</span> <span class="dt">Lit</span> a</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="dt">Var&#39;</span> name <span class="ot">-&gt;</span> <span class="dt">Var</span> (env <span class="op">Map.!</span> name)</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="dt">Abs&#39;</span> expr&#39; <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb4-10" title="10">        env&#39;  <span class="ot">=</span> Map.map <span class="fu">succ</span> env</a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="kw">in</span> <span class="dt">Abs</span> (desugarAndAnonymise env&#39; expr&#39;)</a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="dt">App&#39;</span> f x <span class="ot">-&gt;</span> <span class="dt">App</span> (desugarAndAnonymise env f) (desugarAndAnonymise env x)</a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="dt">Let&#39;</span> n v expr&#39; <span class="ot">-&gt;</span> desugarAndAnonymise env (<span class="dt">App&#39;</span> (<span class="dt">Abs&#39;</span> expr&#39;) v)</a></code></pre></div>
<p>That wasn’t a lot of fun to write, I have no idea if I did the conversion from names to indices correctly, and there’s no easy way to check if I did.</p>
<p>These problems are (barely) manageable in this case, but what if we want to add more syntax sugar or share this data type with other libraries that have different use cases? We’d either have to write variations on a theme over and over again or say goodbye to type safety. It also becomes harder and harder to decompose our functions into smaller ones that only do one thing. There has to be a better way!</p>
<p>This is the subject of <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf">Trees that Grow</a> by Shayan Najd and Simon Peyton Jones. They noticed the need for this approach when looking at GHC’s abstract syntax tree type but the idiom is generally applicable.</p>
<p>The first insight is that defining different data types for each use case is the wrong approach. Conceptually all these data types are the same type, just with different annotations or decoration, and we should be able to define the base data type with enough extensibility to accommodate all the other use cases.</p>
<p>The second insight is that we can use some of GHC’s fancier features to ease the pain of working with this ridiculously extensible data type, such as type families and pattern synonyms.</p>
<p>The third insight is that this can be made to work with other language features, such as generalised abstract data types and existentials! We won’t use this here, but it’s great to know that it’s possible.</p>
<p>Let’s see how we can use it to solve our problem. The first thing to do is turn on some language extensions, as with anything moderately fun in Haskell:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ot">{-# LANGUAGE PatternSynonyms   #-}</span></a></code></pre></div>
<p>The next steps are:</p>
<ol type="1">
<li>Add a type parameter to the data type declaration.</li>
<li>Add a field to each constructor with a new data type that uses this parameter (and any others).</li>
<li>Add an extra constructor to enable extending this data type, also with a new data type as in step 2.</li>
<li>Define type families for each of the new data types you declared in steps 2 and 3.</li>
</ol>
<p>And we’re done! This is what that looks like for our example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">ExpX</span> i a</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="ot">=</span> <span class="dt">LitX</span> (<span class="dt">XLit</span> i a) a</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="op">|</span> <span class="dt">VarX</span> (<span class="dt">XVar</span> i a)</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="op">|</span> <span class="dt">AbsX</span> (<span class="dt">XAbs</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="op">|</span> <span class="dt">AppX</span> (<span class="dt">XApp</span> i a) (<span class="dt">ExpX</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="op">|</span> <span class="dt">ExpX</span> (<span class="dt">XExp</span> i a)</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XLit</span> i a</a>
<a class="sourceLine" id="cb6-9" title="9"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XVar</span> i a</a>
<a class="sourceLine" id="cb6-10" title="10"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XAbs</span> i a</a>
<a class="sourceLine" id="cb6-11" title="11"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XApp</span> i a</a>
<a class="sourceLine" id="cb6-12" title="12"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XExp</span> i a</a></code></pre></div>
<p>The next thing to do is to reconstruct our original data type with no extensions. To do this we’ll need to use the <a href="http://hackage.haskell.org/package/base/docs/Data-Void.html"><code>Data.Void</code></a> package:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ot">void ::</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb7-4" title="4">void <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Attempt to evaluate void&quot;</span></a></code></pre></div>
<p>Now we can define <code>ExpUD</code> (UD for “undecorated”) using <code>Int</code> for our <code>Var</code> like we originally wanted and <code>Void</code> for all other extension points. It might get frustrating to construct and work with these values by hand, so we can use pattern synonyms to ease this pain.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">type</span> <span class="dt">ExpUD</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">UD</span> a</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">data</span> <span class="dt">UD</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="kw">pattern</span> <span class="dt">LitUD</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-10" title="10"><span class="kw">pattern</span> <span class="dt">LitUD</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="kw">where</span> <span class="dt">LitUD</span> a <span class="ot">=</span> <span class="dt">LitX</span> void a</a>
<a class="sourceLine" id="cb8-12" title="12"><span class="kw">pattern</span> <span class="dt">VarUD</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-13" title="13"><span class="kw">pattern</span> <span class="dt">VarUD</span> i <span class="ot">&lt;-</span> <span class="dt">VarX</span> i</a>
<a class="sourceLine" id="cb8-14" title="14">    <span class="kw">where</span> <span class="dt">VarUD</span> i <span class="ot">=</span> <span class="dt">VarX</span> i</a>
<a class="sourceLine" id="cb8-15" title="15"><span class="kw">pattern</span> <span class="dt">AbsUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-16" title="16"><span class="kw">pattern</span> <span class="dt">AbsUD</span> a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> _ a</a>
<a class="sourceLine" id="cb8-17" title="17">    <span class="kw">where</span> <span class="dt">AbsUD</span> a <span class="ot">=</span> <span class="dt">AbsX</span> void a</a>
<a class="sourceLine" id="cb8-18" title="18"><span class="kw">pattern</span> <span class="dt">AppUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-19" title="19"><span class="kw">pattern</span> <span class="dt">AppUD</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</a>
<a class="sourceLine" id="cb8-20" title="20">    <span class="kw">where</span> <span class="dt">AppUD</span> f a <span class="ot">=</span> <span class="dt">AppX</span> void f a</a></code></pre></div>
<p>This is unfortunately a bit boilerplate-y, but now we can define that intermediate data type that uses named variables as well as de Bruijn indices! As a bonus, we can now have named parameters to lambdas, which would not have been possible with the approach we tried to use above.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">type</span> <span class="dt">ExpAnn</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Ann</span> a</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">data</span> <span class="dt">Ann</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Ann</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="kw">pattern</span> <span class="dt">LitAnn</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-10" title="10"><span class="kw">pattern</span> <span class="dt">LitAnn</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</a>
<a class="sourceLine" id="cb9-11" title="11">    <span class="kw">where</span> <span class="dt">LitAnn</span> a <span class="ot">=</span> <span class="dt">LitX</span> void a</a>
<a class="sourceLine" id="cb9-12" title="12"><span class="kw">pattern</span> <span class="dt">VarAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-13" title="13"><span class="kw">pattern</span> <span class="dt">VarAnn</span> s i <span class="ot">&lt;-</span> <span class="dt">VarX</span> (s,i)</a>
<a class="sourceLine" id="cb9-14" title="14">    <span class="kw">where</span> <span class="dt">VarAnn</span> s i <span class="ot">=</span> <span class="dt">VarX</span> (s, i)</a>
<a class="sourceLine" id="cb9-15" title="15"><span class="kw">pattern</span> <span class="dt">AbsAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-16" title="16"><span class="kw">pattern</span> <span class="dt">AbsAnn</span> s a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb9-17" title="17">    <span class="kw">where</span> <span class="dt">AbsAnn</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb9-18" title="18"><span class="kw">pattern</span> <span class="dt">AppAnn</span><span class="ot"> ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-19" title="19"><span class="kw">pattern</span> <span class="dt">AppAnn</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</a>
<a class="sourceLine" id="cb9-20" title="20">    <span class="kw">where</span> <span class="dt">AppAnn</span> f a <span class="ot">=</span> <span class="dt">AppX</span> void f a</a></code></pre></div>
<p>Now for my favourite part, where we add let bindings! We achieve this by using a tuple to represent <code>let &lt;name&gt; = &lt;expr&gt; in &lt;expr&gt;</code> as <code>(&lt;name&gt;, &lt;expr&gt;, &lt;expr&gt;)</code>, and we use named variables and parameters in this representation.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">type</span> <span class="dt">ExpLet</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Let</span> a</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">data</span> <span class="dt">Let</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Let</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">ExpLet</span> a, <span class="dt">ExpLet</span> a)</a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="kw">pattern</span> <span class="dt">LitLet</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-10" title="10"><span class="kw">pattern</span> <span class="dt">LitLet</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</a>
<a class="sourceLine" id="cb10-11" title="11">    <span class="kw">where</span> <span class="dt">LitLet</span> a <span class="ot">=</span> <span class="dt">LitX</span> void a</a>
<a class="sourceLine" id="cb10-12" title="12"><span class="kw">pattern</span> <span class="dt">VarLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-13" title="13"><span class="kw">pattern</span> <span class="dt">VarLet</span> s <span class="ot">&lt;-</span> <span class="dt">VarX</span> s</a>
<a class="sourceLine" id="cb10-14" title="14">    <span class="kw">where</span> <span class="dt">VarLet</span> s <span class="ot">=</span> <span class="dt">VarX</span> s</a>
<a class="sourceLine" id="cb10-15" title="15"><span class="kw">pattern</span> <span class="dt">AbsLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-16" title="16"><span class="kw">pattern</span> <span class="dt">AbsLet</span> s a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb10-17" title="17">    <span class="kw">where</span> <span class="dt">AbsLet</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb10-18" title="18"><span class="kw">pattern</span> <span class="dt">AppLet</span><span class="ot"> ::</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-19" title="19"><span class="kw">pattern</span> <span class="dt">AppLet</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</a>
<a class="sourceLine" id="cb10-20" title="20">    <span class="kw">where</span> <span class="dt">AppLet</span> f a <span class="ot">=</span> <span class="dt">AppX</span> void f a</a>
<a class="sourceLine" id="cb10-21" title="21"><span class="kw">pattern</span> <span class="dt">LetLet</span> n v e <span class="ot">&lt;-</span> <span class="dt">ExpX</span> (n,v,e)</a></code></pre></div>
<p>Now instead of writing a single giant pass, we can write smaller ones!</p>
<p>We can write a desugarer that preserves names and rewrites our let bindings as follows:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">desugar ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb11-2" title="2">desugar env expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="dt">LitLet</span> a <span class="ot">-&gt;</span> <span class="dt">LitAnn</span> a</a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="dt">VarLet</span> name <span class="ot">-&gt;</span> <span class="dt">VarAnn</span> name (env <span class="op">Map.!</span> name)</a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="dt">AbsLet</span> name expr&#39; <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb11-6" title="6">        env&#39;  <span class="ot">=</span> Map.map <span class="fu">succ</span> env</a>
<a class="sourceLine" id="cb11-7" title="7">        env&#39;&#39; <span class="ot">=</span> Map.insert name <span class="dv">0</span> env&#39;</a>
<a class="sourceLine" id="cb11-8" title="8">        <span class="kw">in</span> <span class="dt">AbsAnn</span> name (desugar env&#39;&#39; expr&#39;)</a>
<a class="sourceLine" id="cb11-9" title="9">    <span class="dt">AppLet</span> f x <span class="ot">-&gt;</span> <span class="dt">AppAnn</span> (desugar env f) (desugar env x)</a>
<a class="sourceLine" id="cb11-10" title="10">    <span class="dt">LetLet</span> n v expr&#39; <span class="ot">-&gt;</span> desugar env (<span class="dt">AppLet</span> (<span class="dt">AbsLet</span> n expr&#39;) v)</a></code></pre></div>
<p>We can also write an anonymiser that throws the names away:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">anonymise ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb12-2" title="2">anonymise expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="dt">LitAnn</span> a <span class="ot">-&gt;</span> <span class="dt">LitUD</span> a</a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="dt">VarAnn</span> _ i <span class="ot">-&gt;</span> <span class="dt">VarUD</span> i</a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="dt">AbsAnn</span> _ e <span class="ot">-&gt;</span> <span class="dt">AbsUD</span> (anonymise e)</a>
<a class="sourceLine" id="cb12-6" title="6">    <span class="dt">AppAnn</span> f x <span class="ot">-&gt;</span> <span class="dt">AppUD</span> (anonymise f) (anonymise x)</a></code></pre></div>
<p>And finally an evaluator that operates on undecorated expressions:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">eval ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb13-2" title="2">eval env expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="dt">LitUD</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb13-4" title="4">    <span class="dt">VarUD</span> i <span class="ot">-&gt;</span> env <span class="op">!!</span> i</a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="dt">AbsUD</span> f <span class="ot">-&gt;</span> eval env f</a>
<a class="sourceLine" id="cb13-6" title="6">    <span class="dt">AppUD</span> f x <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb13-7" title="7">        x&#39; <span class="ot">=</span> eval env x</a>
<a class="sourceLine" id="cb13-8" title="8">        <span class="kw">in</span> eval (x&#39;<span class="op">:</span>env) f</a></code></pre></div>
<p>Let’s see it in action!</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">identity <span class="ot">=</span> <span class="dt">AbsLet</span> <span class="st">&quot;i&quot;</span> (<span class="dt">VarLet</span> <span class="st">&quot;i&quot;</span>)</a>
<a class="sourceLine" id="cb14-2" title="2">konst <span class="ot">=</span> (<span class="dt">AbsLet</span> <span class="st">&quot;x&quot;</span> (<span class="dt">AbsLet</span> <span class="st">&quot;y&quot;</span> (<span class="dt">VarLet</span> <span class="st">&quot;x&quot;</span>)))</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4">eval [] <span class="op">.</span> anonymise <span class="op">.</span> desugar Map.empty <span class="op">$</span> <span class="dt">AppLet</span> (<span class="dt">AppLet</span> konst (<span class="dt">LitLet</span> <span class="dv">1</span>)) (<span class="dt">LitLet</span> <span class="dv">2</span>)</a></code></pre></div>
<pre><code>2</code></pre>
<p>Awesome! We have composable compiler passes that are easier to write and to think about. Even with this small example, I hope the benefits are clear.</p>
<p>Edit: <a href="https://www.reddit.com/r/haskell/comments/8s75n3/trees_that_shrink/e0x8se2">Edward Kmett points out</a> that using <code>Void</code> makes this approach unnecessarily footgun-prone and suggests using strict fields and <code>()</code> instead. This allows for simpler pattern synonyms and comes with the additional benefit that we can disable constructors with <code>Void</code> so we can actually have trees that shrink:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">data</span> <span class="dt">ExpX</span> i a</a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="ot">=</span> <span class="dt">LitX</span> <span class="op">!</span>(<span class="dt">XLit</span> i a) a</a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="op">|</span> <span class="dt">VarX</span> <span class="op">!</span>(<span class="dt">XVar</span> i a)</a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="op">|</span> <span class="dt">AbsX</span> <span class="op">!</span>(<span class="dt">XAbs</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb16-5" title="5">    <span class="op">|</span> <span class="dt">AppX</span> <span class="op">!</span>(<span class="dt">XApp</span> i a) (<span class="dt">ExpX</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb16-6" title="6">    <span class="op">|</span> <span class="dt">ExpX</span> <span class="op">!</span>(<span class="dt">XExp</span> i a)</a>
<a class="sourceLine" id="cb16-7" title="7"></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XLit</span> i a</a>
<a class="sourceLine" id="cb16-9" title="9"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XVar</span> i a</a>
<a class="sourceLine" id="cb16-10" title="10"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XAbs</span> i a</a>
<a class="sourceLine" id="cb16-11" title="11"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XApp</span> i a</a>
<a class="sourceLine" id="cb16-12" title="12"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XExp</span> i a</a>
<a class="sourceLine" id="cb16-13" title="13"></a>
<a class="sourceLine" id="cb16-14" title="14"><span class="kw">type</span> <span class="dt">ExpUD</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">UD</span> a</a>
<a class="sourceLine" id="cb16-15" title="15"><span class="kw">data</span> <span class="dt">UD</span></a>
<a class="sourceLine" id="cb16-16" title="16"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">UD</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-17" title="17"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-18" title="18"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">UD</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-19" title="19"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">UD</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-20" title="20"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-21" title="21"></a>
<a class="sourceLine" id="cb16-22" title="22"><span class="kw">pattern</span> <span class="dt">LitUD</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-23" title="23"><span class="kw">pattern</span> <span class="dt">LitUD</span> a <span class="ot">=</span> <span class="dt">LitX</span> () a</a>
<a class="sourceLine" id="cb16-24" title="24"><span class="kw">pattern</span> <span class="dt">VarUD</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-25" title="25"><span class="kw">pattern</span> <span class="dt">VarUD</span> i <span class="ot">=</span> <span class="dt">VarX</span> i</a>
<a class="sourceLine" id="cb16-26" title="26"><span class="kw">pattern</span> <span class="dt">AbsUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-27" title="27"><span class="kw">pattern</span> <span class="dt">AbsUD</span> a <span class="ot">=</span> <span class="dt">AbsX</span> () a</a>
<a class="sourceLine" id="cb16-28" title="28"><span class="kw">pattern</span> <span class="dt">AppUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-29" title="29"><span class="kw">pattern</span> <span class="dt">AppUD</span> f a <span class="ot">=</span> <span class="dt">AppX</span> () f a</a>
<a class="sourceLine" id="cb16-30" title="30"></a>
<a class="sourceLine" id="cb16-31" title="31"><span class="kw">type</span> <span class="dt">ExpAnn</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Ann</span> a</a>
<a class="sourceLine" id="cb16-32" title="32"><span class="kw">data</span> <span class="dt">Ann</span></a>
<a class="sourceLine" id="cb16-33" title="33"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Ann</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-34" title="34"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Ann</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb16-35" title="35"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb16-36" title="36"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Ann</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-37" title="37"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-38" title="38"></a>
<a class="sourceLine" id="cb16-39" title="39"><span class="kw">pattern</span> <span class="dt">LitAnn</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-40" title="40"><span class="kw">pattern</span> <span class="dt">LitAnn</span> a <span class="ot">=</span> <span class="dt">LitX</span> () a</a>
<a class="sourceLine" id="cb16-41" title="41"><span class="kw">pattern</span> <span class="dt">VarAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-42" title="42"><span class="kw">pattern</span> <span class="dt">VarAnn</span> s i <span class="ot">=</span> <span class="dt">VarX</span> (s, i)</a>
<a class="sourceLine" id="cb16-43" title="43"><span class="kw">pattern</span> <span class="dt">AbsAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-44" title="44"><span class="kw">pattern</span> <span class="dt">AbsAnn</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb16-45" title="45"><span class="kw">pattern</span> <span class="dt">AppAnn</span><span class="ot"> ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-46" title="46"><span class="kw">pattern</span> <span class="dt">AppAnn</span> f a <span class="ot">=</span> <span class="dt">AppX</span> () f a</a>
<a class="sourceLine" id="cb16-47" title="47"></a>
<a class="sourceLine" id="cb16-48" title="48"><span class="kw">type</span> <span class="dt">ExpLet</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Let</span> a</a>
<a class="sourceLine" id="cb16-49" title="49"><span class="kw">data</span> <span class="dt">Let</span></a>
<a class="sourceLine" id="cb16-50" title="50"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Let</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-51" title="51"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb16-52" title="52"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb16-53" title="53"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Let</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-54" title="54"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Let</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">ExpLet</span> a, <span class="dt">ExpLet</span> a)</a>
<a class="sourceLine" id="cb16-55" title="55"></a>
<a class="sourceLine" id="cb16-56" title="56"><span class="kw">pattern</span> <span class="dt">LitLet</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-57" title="57"><span class="kw">pattern</span> <span class="dt">LitLet</span> a <span class="ot">=</span> <span class="dt">LitX</span> () a</a>
<a class="sourceLine" id="cb16-58" title="58"><span class="kw">pattern</span> <span class="dt">VarLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-59" title="59"><span class="kw">pattern</span> <span class="dt">VarLet</span> s <span class="ot">=</span> <span class="dt">VarX</span> s</a>
<a class="sourceLine" id="cb16-60" title="60"><span class="kw">pattern</span> <span class="dt">AbsLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-61" title="61"><span class="kw">pattern</span> <span class="dt">AbsLet</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb16-62" title="62"><span class="kw">pattern</span> <span class="dt">AppLet</span><span class="ot"> ::</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-63" title="63"><span class="kw">pattern</span> <span class="dt">AppLet</span> f a <span class="ot">=</span> <span class="dt">AppX</span> () f a</a>
<a class="sourceLine" id="cb16-64" title="64"><span class="kw">pattern</span> <span class="dt">LetLet</span> n v e <span class="ot">&lt;-</span> <span class="dt">ExpX</span> (n,v,e)</a></code></pre></div>
<p>The definitions of <code>desugar</code>, <code>anonymise</code>, and <code>eval</code> are unchanged.</p>
<p>Thanks to <a href="http://andychu.net/">Andy Chu</a> and <a href="https://push.cx/">Peter Bhat Harkins</a> for comments and feedback.</p>
]]></summary>
</entry>
<entry>
    <title>Quick and Easy Nixpkgs Pinning</title>
    <link href="https://vaibhavsagar.com/blog/2018/05/27/quick-easy-nixpkgs-pinning/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/05/27/quick-easy-nixpkgs-pinning/index.html</id>
    <published>2018-05-27T00:00:00Z</published>
    <updated>2018-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 27 May 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/nix/index.html">nix</a>
    
</div>

<p>I love Nix because it makes packaging and using software so easy. For example, here’s a first stab at an expression that makes a recent version of Pandoc available in a <code>nix-shell</code> (be warned, this will take a while the first time!):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {};</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="ex">haskellPackages</span> = pkgs.haskellPackages.override {</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="ex">overrides</span> = self: super: {</a>
<a class="sourceLine" id="cb1-5" title="5">      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.2&quot;</span> {};</a>
<a class="sourceLine" id="cb1-6" title="6">      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.4.2&quot;</span> {};</a>
<a class="sourceLine" id="cb1-7" title="7">    };</a>
<a class="sourceLine" id="cb1-8" title="8">  };</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {</a>
<a class="sourceLine" id="cb1-10" title="10">  <span class="ex">buildInputs</span> = [ haskellPackages.pandoc ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb1-11" title="11">} <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>If we save this to <code>default.nix</code> we can use it as follows (unless you’re reading this after the release of NixOS 18.09, more on that below):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1">$ <span class="ex">nix-shell</span> default.nix</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb2-3" title="3">[<span class="ex">nix-shell</span>]$ pandoc --version</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ex">pandoc</span> 2.2</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></a></code></pre></div>
<p>Pandoc is infamously large, so this will probably take a while the first time. Fortunately, Nix caches build artifacts and knows to provide the same output if the inputs are unchanged, so if we immediately try this again a second time it should be nearly instantaneous.</p>
<p>Barring an event like the garbage collection of the Nix store or a change in the expression above, we would like to never rebuild this package again.</p>
<p>Unfortunately, there is a serious flaw with this expression that prevents us from guaranteeing this.</p>
<p>The problem is not immediately obvious, and might only manifest days or weeks later, or when you upgrade NixOS to the next version. The issue is with the second line,</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span><span class="kw">;</span></a></code></pre></div>
<p>where we import the system-wide <code>nixpkgs</code>. If we later update this by running</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1">$ <span class="ex">nix-channel</span> --update</a></code></pre></div>
<p>and any of the transitive dependencies of our expression are updated, this will cause a rebuild because Nix will rightly detect that the inputs have changed.</p>
<p>This might be desirable in many cases, but for us it means a lot of waiting for no benefit. We can avoid this by pinning <code>nixpkgs</code> to a known-good commit. One way to do this is by setting the <code>NIX_PATH</code> environment variable, which is where Nix looks for the location of <code>nixpkgs</code>. We could do this as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1">$ <span class="va">NIX_PATH=</span>nixpkgs=<span class="ex">https</span>://github.com/NixOS/nixpkgs-channels/archive/2f6440eb09b7e6e3322720ac91ce7e2cdeb413f9.tar.gz nix-shell default.nix</a></code></pre></div>
<p>which takes advantage of the fact that Nix will transparently download a URL for <code>nixpkgs</code> instead of a filepath. This can quickly get tedious and is easy to forget though. Let’s pin <code>nixpkgs</code> directly in the expression:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="ex">inherit</span> (import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {}) <span class="ex">fetchFromGitHub</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="ex">nixpkgs</span> = fetchFromGitHub {</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="ex">owner</span>  = <span class="st">&quot;NixOS&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="ex">repo</span>   = <span class="st">&quot;nixpkgs-channels&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="fu">rev</span>    = <span class="st">&quot;2f6440eb09b7e6e3322720ac91ce7e2cdeb413f9&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="ex">sha256</span> = <span class="st">&quot;0vb7ikjscrp2rw0dfw6pilxqpjm50l5qg2x2mn1vfh93dkl2aan7&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-8" title="8">  };</a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="ex">pkgs</span> = import nixpkgs {};</a>
<a class="sourceLine" id="cb6-10" title="10">  <span class="ex">haskellPackages</span> = pkgs.haskellPackages.override {</a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="ex">overrides</span> = self: super: {</a>
<a class="sourceLine" id="cb6-12" title="12">      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.2&quot;</span> {};</a>
<a class="sourceLine" id="cb6-13" title="13">      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.4.2&quot;</span> {};</a>
<a class="sourceLine" id="cb6-14" title="14">    };</a>
<a class="sourceLine" id="cb6-15" title="15">  };</a>
<a class="sourceLine" id="cb6-16" title="16"><span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {</a>
<a class="sourceLine" id="cb6-17" title="17">  <span class="ex">buildInputs</span> = [ haskellPackages.pandoc ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-18" title="18">} <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>Now we use the system-wide <code>nixpkgs</code> only to provide one function, <code>fetchFromGitHub</code>, which we then use to download a specific version of <code>nixpkgs</code> that we import instead. This is easier to use but computing the <code>sha256</code> is frustrating. One trick to keep in mind is that <code>fetchFromGitHub</code> is equivalent to</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1">$ <span class="ex">nix-prefetch-url</span> --unpack https://github.com/<span class="op">&lt;</span>owner<span class="op">&gt;</span>/<span class="op">&lt;</span>repo<span class="op">&gt;</span>/archive/<span class="op">&lt;</span>rev<span class="op">&gt;</span>.tar.gz</a></code></pre></div>
<p>which outputs the correct hash at the end.</p>
<p>What happens if we want to update the pinned version? One workflow I’ve seen suggested is to update the <code>rev</code>, change one character in the <code>sha256</code>, and let the Nix error message tell you the correct hash to use. I think we can do better than this.</p>
<p><a href="https://github.com/expipiplus1">Joe Hermaszewski</a> has a handy tool called <a href="https://github.com/expipiplus1/update-nix-fetchgit">update-nix-fetchgit</a> that parses Nix files and automatically updates any <code>fetchFromGitHub</code> calls to the latest <code>master</code> revision and SHA256 of the repository. This is certainly a lot more convenient, but it doesn’t seem to work for repositories that don’t have a <code>master</code> branch or that we want to update to the <code>HEAD</code> of a different branch. This seems like an unimportant omission except that <code>nixpkgs-channels</code> is one such repository, and we want to update it to the <code>HEAD</code> of e.g. <code>nixos-18.03</code>.</p>
<p>So, we have a tedious manual process on one hand and a quick, efficient, and wrong process on the other. There has to be a better way!</p>
<p>I’ve settled on a solution that uses two extra files: an <code>updater</code> script and a <code>versions.json</code> that stores the arguments to <code>fetchFromGitHub</code> as JSON.</p>
<p>My <code>updater</code> script looks like</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="co">#! /usr/bin/env nix-shell</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="co">#! nix-shell -i bash</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">#! nix-shell -p curl jq nix</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">set</span> <span class="ex">-eufo</span> pipefail</a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="va">FILE=$1</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="va">PROJECT=$2</span></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="va">BRANCH=${3:-</span>master<span class="va">}</span></a>
<a class="sourceLine" id="cb8-10" title="10"></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="va">OWNER=$(</span><span class="ex">jq</span> -r <span class="st">&#39;.[$project].owner&#39;</span> --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="va">REPO=$(</span><span class="ex">jq</span> -r <span class="st">&#39;.[$project].repo&#39;</span> --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-13" title="13"></a>
<a class="sourceLine" id="cb8-14" title="14"><span class="va">REV=$(</span><span class="ex">curl</span> <span class="st">&quot;https://api.github.com/repos/</span><span class="va">$OWNER</span><span class="st">/</span><span class="va">$REPO</span><span class="st">/branches/</span><span class="va">$BRANCH</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="ex">jq</span> -r <span class="st">&#39;.commit.sha&#39;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-15" title="15"><span class="va">SHA256=$(</span><span class="ex">nix-prefetch-url</span> --unpack <span class="st">&quot;https://github.com/</span><span class="va">$OWNER</span><span class="st">/</span><span class="va">$REPO</span><span class="st">/archive/</span><span class="va">$REV</span><span class="st">.tar.gz&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-16" title="16"><span class="va">TJQ=$(</span><span class="ex">jq</span> <span class="st">&#39;.[$project] = {owner: $owner, repo: $repo, rev: $rev, sha256: $sha256}&#39;</span> \</a>
<a class="sourceLine" id="cb8-17" title="17">  --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-18" title="18">  --arg owner <span class="st">&quot;</span><span class="va">$OWNER</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-19" title="19">  --arg repo <span class="st">&quot;</span><span class="va">$REPO</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-20" title="20">  --arg rev <span class="st">&quot;</span><span class="va">$REV</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-21" title="21">  --arg sha256 <span class="st">&quot;</span><span class="va">$SHA256</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-22" title="22">  <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-23" title="23"><span class="kw">[[</span> <span class="va">$?</span> <span class="ot">==</span> 0<span class="kw"> ]]</span> <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">${TJQ}</span><span class="st">&quot;</span> <span class="op">&gt;</span><span class="kw">|</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span></a></code></pre></div>
<p>It uses <code>curl</code> and <code>jq</code> to interact with the GitHub API and <code>nix</code> to calculate the appropriate hashes.</p>
<p>A simple <code>versions.json</code> looks like</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb9-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="dt">&quot;nixpkgs&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="dt">&quot;owner&quot;</span><span class="fu">:</span> <span class="st">&quot;NixOS&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="dt">&quot;repo&quot;</span><span class="fu">:</span> <span class="st">&quot;nixpkgs-channels&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="dt">&quot;rev&quot;</span><span class="fu">:</span> <span class="st">&quot;2f6440eb09b7e6e3322720ac91ce7e2cdeb413f9&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="dt">&quot;sha256&quot;</span><span class="fu">:</span> <span class="st">&quot;0vb7ikjscrp2rw0dfw6pilxqpjm50l5qg2x2mn1vfh93dkl2aan7&quot;</span></a>
<a class="sourceLine" id="cb9-7" title="7">  <span class="fu">}</span></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="fu">}</span></a></code></pre></div>
<p>And a Nix expression using these files looks like</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="ex">inherit</span> (import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {}) <span class="ex">fetchFromGitHub</span> lib<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="ex">versions</span> = lib.mapAttrs</a>
<a class="sourceLine" id="cb10-4" title="4">    <span class="kw">(</span><span class="ex">_</span>: fetchFromGitHub<span class="kw">)</span></a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="kw">(</span><span class="ex">builtins.fromJSON</span> (builtins.readFile ./versions.json<span class="kw">)</span>);</a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="co"># ./updater versions.json nixpkgs nixos-18.03</span></a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="ex">pkgs</span> = import versions.nixpkgs {};</a>
<a class="sourceLine" id="cb10-8" title="8">  <span class="ex">haskellPackages</span> = pkgs.haskellPackages.override {</a>
<a class="sourceLine" id="cb10-9" title="9">    <span class="ex">overrides</span> = self: super: {</a>
<a class="sourceLine" id="cb10-10" title="10">      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.2&quot;</span> {};</a>
<a class="sourceLine" id="cb10-11" title="11">      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.4.2&quot;</span> {};</a>
<a class="sourceLine" id="cb10-12" title="12">    };</a>
<a class="sourceLine" id="cb10-13" title="13">  };</a>
<a class="sourceLine" id="cb10-14" title="14"><span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {</a>
<a class="sourceLine" id="cb10-15" title="15">  <span class="ex">buildInputs</span> = [ haskellPackages.pandoc ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-16" title="16">} <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>And the command to update <code>nixpkgs</code> is</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1">$ <span class="ex">./updater</span> versions.json nixpkgs nixos-18.03</a></code></pre></div>
<p>The reason I went with this approach is that <code>jq</code> is easier and friendlier to use than most of the Nix tooling available, and Nix fortunately has good JSON interoperability. I’ve toyed with the idea of rewriting my updater script in a language that is more robust (possibly Haskell with <a href="https://github.com/haskell-nix/hnix">hnix</a>) but I feel like it’s at a local maximum and I’m happy with the way it works for now.</p>
<p>I hope you find some of the ideas and/or code here useful the next time you’re wondering if you should pin <code>nixpkgs</code> and how to do so!</p>
<p><strong>Appendix 1</strong></p>
<p>If you use Nix 2.0 or newer, the <code>builtins.fetchTarball</code> command takes a <code>sha256</code> which means you can replace <code>fetchFromGitHub</code> and bootstrap without an existing <code>&lt;nixpkgs&gt;</code>! The following code snippet is identical to <code>fetchFromGitHub</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" title="1"><span class="ex">fetcher</span> = { owner, repo, rev, sha256 }: <span class="ex">builtins.fetchTarball</span> {</a>
<a class="sourceLine" id="cb12-2" title="2">  <span class="ex">inherit</span> sha256<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-3" title="3">  <span class="ex">url</span> = <span class="st">&quot;https://github.com/</span><span class="va">${owner}</span><span class="st">/</span><span class="va">${repo}</span><span class="st">/archive/</span><span class="va">${rev}</span><span class="st">.tar.gz&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-4" title="4">};</a></code></pre></div>
<p>Thanks to <a href="https://jarmac.org/">Ahmad Jarara</a>, <a href="https://twitter.com/@chrisczynski">Chris Stryczynski</a>, <a href="https://github.com/garry-cairns">Garry Cairns</a>, <a href="https://haroldtreen.com/">Harold Treen</a>, <a href="https://ren.zone/">Renzo Carbonara</a>, <a href="http://susanpotter.net/">Susan Potter</a>, and <a href="https://twitter.com/tpflug">Tobias Pflug</a> for comments and feedback!</p>
]]></summary>
</entry>
<entry>
    <title>IHaskell on CoCalc!</title>
    <link href="https://vaibhavsagar.com/blog/2018/04/08/ihaskell-cocalc/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/04/08/ihaskell-cocalc/index.html</id>
    <published>2018-04-08T00:00:00Z</published>
    <updated>2018-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on  8 April 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>
    
</div>

<p>IHaskell is now available on <a href="https://cocalc.com/">CoCalc</a>! I’m excited that there are even more options for creating your own IHaskell notebooks without having to install anything.</p>
<p>This is the result of a long collaboration with the lovely people at CoCalc, particularly <a href="https://wstein.org/">William Stein</a> and <a href="http://harald.schil.ly/">Harald Schilly</a>. I’d like to say a little about how this happened, but if you’re not interested you can stop reading here!</p>
<p>During the wonderful and magical time that was my batch at the <a href="https://www.recurse.com/scout/click?t=5ac465e5d3396a7e491e42afac4c5c90">Recurse Center</a>, I fulfilled a long-term goal of <a href="https://www.youtube.com/watch?v=wsNnP3we_R4">speaking at the NYHUG</a>. I was particularly enthusiastic about IHaskell, and <a href="http://gbaz.github.io/">Gershom</a> mentioned that people at SageMathCloud were interested in <a href="https://github.com/sagemathinc/cocalc/issues/125">getting it working</a> and offered to put me in touch.</p>
<p>I immediately encountered an issue where <a href="https://github.com/gibiansky/IHaskell/issues/694">IHaskell wasn’t handling all valid inputs</a> and complained about it on <a href="https://www.recurse.com/blog/112-how-rc-uses-zulip">Zulip</a>. I woke up the next day to find that <a href="https://twitter.com/horrorcheck">Libby Horacek</a> had gone ahead and <a href="https://github.com/gibiansky/IHaskell/pull/697">fixed the issue</a>. What a legend! This was also my first open-source contribution to a Haskell project ever.</p>
<p>I then tried the obvious thing, <code>stack build &amp;&amp; stack install</code> which resulted in a working notebook but an impossible deploy, because they needed the whole installation to be self-contained whereas Stack stores some things in <code>~/.stack</code> and other things in <code>&lt;project&gt;/.stack-work</code>. I (incorrectly) assumed that having <code>ihaskell</code> be a static binary would fix the issue, so then I spent a few weeks faffing around with <a href="https://www.fpcomplete.com/blog/2016/10/static-compilation-with-stack">this</a> which resulted in a static binary and made no difference otherwise.</p>
<p>Frustrated that my first attempt failed, I went silent for a while. My batch ended, I was unemployed for a few more months, I started a new role, and I moved to a new country. Because <a href="https://github.com/gibiansky/IHaskell/pull/716#issuecomment-305934463">I asked at the right time</a>, I became a maintainer of IHaskell and we finally got GHC 8 support! We also dropped GHC 7.10 support, which was <a href="https://github.com/gibiansky/IHaskell/pull/747">controversial</a>.</p>
<p>In the meantime SageMathCloud rebranded to CoCalc and revamped its infrastructure, and <a href="https://github.com/gibiansky/IHaskell/issues/731">they put the feelers out to try again</a>.</p>
<p>I saw that they were still running GHC 7.10 and went silent again, because I didn’t want to use an old version of IHaskell or have the discussion about installing a newer GHC just so I could fiddle some more. Instead, I worked on keeping IHaskell up-to-date and making it easier to use, with PRs for <a href="https://github.com/gibiansky/IHaskell/pull/735">GHC 8.2</a>, <a href="https://github.com/gibiansky/IHaskell/pull/817">GHC 8.4</a> and supporting installation with Nix.</p>
<p>Despite my best efforts, I was still getting lots of questions about installing IHaskell and I got fed up and <a href="https://twitter.com/vbhvsgr/status/975388161898561536">whinged about it on Twitter</a>. In response, Gershom DMed me to ask how the CoCalc stuff was progressing, after which I got back in touch and asked for a newer version of GHC. They obliged with GHC 8.4.</p>
<p>By this time we had realised that Stack wasn’t going to work, so we tried old-style Cabal and new-style Cabal, which both have similar issues with dependencies in <code>~/.cabal</code>. Finally Harald suggested using <code>cabal sandbox</code> and we were able to come up with a working, self-contained IHaskell install.</p>
<p>This would have been impossible without the patience and generosity of everyone involved. All told, it took almost a year and a half to get this working, which doesn’t come across in the <a href="https://twitter.com/cocalc_com/status/982650432928583680">announcement</a>.</p>
]]></summary>
</entry>
<entry>
    <title>IHaskell on mybinder.org</title>
    <link href="https://vaibhavsagar.com/blog/2018/03/31/ihaskell-mybinder/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/03/31/ihaskell-mybinder/index.html</id>
    <published>2018-03-31T00:00:00Z</published>
    <updated>2018-03-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 31 March 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p><a href="https://mybinder.org/">mybinder.org</a> is a website that will freely host a GitHub repository as a collection of interactive Jupyter notebooks. It has excellent built-in support for some of the more popular Jupyter kernels such as Python and Julia, but it also has support for building a <code>Dockerfile</code> of your choosing.</p>
<p>This means that getting an IHaskell installation up and running can be as simple as clicking a link, and I’m happy to report that I’ve gotten this working! You can <a href="https://mybinder.org/v2/gh/gibiansky/IHaskell/master">try it here</a>.</p>
<p>I started with the simplest thing I could think of, which was to install system dependencies and Jupyter to an Ubuntu container and then run <code>stack install ihaskell</code>. You can see the Dockerfile for that <a href="https://github.com/vaibhavsagar/ihaskell-mybinder/blob/6d093c5cd06cde77e13a5a98ae8ce093ba51fee9/Dockerfile">here</a>.</p>
<p>Once I had that working, my next step was to roll these changes into <a href="https://github.com/gibiansky/IHaskell/pull/848">IHaskell’s <code>Dockerfile</code></a> and now everyone can use IHaskell on mybinder.org!</p>
<p>I’ve also <a href="https://hub.docker.com/r/vaibhavsagar/ihaskell/">pushed an image to Docker Hub</a> that you can use as a base for your own repositories. A minimal example of a valid <code>Dockerfile</code> looks something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">FROM</span> vaibhavsagar/ihaskell:4afa0aee339e</a></code></pre></div>
<p>Ideally I would also like to get this running with Nix, because that approach results in a much smaller image and is easily extensible just by editing <code>default.nix</code>. I have a small repo that <a href="https://github.com/vaibhavsagar/ihaskell-mybinder-nix">builds but doesn’t run on mybinder.org</a>, and I’ve <a href="https://github.com/jupyterhub/binder/issues/87">opened an issue</a>.</p>
<p>I’m pretty excited about what this means for the Jupyter ecosystem and IHaskell in particular, and I’m looking forward to seeing what other people do with this!</p>
]]></summary>
</entry>
<entry>
    <title>Faking Non-NixOS for Stack</title>
    <link href="https://vaibhavsagar.com/blog/2018/03/17/faking-non-nixos-stack/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/03/17/faking-non-nixos-stack/index.html</id>
    <published>2018-03-17T00:00:00Z</published>
    <updated>2018-03-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 17 March 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/nix/index.html">nix</a>
    
</div>

<p>I like most things about NixOS, but one thing I do not like is the way it integrates with <code>stack</code>. Nix’s own Haskell infrastructure works well enough that this is not an issue for my own projects, but sometimes I want to test that the Stack workflow is fine for people using less opinionated distros like Ubuntu.</p>
<p>Fortunately, Nixpkgs includes a handy tool called <code>buildFHSUserEnv</code> which will build a chroot wherein everything is laid out according to the <a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">Filesystem Hierarchy Standard</a> that most software is accustomed to. This means we can provide an environment with Stack and any dependencies and it will happily run.</p>
<p>Let’s walk through doing this for a package like <a href="https://github.com/gibiansky/IHaskell">IHaskell</a>. We begin by cloning the IHaskell repository and creating a <code>fhsenv.nix</code> with only <code>stack</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {};</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="ex">pkgs.haskellPackages.stack</span></a>
<a class="sourceLine" id="cb1-7" title="7">  ];</a>
<a class="sourceLine" id="cb1-8" title="8">}</a></code></pre></div>
<p>Entering the chroot and running <code>stack build</code> gives us our first error:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1">$ <span class="va">$(</span><span class="ex">nix-build</span> fhsenv.nix<span class="va">)</span><span class="ex">/bin/fhs</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ex">fhs-chrootenv</span>$ stack build</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ex">HttpExceptionRequest</span> Request {</a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="ex">host</span>                 = <span class="st">&quot;raw.githubusercontent.com&quot;</span></a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="ex">port</span>                 = 443</a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="ex">secure</span>               = True</a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="ex">requestHeaders</span>       = []</a>
<a class="sourceLine" id="cb2-8" title="8">  <span class="ex">path</span>                 = <span class="st">&quot;/fpco/stackage-content/master/stack/stack-setup-2.yaml&quot;</span></a>
<a class="sourceLine" id="cb2-9" title="9">  <span class="ex">queryString</span>          = <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb2-10" title="10">  <span class="ex">method</span>               = <span class="st">&quot;GET&quot;</span></a>
<a class="sourceLine" id="cb2-11" title="11">  <span class="ex">proxy</span>                = Nothing</a>
<a class="sourceLine" id="cb2-12" title="12">  <span class="ex">rawBody</span>              = False</a>
<a class="sourceLine" id="cb2-13" title="13">  <span class="ex">redirectCount</span>        = 10</a>
<a class="sourceLine" id="cb2-14" title="14">  <span class="ex">responseTimeout</span>      = ResponseTimeoutDefault</a>
<a class="sourceLine" id="cb2-15" title="15">  <span class="ex">requestVersion</span>       = HTTP/1.1</a>
<a class="sourceLine" id="cb2-16" title="16">}</a>
<a class="sourceLine" id="cb2-17" title="17"> <span class="kw">(</span><span class="ex">ConnectionFailure</span> Network.BSD.getProtocolByName: does not exist (no such protocol name: tcp<span class="kw">)</span>)</a></code></pre></div>
<p>Looking through the Nixpkgs issue tracker for similar errors reveals that we need the <code>iana-etc</code> package. Let’s add it:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {};</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="ex">pkgs.haskellPackages.stack</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="ex">pkgs.iana-etc</span></a>
<a class="sourceLine" id="cb3-8" title="8">  ];</a>
<a class="sourceLine" id="cb3-9" title="9">}</a></code></pre></div>
<p>Now it’ll start to download GHC, which takes forever for me. This is the wrong download though, so cancel it and let’s move on. More on this in a bit.</p>
<p>If the download had successfully completed, <code>stack</code> would then have complained that <code>make</code> was unavailable, so we add <code>gnumake</code>. Then it would have complained about the lack of Perl, a missing C compiler, missing <code>libgmp</code>, and no <code>pkg-config</code>, so we add those too. Then it progresses a lot further before it halts, complaining about <code>libtinfo</code> being missing. The closest thing we have is <code>ncurses</code>, so we add that too. Now our expression looks like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {};</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="ex">pkgs.iana-etc</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="ex">pkgs.haskellPackages.stack</span></a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="ex">pkgs.gcc</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="ex">pkgs.gmp</span></a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="ex">pkgs.gnumake</span></a>
<a class="sourceLine" id="cb4-11" title="11">    <span class="ex">pkgs.perl</span></a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="ex">pkgs.pkgconfig</span></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="ex">pkgs.ncurses</span></a>
<a class="sourceLine" id="cb4-14" title="14">  ];</a>
<a class="sourceLine" id="cb4-15" title="15">}</a></code></pre></div>
<p>This prompts <code>stack</code> to download a different GHC, but the whole process should complete successfully now.</p>
<p>At this point, we’re in luck, because IHaskell has been configured to work with <code>stack --nix</code>, which means the dependencies <code>stack</code> needs are already specified under the <code>nix.packages</code> key in <code>stack.yaml</code>, and we can copy them into <code>fhsenv.nix</code> to speed up the process of building everything. At this point I found that header files in <code>/usr/include</code> weren’t being found, but this was easy to fix by specifying <code>C_INCLUDE_PATH</code> in the <code>profile</code> attribute. I’d recommend commenting out <code>ihaskell-widgets</code> at this point, because it takes an absurdly long time to compile and doesn’t seem to have any interesting dependencies. The complete <code>fhsenv.nix</code> for <code>stack build</code> and <code>stack test</code> looks like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {};</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="ex">pkgs.blas</span></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="ex">pkgs.cairo.dev</span></a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="ex">pkgs.file</span></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="ex">pkgs.gcc</span></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="ex">pkgs.glib.dev</span></a>
<a class="sourceLine" id="cb5-11" title="11">    <span class="ex">pkgs.gmp</span></a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="ex">pkgs.gnumake</span></a>
<a class="sourceLine" id="cb5-13" title="13">    <span class="ex">pkgs.haskellPackages.stack</span></a>
<a class="sourceLine" id="cb5-14" title="14">    <span class="ex">pkgs.iana-etc</span></a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="ex">pkgs.liblapack</span></a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="ex">pkgs.pango.dev</span></a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="ex">pkgs.perl</span></a>
<a class="sourceLine" id="cb5-18" title="18">    <span class="ex">pkgs.pkgconfig</span></a>
<a class="sourceLine" id="cb5-19" title="19">    <span class="ex">pkgs.ncurses</span></a>
<a class="sourceLine" id="cb5-20" title="20">    <span class="ex">pkgs.zeromq</span></a>
<a class="sourceLine" id="cb5-21" title="21">    <span class="ex">pkgs.zlib.dev</span></a>
<a class="sourceLine" id="cb5-22" title="22">  ];</a>
<a class="sourceLine" id="cb5-23" title="23">  <span class="ex">profile</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb5-24" title="24">    <span class="bu">export</span> <span class="va">C_INCLUDE_PATH=</span>/usr/include:<span class="va">$C_INClUDE_PATH</span></a>
<a class="sourceLine" id="cb5-25" title="25">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb5-26" title="26">}</a></code></pre></div>
<p>Of course, building IHaskell is no fun if we can’t install it and see it in action. Providing the Jupyter notebook environment is an additional line:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {};</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="ex">pkgs.blas</span></a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="ex">pkgs.cairo.dev</span></a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="ex">pkgs.file</span></a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="ex">pkgs.gcc</span></a>
<a class="sourceLine" id="cb6-10" title="10">    <span class="ex">pkgs.glib.dev</span></a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="ex">pkgs.gmp</span></a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="ex">pkgs.gnumake</span></a>
<a class="sourceLine" id="cb6-13" title="13">    <span class="ex">pkgs.haskellPackages.stack</span></a>
<a class="sourceLine" id="cb6-14" title="14">    <span class="ex">pkgs.iana-etc</span></a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="ex">pkgs.liblapack</span></a>
<a class="sourceLine" id="cb6-16" title="16">    <span class="ex">pkgs.pango.dev</span></a>
<a class="sourceLine" id="cb6-17" title="17">    <span class="ex">pkgs.perl</span></a>
<a class="sourceLine" id="cb6-18" title="18">    <span class="ex">pkgs.pkgconfig</span></a>
<a class="sourceLine" id="cb6-19" title="19">    <span class="kw">(</span><span class="ex">pkgs.python3.withPackages</span> (ps: [ ps.jupyter ps.notebook ]<span class="kw">)</span>)</a>
<a class="sourceLine" id="cb6-20" title="20">    <span class="ex">pkgs.ncurses</span></a>
<a class="sourceLine" id="cb6-21" title="21">    <span class="ex">pkgs.zeromq</span></a>
<a class="sourceLine" id="cb6-22" title="22">    <span class="ex">pkgs.zlib.dev</span></a>
<a class="sourceLine" id="cb6-23" title="23">  ];</a>
<a class="sourceLine" id="cb6-24" title="24">  <span class="ex">profile</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-25" title="25">    <span class="bu">export</span> <span class="va">C_INCLUDE_PATH=</span>/usr/include:<span class="va">$C_INClUDE_PATH</span></a>
<a class="sourceLine" id="cb6-26" title="26">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb6-27" title="27">}</a></code></pre></div>
<p>and we can install and run IHaskell as usual:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1"><span class="ex">fhs-chrootenv</span>$ stack build</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ex">fhs-chrootenv</span>$ stack exec -- ihaskell install --stack</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ex">fhs-chrootenv</span>$ stack exec -- jupyter notebook</a></code></pre></div>
<p>Cool!</p>
<p>This expression is available <a href="https://github.com/vaibhavsagar/experiments/blob/master/stack-env-nix/ihaskell.nix">on GitHub</a>.</p>
]]></summary>
</entry>
<entry>
    <title>Revisiting 'Monadic Parsing in Haskell'</title>
    <link href="https://vaibhavsagar.com/blog/2018/02/04/revisiting-monadic-parsing-haskell/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/02/04/revisiting-monadic-parsing-haskell/index.html</id>
    <published>2018-02-04T00:00:00Z</published>
    <updated>2018-02-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on  4 February 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/monads/index.html">monads</a>
    
</div>

<p><em>Translated to <a href="http://clipartmag.com/ru-revisiting-monadic-parsing-haskell">Russian</a> by <a href="http://clipartmag.com/">Clipart Team</a></em></p>
<p><a href="http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf">‘Monadic Parsing in Haskell’</a> is a short paper that laid the groundwork for libraries like Parsec and Attoparsec. Although it was published in 1998 (almost 20 years ago!) it has aged gracefully and the code samples will run with almost no changes. However, the state of the art has advanced since then and I think the use of modern Haskell can make this material simpler to follow and implement.</p>
<p>Monadic parsing in Haskell is what sold me on all three. Before Haskell my experiences with parsing had involved buggy regexes for lexers and wrangling tools like <code>bison</code> and <code>flex</code>, and although I’d heard that Haskell was good for parsing I couldn’t see how this could be the case when I couldn’t find any robust regex libraries! An aside in some documentation pointed me to Attoparsec and when I saw the <a href="https://github.com/bos/attoparsec/blob/master/examples/RFC2616.hs">example RFC2616 parser</a> it seemed like a magic trick. How could it be so small? After a few weeks of trying it myself I was convinced and I’ve never looked back. This was the first application of monads I encountered that actually made my life simpler, and I started to realise that there was more to monads than smugness and being inaccessible to newcomers.</p>
<p>The first change I want to make is the type definition. The paper uses the type</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="ot">=</span> <span class="dt">Parser</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> [(a,<span class="dt">String</span>)])</a></code></pre></div>
<p>and although this is a famous enough definition that it has <a href="http://www.willamette.edu/~fruehr/haskell/seuss.html">its own rhyme</a>, I think the flexibility of lists is wasted here. The authors don’t use it, and instead define a ‘deterministic choice’ operator <code>(+++)</code> that gives at most one result and use that everywhere instead. There is already a perfectly good datatype in Haskell for lists of at most one element, <code>Maybe</code>, so I’ll use that instead of <code>[]</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="ot">=</span> <span class="dt">Parser</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>))</a></code></pre></div>
<p>If we rename <code>String</code> to <code>s</code> and <code>Maybe</code> to <code>m</code>, a more interesting pattern is revealed:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">newtype</span> <span class="dt">Parser</span> s m a <span class="ot">=</span> <span class="dt">Parser</span> (s <span class="ot">-&gt;</span> m (a, s))</a></code></pre></div>
<p>This is <a href="https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-State-Strict.html#t:StateT"><code>StateT</code></a>! Recognising this pattern makes instance definitions much easier, so much easier in fact that GHC can do it for us automatically with <code>-XGeneralizedNewtypeDeriving</code>! For completeness I will resist the temptation to do this, but you can try it yourself with</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="ot">=</span> <span class="dt">Parser</span> (<span class="dt">StateT</span> <span class="dt">String</span> <span class="dt">Maybe</span> a) <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Alternative</span>, <span class="dt">Monad</span>)</a></code></pre></div>
<p>The second change is also for completeness: the authors jump straight into the <code>Monad</code> instance without defining <code>Functor</code> and <code>Applicative</code> first. To be fair, the <code>Applicative</code> abstraction hadn’t been <a href="http://www.staff.city.ac.uk/~ross/papers/Applicative.html">discovered</a> yet, and this is also the reason why the authors define <code>mzero</code> and <code>mplus</code> (which they call <code>(++)</code>) instead of the more general <code>Alternative</code> methods <code>empty</code> and <code>(&lt;|&gt;)</code>. Because of our <code>Maybe</code> change, defining <code>Alternative</code> means I won’t need to bother with their <code>(+++)</code>.</p>
<p>Finally, I’ll try to avoid do-notation where possible in favour of a more Applicative style using e.g. <code>&lt;*&gt;</code> (which can be pronounced ‘splat’ if you don’t already have a name for it) because most of these parsers don’t require it.</p>
<p>Let’s begin!</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">import</span> <span class="dt">Control.Applicative</span> (<span class="dt">Alternative</span>(..))</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">import</span> <span class="dt">Control.Monad.Trans.State.Strict</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">import</span> <span class="dt">Control.Monad</span> (guard)</a>
<a class="sourceLine" id="cb5-6" title="6"><span class="kw">import</span> <span class="dt">Data.Char</span> (isSpace, isDigit, ord)</a></code></pre></div>
<p>For convenience I’ve defined an <code>unParser</code> that unwraps a <code>Parser a</code> to its underlying <code>StateT String Maybe a</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="ot">=</span> <span class="dt">Parser</span> {<span class="ot"> unParser ::</span> <span class="dt">StateT</span> <span class="dt">String</span> <span class="dt">Maybe</span> a }</a>
<a class="sourceLine" id="cb6-2" title="2">runParser <span class="ot">=</span> runStateT <span class="op">.</span> unParser</a></code></pre></div>
<p><code>fmap</code> is as simple as unwrapping the <code>Parser</code> and using the underlying <code>StateT</code>’s <code>fmap</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Parser</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="fu">fmap</span> f p <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> f <span class="op">&lt;$&gt;</span> unParser p</a></code></pre></div>
<p>More unwrapping for <code>Applicative</code> and <code>Alternative</code>.</p>
<p>The <a href="https://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:Alternative"><code>Alternative</code></a> typeclass allows us to express the idea of running one parser or another parser, resulting in the first successful parse. <code>empty</code> handles the case where both parsers fail, and <code>(&lt;|&gt;)</code> (which can be pronounced ‘alt’) performs the alternation. This is convenient enough on its own, but <code>Alternative</code> also provides <code>many</code> and <code>some</code> which correspond exactly to <code>many</code> and <code>many1</code> from the paper:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="co">-- many v = some v &lt;|&gt; pure []</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="co">-- some v = (:) &lt;$&gt; v &lt;*&gt; many v</span></a></code></pre></div>
<p>but only after replacing <code>[]</code> with <code>Maybe</code> like I’ve done here so that <code>(&lt;|&gt;)</code> corresponds to <code>(+++)</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Parser</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="fu">pure</span> a  <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> <span class="fu">pure</span> a</a>
<a class="sourceLine" id="cb9-4" title="4"><span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</a>
<a class="sourceLine" id="cb9-5" title="5">    f <span class="op">&lt;*&gt;</span> a <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> unParser f <span class="op">&lt;*&gt;</span> unParser a</a>
<a class="sourceLine" id="cb9-6" title="6"></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Parser</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="ot">    empty ::</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb9-9" title="9">    empty   <span class="ot">=</span> <span class="dt">Parser</span> empty</a>
<a class="sourceLine" id="cb9-10" title="10"><span class="ot">    (&lt;|&gt;) ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb9-11" title="11">    a <span class="op">&lt;|&gt;</span> b <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> unParser a <span class="op">&lt;|&gt;</span> unParser b</a></code></pre></div>
<p>The <code>Monad</code> definition is slightly more interesting, because we have to manually construct the <code>StateT</code> value, but this also boils down to unwrapping and rewrapping.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Parser</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</a>
<a class="sourceLine" id="cb10-3" title="3">    a <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">$</span> <span class="dt">StateT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-4" title="4">        (a&#39;, s&#39;) <span class="ot">&lt;-</span> runParser a s</a>
<a class="sourceLine" id="cb10-5" title="5">        runParser (f a&#39;) s&#39;</a></code></pre></div>
<p>Notice that <code>anyChar</code> is the only function below that manually constructs a <code>Parser</code>, and <code>satisfy</code> is the only one that requires the <code>Monad</code> interface.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">anyChar ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-2" title="2">anyChar <span class="ot">=</span> <span class="dt">Parser</span> <span class="op">.</span> <span class="dt">StateT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-3" title="3">    []     <span class="ot">-&gt;</span> empty</a>
<a class="sourceLine" id="cb11-4" title="4">    (c<span class="op">:</span>cs) <span class="ot">-&gt;</span> <span class="fu">pure</span> (c, cs)</a>
<a class="sourceLine" id="cb11-5" title="5"></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="ot">satisfy ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-7" title="7">satisfy <span class="fu">pred</span> <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-8" title="8">    c <span class="ot">&lt;-</span> anyChar</a>
<a class="sourceLine" id="cb11-9" title="9">    guard <span class="op">$</span> <span class="fu">pred</span> c</a>
<a class="sourceLine" id="cb11-10" title="10">    <span class="fu">pure</span> c</a>
<a class="sourceLine" id="cb11-11" title="11"></a>
<a class="sourceLine" id="cb11-12" title="12"><span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-13" title="13">char <span class="ot">=</span> satisfy <span class="op">.</span> (<span class="op">==</span>)</a>
<a class="sourceLine" id="cb11-14" title="14"></a>
<a class="sourceLine" id="cb11-15" title="15"><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb11-16" title="16">string []     <span class="ot">=</span> <span class="fu">pure</span> []</a>
<a class="sourceLine" id="cb11-17" title="17">string (c<span class="op">:</span>cs) <span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> char c <span class="op">&lt;*&gt;</span> string cs</a></code></pre></div>
<p>Again, <code>many</code> and <code>many1</code> don’t need to be defined because they are provided for free!</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">sepBy ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]</a>
<a class="sourceLine" id="cb12-2" title="2">sepBy p sep <span class="ot">=</span> (p <span class="ot">`sepBy1`</span> sep) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> []</a>
<a class="sourceLine" id="cb12-3" title="3"></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="ot">sepBy1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]</a>
<a class="sourceLine" id="cb12-5" title="5">sepBy1 p sep <span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> p <span class="op">&lt;*&gt;</span> many (sep <span class="op">*&gt;</span> p)</a></code></pre></div>
<p>These are almost identical to the definitions in the paper. I’ve included <code>chainr</code> for completeness.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">chainl ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb13-2" title="2">chainl p op a <span class="ot">=</span> (p <span class="ot">`chainl1`</span> op) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> a</a>
<a class="sourceLine" id="cb13-3" title="3"></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="ot">chainl1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb13-5" title="5">chainl1 p op <span class="ot">=</span> p <span class="op">&gt;&gt;=</span> rest</a>
<a class="sourceLine" id="cb13-6" title="6">    <span class="kw">where</span> </a>
<a class="sourceLine" id="cb13-7" title="7">        rest a <span class="ot">=</span> (<span class="kw">do</span></a>
<a class="sourceLine" id="cb13-8" title="8">            f <span class="ot">&lt;-</span> op</a>
<a class="sourceLine" id="cb13-9" title="9">            b <span class="ot">&lt;-</span> p</a>
<a class="sourceLine" id="cb13-10" title="10">            rest (f a b)) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> a</a>
<a class="sourceLine" id="cb13-11" title="11"></a>
<a class="sourceLine" id="cb13-12" title="12"><span class="ot">chainr ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb13-13" title="13">chainr p op a <span class="ot">=</span> (p <span class="ot">`chainr1`</span> op) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> a</a>
<a class="sourceLine" id="cb13-14" title="14"></a>
<a class="sourceLine" id="cb13-15" title="15"><span class="ot">chainr1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb13-16" title="16">chainr1 p op <span class="ot">=</span> scan</a>
<a class="sourceLine" id="cb13-17" title="17">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-18" title="18">        scan   <span class="ot">=</span> p <span class="op">&gt;&gt;=</span> rest</a>
<a class="sourceLine" id="cb13-19" title="19">        rest a <span class="ot">=</span> (<span class="kw">do</span></a>
<a class="sourceLine" id="cb13-20" title="20">            f <span class="ot">&lt;-</span> op</a>
<a class="sourceLine" id="cb13-21" title="21">            b <span class="ot">&lt;-</span> scan</a>
<a class="sourceLine" id="cb13-22" title="22">            rest (f a b)) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> a</a></code></pre></div>
<p>The only difference here is the replacement of <code>(&gt;&gt;)</code> with <code>(*&gt;)</code>. These have the same effect, except that the latter works on <code>Applicative</code>s and also comes with a counterpart <code>(&lt;*)</code>. When writing parsers I find these especially useful because they allow me to combine multiple parsers together when I only care about the output of one of them, e.g. <code>ignored *&gt; ignored *&gt; value &lt;* ignored</code>. The calculator example uses this in <code>factor</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">space ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb14-2" title="2">space <span class="ot">=</span> many (satisfy <span class="fu">isSpace</span>)</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="ot">token ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb14-5" title="5">token p <span class="ot">=</span> p <span class="op">&lt;*</span> space</a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="ot">symbol ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb14-8" title="8">symbol <span class="ot">=</span> token <span class="op">.</span> string</a>
<a class="sourceLine" id="cb14-9" title="9"></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="ot">apply ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb14-11" title="11">apply p <span class="ot">=</span> runParser (space <span class="op">*&gt;</span> p)</a></code></pre></div>
<p>The calculator example is almost unchanged.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1">expr, term, factor,<span class="ot"> digit ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-2" title="2">expr   <span class="ot">=</span> term   <span class="ot">`chainl1`</span> addop</a>
<a class="sourceLine" id="cb15-3" title="3">term   <span class="ot">=</span> factor <span class="ot">`chainl1`</span> mulop</a>
<a class="sourceLine" id="cb15-4" title="4">factor <span class="ot">=</span> digit <span class="op">&lt;|&gt;</span> (symbol <span class="st">&quot;(&quot;</span> <span class="op">*&gt;</span> expr <span class="op">&lt;*</span> symbol <span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb15-5" title="5">digit  <span class="ot">=</span> <span class="fu">subtract</span> (<span class="fu">ord</span> <span class="ch">&#39;0&#39;</span>) <span class="op">.</span> <span class="fu">ord</span> <span class="op">&lt;$&gt;</span> token (satisfy <span class="fu">isDigit</span>)</a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7">addop,<span class="ot"> mulop ::</span> <span class="dt">Parser</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb15-8" title="8">addop <span class="ot">=</span> (symbol <span class="st">&quot;+&quot;</span> <span class="op">*&gt;</span> <span class="fu">pure</span> (<span class="op">+</span>)) <span class="op">&lt;|&gt;</span> (symbol <span class="st">&quot;-&quot;</span> <span class="op">*&gt;</span> <span class="fu">pure</span> (<span class="op">-</span>))</a>
<a class="sourceLine" id="cb15-9" title="9">mulop <span class="ot">=</span> (symbol <span class="st">&quot;*&quot;</span> <span class="op">*&gt;</span> <span class="fu">pure</span> (<span class="op">*</span>)) <span class="op">&lt;|&gt;</span> (symbol <span class="st">&quot;/&quot;</span> <span class="op">*&gt;</span> <span class="fu">pure</span> (<span class="fu">div</span>))</a></code></pre></div>
<p>Finally, the payoff!</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1">runParser expr <span class="st">&quot;(1 + 2 * 4) / 3 + 5&quot;</span></a></code></pre></div>
<pre><code>Just (8,&quot;&quot;)</code></pre>
<p>What have we gained in 20 years? With only minor changes, the code is more composable and uses finer-grained abstractions. For example, if we change our minds about replacing <code>[]</code> with <code>Maybe</code>, we can switch it back and would only have to update the type signature of <code>apply</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="ot">apply ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(a, <span class="dt">String</span>)]</a>
<a class="sourceLine" id="cb18-2" title="2">apply p <span class="ot">=</span> runParser (space <span class="op">*&gt;</span> p) <span class="co">-- the implementation stays the same!</span></a></code></pre></div>
<p>If we want better error messages, we could use a type such as <code>Either String</code> to keep track of locations and error messages. The <a href="http://hackage.haskell.org/package/yoctoparsec"><code>yoctoparsec</code></a> library takes this even further, allowing to you to choose your own stream type.</p>
<p>Another big difference is the <code>Applicative</code> family of functions, which we can leverage whenever we don’t have to branch on a previously parsed value (which turns out to be surprisingly often). I’m a huge fan of the <code>x &lt;$&gt; y &lt;*&gt; z</code> and the <code>ignored *&gt; value &lt;* ignored</code> idioms and I think it’s useful to be able to parse this way.</p>
<p>Otherwise, the code is largely the same and I think it’s pretty incredible that so little has changed in 20 years! This code is available as an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/revisiting-monadic-parsing-haskell/Parser.ipynb">IHaskell notebook</a> if you would like to experiment with it yourself.</p>
<p><em>Edit: I just found <a href="https://lirias.kuleuven.be/bitstream/123456789/499951/1/main.pdf">‘From monoids to near-semirings: the essence of <code>MonadPlus</code> and <code>Alternative</code>’</a>, which demonstrates how my <code>Maybe</code>-based parser doesn’t strictly obey the <code>Alternative</code> laws. Something to keep in mind if you plan to use it or something like it!</em></p>
<p>Thanks to <a href="https://github.com/cqfd">Alan O’Donnell</a>, <a href="https://blogs.ncl.ac.uk/andreymokhov/">Andrey Mokhov</a>, <a href="https://anniecherkaev.com/">Annie Cherkaev</a>, <a href="https://jvns.ca/">Julia Evans</a>, and <a href="https://github.com/rampion/">Noah Luck Easterly</a> for comments and feedback!</p>
]]></summary>
</entry>
<entry>
    <title>Building Static Haskell Binaries with Nix</title>
    <link href="https://vaibhavsagar.com/blog/2018/01/03/static-haskell-nix/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/01/03/static-haskell-nix/index.html</id>
    <published>2018-01-03T00:00:00Z</published>
    <updated>2018-01-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on  3 January 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/nix/index.html">nix</a>, <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p><em>Most of the instructions in this blog post have been improved on in Niklas Hambüchen’s <a href="https://github.com/nh2/static-haskell-nix">https://github.com/nh2/static-haskell-nix</a>, so if you’re primarily interesting in getting things working quickly I would recommend looking there first.</em></p>
<p><em>Skip to the end for a faster and easier way of getting this working. All you have to do is clone the linked repo and run <code>nix-build default.nix</code>!</em></p>
<p>The section of the Nixpkgs manual that talks about <a href="https://nixos.org/nixpkgs/manual/#creating-statically-linked-binaries">creating statically linked binaries</a> with Haskell ends with the caveat:</p>
<blockquote>
<p>It’s important to realize, however, that most system libraries in Nix are built as shared libraries only, i.e. there is just no static library available that Cabal could link!</p>
</blockquote>
<p>That sounds like a challenge. Especially when doing it on other platforms is <a href="http://www.kuznero.com/posts/haskell/building-statically-linked-binaries.html">so easy</a>.</p>
<p>On other platforms, building a static binary is meant to be as simple as</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1">$ <span class="ex">cabal</span> update</a>
<a class="sourceLine" id="cb1-2" title="2">$ <span class="ex">cabal</span> install --only-dependencies</a>
<a class="sourceLine" id="cb1-3" title="3">$ <span class="ex">cabal</span> configure --disable-executable-dynamic --disable-shared --ghc-option=-optl=-static</a>
<a class="sourceLine" id="cb1-4" title="4">$ <span class="ex">cabal</span> build</a></code></pre></div>
<p>with the magic happening in the second step. On Nix, we do in fact have the necessary static libraries and we can provide them as build inputs but keeping track of the library paths gets hairy quickly. Fortunately Nix has an escape hatch called <code>buildFHSUserEnv</code> that we can use to simulate an environment that <code>cabal</code> is more familiar with.</p>
<p>Let’s put it through its paces by building a simple Scotty web app:</p>
<p><em>blank-me-up.cabal</em></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">name<span class="op">:</span>                blank<span class="op">-</span>me<span class="op">-</span>up</a>
<a class="sourceLine" id="cb2-2" title="2">version<span class="op">:</span>             <span class="fl">0.1</span><span class="op">.</span><span class="fl">0.0</span></a>
<a class="sourceLine" id="cb2-3" title="3">license<span class="op">:</span>             <span class="dt">BSD3</span></a>
<a class="sourceLine" id="cb2-4" title="4">build<span class="op">-</span><span class="kw">type</span><span class="op">:</span>          <span class="dt">Simple</span></a>
<a class="sourceLine" id="cb2-5" title="5">cabal<span class="op">-</span>version<span class="op">:</span>       <span class="op">&gt;=</span><span class="fl">1.10</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">executable blank<span class="op">-</span>me<span class="op">-</span>up</a>
<a class="sourceLine" id="cb2-8" title="8">  main<span class="op">-</span>is<span class="op">:</span>             Main.hs</a>
<a class="sourceLine" id="cb2-9" title="9">  build<span class="op">-</span>depends<span class="op">:</span>       base <span class="op">&gt;=</span><span class="fl">4.9</span> <span class="op">&amp;&amp;</span> <span class="op">&lt;</span><span class="dv">5</span></a>
<a class="sourceLine" id="cb2-10" title="10">                     , scotty</a>
<a class="sourceLine" id="cb2-11" title="11">  default<span class="op">-</span>language<span class="op">:</span>    <span class="dt">Haskell2010</span></a></code></pre></div>
<p><em>Main.hs</em></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"> <span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">import</span> <span class="dt">Web.Scotty</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">import</span> <span class="dt">Data.Monoid</span> (mconcat)</a>
<a class="sourceLine" id="cb3-6" title="6"></a>
<a class="sourceLine" id="cb3-7" title="7">main <span class="ot">=</span> scotty <span class="dv">3000</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-8" title="8">    get <span class="st">&quot;/:word&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-9" title="9">        beam <span class="ot">&lt;-</span> param <span class="st">&quot;word&quot;</span></a>
<a class="sourceLine" id="cb3-10" title="10">        html <span class="op">$</span> <span class="fu">mconcat</span> [<span class="st">&quot;&lt;h1&gt;Scotty, &quot;</span>, beam, <span class="st">&quot; me up!&lt;/h1&gt;&quot;</span>]</a></code></pre></div>
<p>We create <code>static.nix</code>:</p>
<p><em>static.nix</em></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {};</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="kw">(</span><span class="ex">pkgs.haskellPackages.ghcWithPackages</span> (p: with p<span class="kw">;</span><span class="bu"> [</span> cabal-install ]))</a>
<a class="sourceLine" id="cb4-7" title="7">    pkgs.gmp5.static</a>
<a class="sourceLine" id="cb4-8" title="8">    pkgs.glibc.static</a>
<a class="sourceLine" id="cb4-9" title="9">    pkgs.zlib.static</a>
<a class="sourceLine" id="cb4-10" title="10">    pkgs.zlib.dev</a>
<a class="sourceLine" id="cb4-11" title="11">  ];</a>
<a class="sourceLine" id="cb4-12" title="12">}</a></code></pre></div>
<p>This defines a chroot where statically linked versions of <code>gmp</code>, <code>glibc</code>, and <code>zlib</code> are available, as well as <code>zlib.h</code>. We enter this environment by running</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1">$ <span class="va">$(</span><span class="ex">nix-build</span> static.nix<span class="va">)</span><span class="ex">/bin/fhs</span></a></code></pre></div>
<p>and then we can run the commands above with only slight modifications:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1">$ <span class="ex">cabal</span> update</a>
<a class="sourceLine" id="cb6-2" title="2">$ <span class="ex">cabal</span> install --only-dependencies --extra-include-dirs=/usr/include --extra-lib-dirs=/usr/lib</a>
<a class="sourceLine" id="cb6-3" title="3">$ <span class="ex">cabal</span> configure --disable-executable-dynamic --disable-shared --ghc-option=-optl=-pthread --ghc-option=-optl=-static --ghc-option=-optl=-L/usr/lib</a>
<a class="sourceLine" id="cb6-4" title="4">$ <span class="ex">cabal</span> build</a></code></pre></div>
<p>The difference is the extra options passed to the linker. After the last command, I get a whole bunch of warnings about</p>
<pre><code>&quot;Using &#39;&lt;function&gt;&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking&quot;</code></pre>
<p>which is definitely something to watch out for if you plan on deploying these executables to a machine that might be running a different version of <code>glibc</code>. A more robust solution is to link against e.g. <code>musl</code> instead of <code>glibc</code>, as Niklas Hambüchen has done <a href="https://github.com/nh2/static-haskell-nix">here</a>. You can confirm that the executable has been statically linked by running</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1">$ <span class="fu">ldd</span> dist/build/blank-me-up/blank-me-up</a>
<a class="sourceLine" id="cb8-2" title="2">        <span class="ex">not</span> a dynamic executable</a></code></pre></div>
<p>I’ve made this project available <a href="https://github.com/vaibhavsagar/experiments/tree/master/static-haskell-nix">here</a> if you’d like to tweak it. Since this was relatively straightforward, I think it might be possible to do this without <code>buildFHSUserEnv</code>. Maybe I will try that next.</p>
<p>Happy static linking!</p>
<p><strong>Edit 1:</strong> This turned out to be fairly easy. I took the output of</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1">$ <span class="ex">cabal2nix</span> --shell . <span class="op">&gt;</span> default.nix</a></code></pre></div>
<p>and changed <code>enableSharedExecutables</code>, <code>enableSharedLibraries</code>, and <code>configureFlags</code> as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" title="1"><span class="ex">enableSharedExecutables</span> = false<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ex">enableSharedLibraries</span> = false<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ex">configureFlags</span> = [</a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="st">&quot;--ghc-option=-optl=-static&quot;</span></a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="st">&quot;--ghc-option=-optl=-pthread&quot;</span></a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="st">&quot;--ghc-option=-optl=-L</span><span class="va">${pkgs</span><span class="er">.gmp6.override { withStatic </span><span class="va">=</span> true; <span class="va">}</span><span class="st">}/lib&quot;</span></a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="st">&quot;--ghc-option=-optl=-L</span><span class="va">${pkgs</span><span class="er">.zlib.static</span><span class="va">}</span><span class="st">/lib&quot;</span></a>
<a class="sourceLine" id="cb10-8" title="8">  <span class="st">&quot;--ghc-option=-optl=-L</span><span class="va">${pkgs</span><span class="er">.glibc.static</span><span class="va">}</span><span class="st">/lib&quot;</span></a>
<a class="sourceLine" id="cb10-9" title="9">];</a></code></pre></div>
<p>This is also available in the linked repository, and you can pin <code>nixpkgs</code> as follows to get my exact build:</p>
<pre><code>$ nix-build -I nixpkgs=https://github.com/NixOS/nixpkgs-channels/archive/08d245eb31a3de0ad73719372190ce84c1bf3aee.tar.gz default.nix</code></pre>
<p><strong>Edit 2</strong>: <a href="https://github.com/angerman">Moritz Angermann</a> and <a href="https://github.com/nh2">Niklas Hambüchen</a> improved these instructions to be more robust. Thanks Moritz and Niklas!</p>
]]></summary>
</entry>

</feed>
