<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Vaibhav Sagar's blog</title>
    <link href="http://vaibhavsagar.com/atom.xml" rel="self" />
    <link href="http://vaibhavsagar.com" />
    <id>http://vaibhavsagar.com/atom.xml</id>
    <author>
        <name>Vaibhav Sagar</name>
        <email>vaibhavsagar@gmail.com</email>
    </author>
    <updated>2017-06-19T00:00:00Z</updated>
    <entry>
    <title>Lazy Functional State Threads</title>
    <link href="http://vaibhavsagar.com/blog/2017/06/19/lazy-functional-state-threads/index.html" />
    <id>http://vaibhavsagar.com/blog/2017/06/19/lazy-functional-state-threads/index.html</id>
    <published>2017-06-19T00:00:00Z</published>
    <updated>2017-06-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 19 June 2017
    
</div>
<div class="info">
    
        Tags: <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming.html">programming</a>, <a href="/tags/monads.html">monads</a>
    
</div>

<p>A funny thing happened when I was writing my Imperative Haskell post: after railing against Haskell’s tendency to tell you to go off and read a paper when introducing a library, I went off and read ‘Lazy Functional State Threads’ and was gobsmacked by how accessible I found it. I’d like to try and demystify it for a wider audience.</p>
<p>The paper begins by admitting that we sometimes want to express strict stateful computations in a purely-functional language efficiently. We want to do this <a href="http://www.threewordphrase.com/pardonme.gif">because of reasons</a>. Some examples of algorithms we’d like to express are those based on mutable hash tables, union find, and especially input/output. However, the language we are working with is renowned for its laziness, which means the order of evaluation can be counterintuitive, and its referential transparency, which means a lack of side effects.</p>
<p>We square this circle by leveraging the type system, which simultaneously allows most of the features we take for granted in imperative languages (multiple named variables, in-place updates) as well as being encapsulated and referentially transparent (for certain values of referentially transparent). Let’s define a ‘state transformer’ that takes an initial state as input and returns a final state. This can be represented as a value of type <code>ST s a</code> where <code>s</code> is the state type and <code>a</code> is the return type.</p>
<!-- picture of state transformer -->
<p>A state transformer can have multiple inputs (multiple arguments to a function) and multiple outputs (a tuple).</p>
<!-- picture of multiple input/output state transformer -->
<p>The simplest state transformer takes a value of type <code>a</code> and sticks it in a state transformer. We’ll call it <code>returnST</code>.</p>
<!-- picture of returnST -->
<p>Let’s talk about ‘state’ now, specifically mutable variables or references. Let’s specify an API for working with references:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">newVar   ::</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">MutVar</span> s a)
<span class="ot">readVar  ::</span> <span class="dt">MutVar</span> s a <span class="ot">-&gt;</span> <span class="dt">ST</span> s a
<span class="ot">writeVar ::</span> <span class="dt">MutVar</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</code></pre></div>
<p>In other words, <code>newVar</code> takes a value of type <code>a</code> and returns a state transformer that can be supplied a state to output a new state containing a fresh reference to the provided value. <code>readVar</code> is a state transformer which leaves the provided state unchanged but extracts the value in the reference from it. <code>writeVar</code> takes a reference and a new value and returns a state transformer that updates the reference to point to the new value. The fact that the return value is <code>()</code> indicates that this state transformer is only useful for its effect on the state.</p>
<p>To compose these state transformers together we can define a <code>thenST</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">thenST ::</span> <span class="dt">ST</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">ST</span> s b) <span class="ot">-&gt;</span> <span class="dt">ST</span> s b</code></pre></div>
<!-- picture of thenST -->
<p>Two things to note here: both <code>s1</code> and <code>s2</code> have to work with the same state type <code>s</code>, and they way they work is inherently sequential, because the output of <code>s1</code> is the input of <code>s2</code>. This is where ‘thread’ in the title comes from. I like to think of this as the baton in a relay: you can’t run when you’re not holding the baton, and you can’t use a different team’s baton because that’s against the rules.</p>
<p>While we let that sink in, I’d like to make a brief historical digression. At this stage in Haskell’s history, monads had been identified as a useful abstraction and a predecessor to this paper had proposed a particular syntax for working with them, but do-notation had not yet made its way into the language. If you’re not familiar with monads, you can think of them as an interface for a type defined by two functions, <code>return</code> and <code>&gt;&gt;=</code> (pronounced ‘bind’) and certain laws that these functions must obey:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">    (&gt;&gt;=)  ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre></div>
<p>The actual definition differs slightly in ways that aren’t relevant here. Why do I bring this up? If you look closely, we’ve encountered functions that look very similar to the two above. If we textually replace <code>m</code> with <code>ST s</code>, we get</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return<span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s a
<span class="ot">(&gt;&gt;=)  ::</span> <span class="dt">ST</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">ST</span> s b) <span class="ot">-&gt;</span> <span class="dt">ST</span> s b</code></pre></div>
<p>which are exactly the type signatures of <code>returnST</code> and <code>thenST</code>. This isn’t a coincidence. I will also claim (but not prove) that these definitions are law-abiding.</p>
<p>What can we do with this information? Let’s take this code snippet that swaps the contents of two references:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">swap ::</span> <span class="dt">MutVar</span> s a <span class="ot">-&gt;</span> <span class="dt">MutVar</span> s a <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()
swap v w <span class="fu">=</span> readVar v    <span class="ot">`thenST`</span> (\a <span class="ot">-&gt;</span>
           readVar w    <span class="ot">`thenST`</span> (\b <span class="ot">-&gt;</span>
           writeVar v b <span class="ot">`thenST`</span> (\_ <span class="ot">-&gt;</span>
           writeVar w a)))</code></pre></div>
<p>This requires working with infix backticks and lambdas and looks pretty ugly, but we can do better! We have do-notation which is syntax sugar that converts</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> x <span class="ot">&lt;-</span> f
   y</code></pre></div>
<p>into</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> y)</code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> x
   y</code></pre></div>
<p>into</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="fu">&gt;&gt;</span> y</code></pre></div>
<p>where <code>&gt;&gt;</code> is like <code>&gt;&gt;=</code> that ignores the output of the left hand side:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b
(<span class="fu">&gt;&gt;</span>) ma mb <span class="fu">=</span> ma <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> mb)</code></pre></div>
<p>Armed with this knowledge, we can rewrite the above example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">swap ::</span> <span class="dt">MutVar</span> s a <span class="ot">-&gt;</span> <span class="dt">MutVar</span> s a <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()
swap v w <span class="fu">=</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> readVar v
    b <span class="ot">&lt;-</span> readVar w
    writeVar v b
    writeVar w a</code></pre></div>
<p>Much better! We even define <code>(&gt;&gt;)</code> directly as <code>thenST_</code>. The rest of the code samples in this post will use do-notation.</p>
<p>The authors also mention the existence of <code>fixST</code>, but this isn’t discussed elsewhere in the paper so I’ll skip that.</p>
<p>We now move to the other main contribution of the paper, which is the matter of how to prevent state from leaking out of our state transformers. The naive approach would be to define a <code>runST</code> that would provide an initial state as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runST ::</span> <span class="dt">ST</span> s a <span class="ot">-&gt;</span> a</code></pre></div>
<p>But this would allow leakage as in the following example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> v <span class="fu">=</span> runST (newVar <span class="dt">True</span>)
<span class="kw">in</span>
runST (readVar v)</code></pre></div>
<p>and because Haskell is a lazy language, we cannot enforce an ordering on updates to the state. What we really want is for our <code>runST</code> to work <em>regardless of which initial state it was given</em>, and we can encode that in the type signature with rank-2 polymorphism as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runST ::</span> <span class="ot">∀</span>a<span class="fu">.</span> (<span class="ot">∀</span>s<span class="fu">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a</code></pre></div>
<p>We can read ∀ as ‘forall’ and this is rank-2 because <code>s</code> is scoped within the parentheses and we can’t move it outside without changing the meaning of the type signature. We can read this as ‘for any <code>a</code>, given a state transformer that would work with any <code>s</code>, provide it with some state and extract the <code>a</code>’. Our previous example no longer typechecks, because <code>v</code> does not have the type <code>∀s.ST s a</code>, and we can see that the typechecker enforces our requirement that the state cannot leak out of the state transformer, hence ensuring referential transparency. This definition still allows useful code such as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">MutVar</span> s a <span class="ot">-&gt;</span> <span class="dt">MutVar</span> s a
f v <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span>
    w <span class="ot">&lt;-</span> newVar v
    readVar w</code></pre></div>
<p>which works because <code>v</code> is never dereferenced.</p>
<p>We can generalise our references to consider an array of mutable references. An API for this could look like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">newArr    ::</span> <span class="dt">Ix</span> i <span class="ot">=&gt;</span> (i, i) <span class="ot">-&gt;</span> elt <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">MutArr</span> s i elt)
<span class="ot">readArr   ::</span> <span class="dt">Ix</span> i <span class="ot">=&gt;</span> <span class="dt">MutArr</span> s i elt <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> <span class="dt">ST</span> s elt
<span class="ot">writeArr  ::</span> <span class="dt">Ix</span> i <span class="ot">=&gt;</span> <span class="dt">MutArr</span> s i elt <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> elt <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()
<span class="ot">freezeArr ::</span> <span class="dt">Ix</span> i <span class="ot">=&gt;</span> <span class="dt">MutArr</span> s i elt <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Array</span> i elt)</code></pre></div>
<p>This is very similar to our API for references, but parametrised over the index type <code>i</code> and including a function <code>freezeArr</code> that looks up the current value of a mutable array in the state and returns an immutable copy of it.</p>
<p>With this API, we can define <code>accumArray</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">accumArray ::</span> <span class="dt">Ix</span> i <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (i, i) <span class="ot">-&gt;</span> [(i, b)] <span class="ot">-&gt;</span> <span class="dt">Array</span> i a</code></pre></div>
<p>This takes a function, an initial value, array bounds, and a list of indexed values, and does a left fold over each indexed value, putting the result at the associated index. This can be used to compute a histogram:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hist ::</span> <span class="dt">Ix</span> i <span class="ot">=&gt;</span> (i, i) <span class="ot">-&gt;</span> [i] <span class="ot">-&gt;</span> <span class="dt">Array</span> i <span class="dt">Int</span>
hist bnds is <span class="fu">=</span> accumArray (<span class="fu">+</span>) <span class="dv">0</span> bnds [(i, <span class="dv">1</span>) <span class="fu">|</span> i <span class="ot">&lt;-</span> is, inRange bnds i]</code></pre></div>
<p>that counts occurrences of elements in <code>is</code> within the bounds provided or <code>binSort</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">binSort ::</span> <span class="dt">Ix</span> i <span class="ot">=&gt;</span> (i,i) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> i) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Array</span> i a
binSort bnds key vs <span class="fu">=</span> accumArray (flip (<span class="fu">:</span>)) [] bnds [(key v, v) <span class="fu">|</span> v <span class="ot">&lt;-</span> vs]</code></pre></div>
<p>that puts each element of <code>vs</code> into a bin based on its <code>key</code>. <code>accumArray</code> can be defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">accumArray f z bnds ivs <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> newArr bnds z
    fill a f ivs
    freezeArr a

fill a f []          <span class="fu">=</span> return ()
fill a f ((i,v)<span class="fu">:</span>ivs) <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> readArr a i
    writeArr a i (f x v)
    fill a f ivs</code></pre></div>
<p>This is a good example of a function that is internally imperative but externally pure.</p>
<p>If we define a function to sequence state transformers:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">seqST ::</span> [<span class="dt">ST</span> s ()] <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()
seqST <span class="fu">=</span> sequence_ <span class="co">-- originally defined as `foldr (&gt;&gt;) (return ())`</span></code></pre></div>
<p>then we can rewrite <code>accumArray</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">accumArray f z bnds ivs <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span>
    a <span class="ot">&lt;-</span> newArr bnds z
    seqST (map (update a f) ivs)
    freezeArr s

update a f (i, v) <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> readArr a i
    writeArr a i (f x v)</code></pre></div>
<p>Let’s reformulate IO in terms of state transformers. It can be thought of as a state transformer of type <code>ST RealWorld a</code>, where <code>RealWorld</code> is an abstract type representing the real world. We can make this explicit as a type synonym:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">IO</span> a <span class="fu">=</span> <span class="dt">ST</span> <span class="dt">RealWorld</span> a</code></pre></div>
<p>We also have a few functions that are specific to IO but not other ST computations, e.g.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">putChar<span class="ot"> ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
getChar<span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">Char</span></code></pre></div>
<p>And this is enough to build e.g. <code>putString</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">putString cs <span class="fu">=</span> seqST (map putChar cs)</code></pre></div>
<p>However, we can take it further and define both <code>putChar</code> and <code>getChar</code> in terms of <code>ccall</code>, which is a language construct that allows the programmer to call any C procedure (with certain restrictions placed on its use):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">putChar c <span class="fu">=</span> <span class="kw">do</span>
    ccall putChar c
    return ()
getChar <span class="fu">=</span> ccall getChar</code></pre></div>
<p>Because <code>IO</code> is not polymorphic in its state, it can’t be used with <code>runST</code>. This is the behaviour we want, and we need to define a special function to execute <code>IO</code> actions. We can call this <code>mainIO</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mainIO ::</span> <span class="dt">IO</span> ()</code></pre></div>
<p>and have it play a role similar to <code>main()</code> in C. In fact, IO in GHC is implemented in Haskell in precisely this manner.</p>
<p>There follows a section with formal semantics which formalises what we’ve seen already and outlines a proof of safety. I won’t go into more detail than that.</p>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = 'https://vaibhavsagar.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
]]></summary>
</entry>
<entry>
    <title>An All-in-One DAG Toolkit</title>
    <link href="http://vaibhavsagar.com/blog/2017/06/10/dag-toolkit/index.html" />
    <id>http://vaibhavsagar.com/blog/2017/06/10/dag-toolkit/index.html</id>
    <published>2017-06-10T00:00:00Z</published>
    <updated>2017-06-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 10 June 2017
    
</div>
<div class="info">
    
        Tags: <a href="/tags/programming.html">programming</a>
    
</div>

<p>I’d like to tell you about an algorithm that I’m frankly annoyed I didn’t discover earlier.</p>
<p>The algorithm is <a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Tarjan’s Strongly Connected Components</a> (or SCCs) algorithm, and as the name suggests, it decomposes a directed graph into its strongly connected components. A <a href="https://en.wikipedia.org/wiki/Directed_graph">directed graph</a> is one where the edges have a direction associated with them, and a <a href="https://en.wikipedia.org/wiki/Strongly_connected_component">strongly connected component</a> of a graph is a subgraph where each node can be reached from every other node, i.e. there’s a directed cycle somewhere in this subgraph.</p>
<style>
img[src*='#center'] {
    display: block;
    margin: auto;
}
p.caption {
    text-align: center;
    font-size: 80%;
}
</style>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/5/5c/Scc.png#center" alt="Strongly Connected Components" />
<p class="caption">Strongly Connected Components</p>
</div>
<p>So why does this matter? I don’t recall ever having the desire to deeply know the SCCs of a particular graph.</p>
<p>Let’s look at a different problem. Given a directed graph, how do we know if it is acyclic? The context here is that I was wondering how difficult it would be literally draw a Git commit history as a graph and render that to a repo. Git commits form a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a> (DAG), which is a directed graph without cycles, and I wanted to validate a user-drawn graph as well as process it.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/f/fe/Tred-G.svg#center" alt="Directed Acyclic Graph" />
<p class="caption">Directed Acyclic Graph</p>
</div>
<p>Consulting <a href="https://stackoverflow.com/questions/583876/how-do-i-check-if-a-directed-graph-is-acyclic">the oracle</a> yielded the concept of a <a href="https://en.wikipedia.org/wiki/Topological_sorting">topological sort</a>, which is where vertices are ordered such that for all vertices <em>u</em> and <em>v</em>, if there is an edge from <em>u</em> to <em>v</em>, <em>u</em> appears earlier than <em>v</em> in the sorted output. The directed edges for a Git commit graph are in the opposite direction from what we want though, because they point from children to parents. What we really want is a reverse topological sort. It would also be nice if I could somehow highlight the subgraphs of an invalid graph that are responsible for it being invalid.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/c/c6/Topological_Ordering.svg#center" alt="Topological Sort" />
<p class="caption">Topological Sort</p>
</div>
<p>This is where we come back to the SCCs of a graph. If there are any SCCs of more than one vertex, the graph is not a DAG and those SCCs are the cause of this. Collapsing the SCCs of a directed graph to a single vertex always leads to a DAG and this is known as the condensation of a directed graph, which I think is a nice way to visualise the relationship between SCCs and DAGs.</p>
<div class="figure">
<img src="https://upload.wikimedia.org/wikipedia/commons/2/20/Graph_Condensation.svg#center" alt="Condensation" />
<p class="caption">Condensation</p>
</div>
<p>Alright, so we do actually want to know the SCCs of this graph, but first we want to try to sort it topologically and reverse that order if that is possible, otherwise we calculate the SCCs and identify the offending ones. This seems a bit messy for graph properties that seem somewhat related. How cool would it be if there were an algorithm that could calculate the SCCs and a reverse topological sort for us <em>at the same time</em>?</p>
<p>It turns out that Tarjan’s SCCs algorithm does exactly that! You’d think that its performance might not be great because it does two things at once, but it is linear in the number of edges and vertices, and has better constant factors than <a href="https://en.wikipedia.org/wiki/Kosaraju&#39;s_algorithm">Kosaraju’s algorithm</a>, which only computes SCCs. Here it is as pseudocode:</p>
<div class="sourceCode"><pre class="sourceCode noweb"><code class="sourceCode noweb"> algorithm tarjan is
  input: graph G = (V, E)
  output: set of strongly connected components (sets of vertices)

  index := 0
  S := empty array
  for each v in V do
    if (v.index is undefined) then
      strongconnect(v)
    end if
  end for

  function strongconnect(v)
    // Set the depth index for v to the smallest unused index
    v.index := index
    v.lowlink := index
    index := index + 1
    S.push(v)
    v.onStack := true

    // Consider successors of v
    for each (v, w) in E do
      if (w.index is undefined) then
        // Successor w has not yet been visited; recurse on it
        strongconnect(w)
        v.lowlink  := min(v.lowlink, w.lowlink)
      else if (w.onStack) then
        // Successor w is in stack S and hence in the current SCC
        // Note: The next line may look odd - but is correct.
        // It says w.index not w.lowlink; that is deliberate and from the original paper
        v.lowlink  := min(v.lowlink, w.index)
      end if
    end for

    // If v is a root node, pop the stack and generate an SCC
    if (v.lowlink = v.index) then
      start a new strongly connected component
      repeat
        w := S.pop()
        w.onStack := false
        add w to current strongly connected component
      while (w != v)
      output the current strongly connected component
    end if
  end function</code></pre></div>
<p>The algorithm does a depth-first search, keeping track of two properties for each vertex: when it was encountered (the <em>index</em>) and the lowest index of any vertex reachable from this vertex (the <em>lowlink</em>). It pushes vertices on to a stack as it goes and outputs a strongly connected component when it cannot find any vertices it has not seen before.</p>
<p>As presented it is very imperative and I like Haskell, but fortunately <a href="/blog/2017/05/29/imperative-haskell/">imperative Haskell</a> is pretty straightforward and I have an implementation <a href="https://github.com/vaibhavsagar/courses/blob/master/algorithms1/week4/SCC.ipynb">here</a>.</p>
<p>This seems like an incredibly niche use case, but validating and processing DAGs in this way happens surprisingly frequently. Consider a build process where inputs and outputs are nodes and their relationships are directed edges. The presence of an SCC with more than one vertex indicates a cyclic dependency, and dependencies need to be built before the nodes that they depend on, which implies a reverse topological sort. This generalises to dataflow programming, where loops need to be identified (and usually eliminated). I like to think of this algorithm as an all-in-one DAG toolkit.</p>
<p>We can also use it to solve <a href="https://en.wikipedia.org/wiki/2-satisfiability">2SAT</a>, which is the problem of determining whether boolean variables in series of constraints of the form <code>a || b</code> can be assigned T and F values such that all constraints hold. This is discussed <a href="">here</a> but boils down to encoding the constraints as nodes and edges, calculating the SCCs, and processing the output in reverse topologically sorted order. An advantage to doing it this way is that the process can stop at the first SCC that indicates unsatisfiability. I have an implementation of this <a href="https://github.com/vaibhavsagar/courses/blob/master/algorithms2/week6/Week6.ipynb">here</a>.</p>
<p>Discovering this algorithm got me excited about theoretical computer science and reminded me that algorithms can be fun, interesting, and an opportunity to marvel at the music of the spheres. I’m curious to know what other equally awesome algorithms are out there. Which one’s your favourite?</p>
<p>Thanks to <a href="https://anniecherkaev.com/">Annie Cherkaev</a> for the title and feedback, and <a href="https://twitter.com/imccoy">Iain McCoy</a> for suggesting <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.45.3876">a more functional approach</a>.</p>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = 'https://vaibhavsagar.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
]]></summary>
</entry>
<entry>
    <title>Imperative Haskell</title>
    <link href="http://vaibhavsagar.com/blog/2017/05/29/imperative-haskell/index.html" />
    <id>http://vaibhavsagar.com/blog/2017/05/29/imperative-haskell/index.html</id>
    <published>2017-05-29T00:00:00Z</published>
    <updated>2017-05-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 29 May 2017
    
</div>
<div class="info">
    
        Tags: <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming.html">programming</a>
    
</div>

<p><em>This post covers essentially the same material as a 5-minute presentation I gave at <a href="https://www.recurse.com/scout/click?t=5ac465e5d3396a7e491e42afac4c5c90">RC</a>, because giving that talk over and over again doesn’t scale and there are things I would like to cover that are difficult within that time limit.</em></p>
<p>I was working through Tim Roughgarden’s <a href="https://www.coursera.org/learn/algorithm-design-analysis/">Algorithms 1</a> (which has now been replaced by two smaller courses) and attempting to do all the exercises in Haskell when I bumped up against an uncomfortable truth. Haskell’s ‘quicksort’:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">qsort []     <span class="fu">=</span> []
qsort (x<span class="fu">:</span>xs) <span class="fu">=</span> lt <span class="fu">++</span> [x] <span class="fu">++</span> gt
    <span class="kw">where</span> lt <span class="fu">=</span> qsort [e <span class="fu">|</span> e <span class="ot">&lt;-</span> xs, e <span class="fu">&lt;</span>  x]
          gt <span class="fu">=</span> qsort [e <span class="fu">|</span> e <span class="ot">&lt;-</span> xs, e <span class="fu">&gt;=</span> x]</code></pre></div>
<p>isn’t a true quicksort! Specifically, it doesn’t sort the elements in place, and the assignment I was working on involved counting the number of comparisons, so I couldn’t get away with my fake quicksort. With my tail between my legs, I gave up on my pure Haskell approach and implemented a solution in Python:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> sys
sys.setrecursionlimit(<span class="dv">10000</span>)

<span class="kw">def</span> partition_first(array, l, r):
    p <span class="op">=</span> array[l]
    i <span class="op">=</span> l <span class="op">+</span> <span class="dv">1</span>
    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(l<span class="op">+</span><span class="dv">1</span>, r):
        <span class="cf">if</span> array[j] <span class="op">&lt;</span> p:
            array[j], array[i] <span class="op">=</span> array[i], array[j]
            i <span class="op">+=</span> <span class="dv">1</span>
    array[l], array[i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> array[i<span class="op">-</span><span class="dv">1</span>], array[l]
    <span class="cf">return</span> (i<span class="op">-</span><span class="dv">1</span>)

<span class="kw">def</span> partition_last(array, l, r):
    array[r<span class="op">-</span><span class="dv">1</span>], array[l] <span class="op">=</span> array[l], array[r<span class="op">-</span><span class="dv">1</span>]
    <span class="cf">return</span> partition_first(array, l, r)

<span class="kw">def</span> partition_median(array, l, r):
    p_idx <span class="op">=</span> choose_median(array, l, r)
    array[p_idx], array[l] <span class="op">=</span> array[l], array[p_idx]
    <span class="cf">return</span> partition_first(array, l, r)

<span class="kw">def</span> choose_median(array, l, r):
    head <span class="op">=</span> array[l]
    last <span class="op">=</span> array[r<span class="op">-</span><span class="dv">1</span>]
    length <span class="op">=</span> r<span class="op">-</span>l
    <span class="cf">if</span> length <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>:
        mid_idx <span class="op">=</span> l <span class="op">+</span> (length<span class="op">//</span><span class="dv">2</span>) <span class="op">-</span> <span class="dv">1</span>
    <span class="cf">else</span>:
        mid_idx <span class="op">=</span> l <span class="op">+</span> (length<span class="op">//</span><span class="dv">2</span>)
    mid <span class="op">=</span> array[mid_idx]
    options <span class="op">=</span> [(l, head), (mid_idx, mid), (r<span class="op">-</span><span class="dv">1</span>, last)]
    options.remove(<span class="bu">max</span>(options, key<span class="op">=</span><span class="kw">lambda</span> v: v[<span class="dv">1</span>]))
    options.remove(<span class="bu">min</span>(options, key<span class="op">=</span><span class="kw">lambda</span> v: v[<span class="dv">1</span>]))
    <span class="cf">return</span> options[<span class="dv">0</span>][<span class="dv">0</span>]

<span class="kw">def</span> quicksort(array, start, end, partition):
    <span class="kw">global</span> comparisons
    <span class="cf">if</span> end<span class="op">&lt;=</span>start: <span class="cf">return</span>
    <span class="cf">else</span>:
        p_idx <span class="op">=</span> partition(array, start, end)
        comparisons <span class="op">+=</span> (end<span class="op">-</span>start<span class="op">-</span><span class="dv">1</span>)
        quicksort(array, start, p_idx, partition)
        quicksort(array, p_idx<span class="op">+</span><span class="dv">1</span>, end, partition)


comparisons <span class="op">=</span> <span class="dv">0</span>
inp1 <span class="op">=</span> contents.copy()
quicksort(inp1, <span class="dv">0</span>, <span class="bu">len</span>(inp1), partition_first)
<span class="bu">print</span>(comparisons)

comparisons <span class="op">=</span> <span class="dv">0</span>
inp2 <span class="op">=</span> contents.copy()
quicksort(inp2, <span class="dv">0</span>, <span class="bu">len</span>(inp2), partition_last)
<span class="bu">print</span>(comparisons)

comparisons <span class="op">=</span> <span class="dv">0</span>
inp3 <span class="op">=</span> contents.copy()
quicksort(inp3, <span class="dv">0</span>, <span class="bu">len</span>(inp3), partition_median)
<span class="bu">print</span>(comparisons)</code></pre></div>
<p>This implementation is not particularly Pythonic: note the recursion limit and the use of a global variable. I actually forgot to reset the variable to 0 between iterations, which was fun to track down. But it works!</p>
<p>So far, so good. This isn’t something we’d be able to do in Haskell, right? And even if we could, the equivalent implementation would be so different as to be unrecognisable. At least this is what I thought until I took a closer look at <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad-ST.html">Control.Monad.ST</a> and <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-STRef.html">Data.STRef</a>.</p>
<p>One of my biggest gripes with Haskell is the quality of the documentation. <code>Control.Monad.ST</code> is introduced as</p>
<blockquote>
<p>This library provides support for strict state threads, as described in the PLDI ’94 paper by John Launchbury and Simon Peyton Jones <em>Lazy Functional State Threads</em>.</p>
</blockquote>
<p>and <code>Data.STRef</code> is introduced as</p>
<blockquote>
<p>Mutable references in the (strict) ST monad.</p>
</blockquote>
<p>I don’t want to read a paper to figure out how to use these libraries, and in fact I don’t have to! In recognition of this, I humbly present alternative descriptions for <code>Control.Monad.ST</code>:</p>
<blockquote>
<p>You asked for mutable state, here it is!</p>
</blockquote>
<p>and <code>Data.STRef</code>:</p>
<blockquote>
<p>Variables that you can actually vary!!!1!1!one!1eleventyone</p>
</blockquote>
<p>Code utilising these libraries can look very familiar to people used to imperative languages, e.g. past me. Here’s the above quicksort rewritten in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad.ST</span>
<span class="kw">import </span><span class="dt">Data.STRef</span>
<span class="kw">import </span><span class="dt">Data.Vector</span> (fromList, toList, freeze, thaw)
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, write, swap)
<span class="kw">import qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span> (<span class="dt">Vector</span>, length)
<span class="kw">import </span><span class="dt">Data.List</span> (sortOn)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (read)

vector <span class="fu">=</span> fromList contents

partitionFirst array l r <span class="fu">=</span> <span class="kw">do</span>
    p <span class="ot">&lt;-</span> read array l
    i <span class="ot">&lt;-</span> newSTRef (l<span class="fu">+</span><span class="dv">1</span>)
    forM_ [l<span class="fu">+</span><span class="dv">1</span><span class="fu">..</span>(r<span class="fu">-</span><span class="dv">1</span>)] <span class="fu">$</span> \j <span class="ot">-&gt;</span> <span class="kw">do</span>
        arrayJ <span class="ot">&lt;-</span> read array j
        i&#39;     <span class="ot">&lt;-</span> readSTRef i
        when (arrayJ <span class="fu">&lt;</span> p) <span class="fu">$</span> <span class="kw">do</span>
            swap array i&#39; j
            modifySTRef&#39; i (<span class="fu">+</span><span class="dv">1</span>)
    i&#39; <span class="ot">&lt;-</span> readSTRef i
    swap array (i&#39;<span class="fu">-</span><span class="dv">1</span>) l
    return (i&#39;<span class="fu">-</span><span class="dv">1</span>)

partitionLast array l r <span class="fu">=</span> <span class="kw">do</span>
    swap array (r<span class="fu">-</span><span class="dv">1</span>) l
    partitionFirst array l r

partitionMedian array l r <span class="fu">=</span> <span class="kw">do</span>
    p <span class="ot">&lt;-</span> chooseMedian array l r
    swap array p l
    partitionFirst array l r

chooseMedian array l r <span class="fu">=</span> <span class="kw">do</span>
    h <span class="ot">&lt;-</span> read array l
    t <span class="ot">&lt;-</span> read array (r<span class="fu">-</span><span class="dv">1</span>)
    <span class="kw">let</span> len <span class="fu">=</span> r<span class="fu">-</span>l
    <span class="kw">let</span> mid <span class="fu">=</span> <span class="kw">if</span> (len <span class="ot">`mod`</span> <span class="dv">2</span>) <span class="fu">==</span> <span class="dv">0</span>
        <span class="kw">then</span> l <span class="fu">+</span> (len <span class="ot">`div`</span> <span class="dv">2</span>) <span class="fu">-</span> <span class="dv">1</span>
        <span class="kw">else</span> l <span class="fu">+</span> (len <span class="ot">`div`</span> <span class="dv">2</span>)
    m <span class="ot">&lt;-</span> read array mid
    <span class="kw">let</span> options <span class="fu">=</span> sortOn snd [(l, h), (mid, m), (r<span class="fu">-</span><span class="dv">1</span>, t)]
    return (fst (options <span class="fu">!!</span> <span class="dv">1</span>))

quicksort array start end partition comparisons <span class="fu">=</span> when (start <span class="fu">&lt;</span> end) <span class="fu">$</span> <span class="kw">do</span>
    i <span class="ot">&lt;-</span> partition array start end
    modifySTRef&#39; comparisons (<span class="fu">+</span> (end<span class="fu">-</span>start<span class="fu">-</span><span class="dv">1</span>))
    quicksort array start i   partition comparisons
    quicksort array (i<span class="fu">+</span><span class="dv">1</span>) end partition comparisons

<span class="ot">quicksort&#39; ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> a <span class="ot">-&gt;</span> (forall s a<span class="fu">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">STVector</span> s a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span>
quicksort&#39; vector partition <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span>
    array  <span class="ot">&lt;-</span> thaw vector
    comps  <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span>
    quicksort array <span class="dv">0</span> (V.length vector) partition comps
    readSTRef comps

quicksort&#39; vector partitionFirst
quicksort&#39; vector partitionLast
quicksort&#39; vector partitionMedian</code></pre></div>
<p>This is roughly the same length as the Python implementation, and even improves on it in some ways: no recursion limit fiddling and no global variables.</p>
<p>If we can write Haskell that resembles Python, and Python is executable pseudocode, can we cut out the middleman and translate pseudocode directly to Haskell? Let’s take a look at another problem.</p>
<p>I needed to calculate the size of the strongly connected components of a graph for another assignment, and I decided to use Tarjan’s Strongly Connected Components algorithm. The pseudocode for that (as taken from Wikipedia) is:</p>
<div class="sourceCode"><pre class="sourceCode noweb"><code class="sourceCode noweb"> algorithm tarjan is
  input: graph G = (V, E)
  output: set of strongly connected components (sets of vertices)

  index := 0
  S := empty array
  for each v in V do
    if (v.index is undefined) then
      strongconnect(v)
    end if
  end for

  function strongconnect(v)
    // Set the depth index for v to the smallest unused index
    v.index := index
    v.lowlink := index
    index := index + 1
    S.push(v)
    v.onStack := true

    // Consider successors of v
    for each (v, w) in E do
      if (w.index is undefined) then
        // Successor w has not yet been visited; recurse on it
        strongconnect(w)
        v.lowlink  := min(v.lowlink, w.lowlink)
      else if (w.onStack) then
        // Successor w is in stack S and hence in the current SCC
        // Note: The next line may look odd - but is correct.
        // It says w.index not w.lowlink; that is deliberate and from the original paper
        v.lowlink  := min(v.lowlink, w.index)
      end if
    end for

    // If v is a root node, pop the stack and generate an SCC
    if (v.lowlink = v.index) then
      start a new strongly connected component
      repeat
        w := S.pop()
        w.onStack := false
        add w to current strongly connected component
      while (w != v)
      output the current strongly connected component
    end if
  end function</code></pre></div>
<p>and here’s what that looks like in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span>
<span class="kw">import </span><span class="dt">Control.Monad.ST</span>
<span class="kw">import </span><span class="dt">Data.STRef</span>

<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span>    <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import qualified</span> <span class="dt">Data.Set</span>           <span class="kw">as</span> <span class="dt">S</span>
<span class="kw">import qualified</span> <span class="dt">Data.IntMap.Strict</span> <span class="kw">as</span> <span class="dt">I</span>
<span class="kw">import qualified</span> <span class="dt">Data.Array</span>         <span class="kw">as</span> <span class="dt">A</span>

<span class="kw">import </span><span class="dt">Control.Monad</span> (forM_, when)
<span class="kw">import </span><span class="dt">Data.Maybe</span> (isNothing, fromJust)

tarjan graph <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span>
    index    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span>
    stack    <span class="ot">&lt;-</span> newSTRef []
    indices  <span class="ot">&lt;-</span> newSTRef I.empty
    lowlinks <span class="ot">&lt;-</span> newSTRef I.empty
    output   <span class="ot">&lt;-</span> newSTRef []

    forM_ (G.vertices graph) <span class="fu">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span>
        vIndex <span class="ot">&lt;-</span> I.lookup v <span class="fu">&lt;$&gt;</span> readSTRef indices
        when (isNothing vIndex) <span class="fu">$</span> strongConnect v graph index stack indices lowlinks output

    reverse <span class="fu">&lt;$&gt;</span> readSTRef output

strongConnect v graph index stack indices lowlinks output <span class="fu">=</span> <span class="kw">do</span>
    i <span class="ot">&lt;-</span> readSTRef index
    modifySTRef&#39; indices  (I.insert v i)
    modifySTRef&#39; lowlinks (I.insert v i)
    modifySTRef&#39; index (<span class="fu">+</span><span class="dv">1</span>)
    push stack v

    forM_ (graph <span class="fu">A.!</span> v) <span class="fu">$</span> \w <span class="ot">-&gt;</span> <span class="kw">do</span>
        wIndex <span class="ot">&lt;-</span> I.lookup w <span class="fu">&lt;$&gt;</span> readSTRef indices
        <span class="kw">if</span> isNothing wIndex
            <span class="kw">then</span> <span class="kw">do</span>
                strongConnect w graph index stack indices lowlinks output
                vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">.</span> I.lookup v <span class="fu">&lt;$&gt;</span> readSTRef lowlinks
                wLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">.</span> I.lookup w <span class="fu">&lt;$&gt;</span> readSTRef lowlinks
                modifySTRef&#39; lowlinks (I.insert v <span class="fu">$</span> min vLowLink wLowLink)
            <span class="kw">else</span> <span class="kw">do</span>
                wOnStack <span class="ot">&lt;-</span> elem w <span class="fu">&lt;$&gt;</span> readSTRef stack
                when wOnStack <span class="fu">$</span> <span class="kw">do</span>
                    vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">.</span> I.lookup v <span class="fu">&lt;$&gt;</span> readSTRef lowlinks
                    modifySTRef&#39; lowlinks (I.insert v <span class="fu">$</span> min vLowLink (fromJust wIndex))

    vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">.</span> I.lookup v <span class="fu">&lt;$&gt;</span> readSTRef lowlinks
    vIndex   <span class="ot">&lt;-</span> fromJust <span class="fu">.</span> I.lookup v <span class="fu">&lt;$&gt;</span> readSTRef indices
    when (vLowLink <span class="fu">==</span> vIndex) <span class="fu">$</span> <span class="kw">do</span>
        scc <span class="ot">&lt;-</span> addSCC v [] stack
        modifySTRef&#39; output (scc<span class="fu">:</span>)

addSCC v scc stack <span class="fu">=</span> <span class="kw">do</span>
    w <span class="ot">&lt;-</span> pop stack
    <span class="kw">let</span> scc&#39; <span class="fu">=</span> w<span class="fu">:</span>scc
    <span class="kw">if</span> w <span class="fu">==</span> v <span class="kw">then</span> return scc&#39; <span class="kw">else</span> addSCC v scc&#39; stack

push stack e <span class="fu">=</span> modifySTRef&#39; stack (e<span class="fu">:</span>)
pop  stack   <span class="fu">=</span> <span class="kw">do</span>
    e <span class="ot">&lt;-</span> head <span class="fu">&lt;$&gt;</span> readSTRef stack
    modifySTRef&#39; stack tail
    return e</code></pre></div>
<p>Aside from explicitly declaring our variables and passing them around, I think this looks pretty close.</p>
<p>How do we square this with Haskell’s reputation for purity and referential transparency? That’s the subject of <a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/state-lasc.pdf">the paper mentioned above</a> that you don’t have to read (but totally can if you want)! They figured out a way to provide a principled pure interface to mutable state by passing the references as arguments into each function that makes use of them and leveraging the type system to make sure any impurity is well contained. The correctness of this approach was <a href="http://iris-project.org/pdfs/2017-icfp-runST-submission.pdf">very recently verified</a>. If desired, we can replace any of the functions with purer and more idiomatic definitions without changing the output, and that satisfies the definition of referential transparency!</p>
<p>Why don’t we do this all the time, when Haskell is at least a serviceable imperative language? Because writing imperative programs is hard! They don’t compose as well, have less useful type signatures, and are harder to reason about. Getting away from those things is why we have Haskell to begin with! The real question should be: how can we avoid doing things this way as much as possible?</p>
<p>Before I discovered this part of Haskell, I had this perception of Haskell (and declarative programming more generally) as “imperative programming but less” from a practical perspective. I thought that although writing declarative code in Python was purely (heh) a matter of discipline, writing imperative code in Haskell required completely reconceptualising the algorithm. Thanks to <code>ST</code>, I now know that this not the case, which is a huge relief. If required, I can do a literal translation of the algorithm, and clean it up (or not) later. In fact Haskell is “imperative programming and more”, and that’s awesome!</p>
<p>Thanks to <a href="http://blog.podsnap.com/">Peter Fraenkel</a>, <a href="https://jvns.ca/">Julia Evans</a>, and <a href="http://msteigerwalt.com/">Michelle Steigerwalt</a> for feedback.</p>
<p><em>If you’d rather try to make sense of the <a href="https://github.com/vaibhavsagar/thursday-presentations/tree/master/imperative-haskell">set of disconnected files</a> that constitutes my slides for that presentation, you can do that instead, although I wouldn’t recommend it.</em></p>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = 'https://vaibhavsagar.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
]]></summary>
</entry>
<entry>
    <title>Discovering Continuations with Typed Holes</title>
    <link href="http://vaibhavsagar.com/blog/2017/05/22/discovering-continuations/index.html" />
    <id>http://vaibhavsagar.com/blog/2017/05/22/discovering-continuations/index.html</id>
    <published>2017-05-22T00:00:00Z</published>
    <updated>2017-05-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 22 May 2017
    
</div>
<div class="info">
    
        Tags: <a href="/tags/haskell.html">haskell</a>, <a href="/tags/programming.html">programming</a>, <a href="/tags/monads.html">monads</a>
    
</div>

<p>I’ve been trying to wrap my head around continuations for a while. I was reading <a href="https://github.com/quchen/articles/blob/master/cont_monad.md">David Luposchainsky’s excellent article</a> on them and playing with his definitions in an IHaskell notebook when I found that typed holes are an excellent hammer to attack this particular nail with.</p>
<p>If you haven’t encountered them before, <a href="https://wiki.haskell.org/GHC/Typed_holes">typed holes</a> are a feature where you put one or more variables starting with <code>_</code> on the right hand side of a definition to get GHC to tell you the type of the value that fits in that hole, and you can narrow the hole as necessary to get the type of a subexpression until you have enough information to complete the definition. I like to think of this as a way of collaboratively filling in a definition with the compiler, instead of my usual approach which is to write a definition, listen carefully to GHC’s complaints, and amend my definition accordingly. Typed holes are fully supported by GHCi and the full suite of editor integrations, but I personally find the edit/reload/squint cycle more tedious than coming up with the definition in IHaskell and then moving it to a module and adding type signatures after I’m satisfied that it works.</p>
<p>I think his type definition makes an excellent starting point:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="fu">=</span> <span class="dt">Cont</span> {<span class="ot"> (&gt;&gt;-) ::</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</code></pre></div>
<p>This defines a type <code>Cont</code> with an infix constructor <code>&gt;&gt;-</code> (that looks suspiciously similar to <code>&gt;&gt;=</code>) that takes a function from <code>a</code> to <code>r</code> and provides an <code>r</code>. One intuition for what this means is that a value of this type knows about an <code>a</code> but for whatever reason refuses to be upfront about it and demands to know what you’re going to do with it and then does it for you, providing you with a final result <code>r</code>. Another intuition is that this is a generalisation of callbacks: a value of this type expects a callback to utilise the <code>a</code>. Anyway, on to my favourite part of working with mysterious data types: defining <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> instances for them! If you’ve done this before, you’ll know that these typeclasses have certain laws that their instances are meant to obey, and it turns out that this type is polymorphic enough that we can just follow the typed holes and the resulting definitions will be lawful. You don’t have to take my word for it and should verify this for yourself, but I won’t be discussing the laws here. Let’s begin!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    fmap f cont <span class="fu">=</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:19: error:<br/>    • Found hole: _ :: Cont r b<br/>      Where: ‘r’ is a rigid type variable bound by the instance declaration at &lt;interactive&gt;:1:10<br/>             ‘b’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 fmap :: forall a b. (a -&gt; b) -&gt; Cont r a -&gt; Cont r b<br/>               at &lt;interactive&gt;:2:5<br/>    • In the expression: _<br/>      In an equation for ‘fmap’: fmap f cont = _<br/>      In the instance declaration for ‘Functor (Cont r)’<br/>    • Relevant bindings include<br/>        cont :: Cont r a (bound at &lt;interactive&gt;:2:12)<br/>        f :: a -&gt; b (bound at &lt;interactive&gt;:2:10)<br/>        fmap :: (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:2:5)</pre>
<p>We didn’t really need a typed hole to tell us this, but at least we know what we have to work with. We know we have to provide a <code>Cont</code> value, so let’s narrow our typed hole that way.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    fmap f cont <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:26: error:<br/>    • Found hole: _ :: (b -&gt; r) -&gt; r<br/>      Where: ‘r’ is a rigid type variable bound by the instance declaration at &lt;interactive&gt;:1:10<br/>             ‘b’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 fmap :: forall a b. (a -&gt; b) -&gt; Cont r a -&gt; Cont r b<br/>               at &lt;interactive&gt;:2:5<br/>    • In the second argument of ‘(<span>&dollar;</span>)’, namely ‘_’<br/>      In the expression: Cont <span>&dollar;</span> _<br/>      In an equation for ‘fmap’: fmap f cont = Cont <span>&dollar;</span> _<br/>    • Relevant bindings include<br/>        cont :: Cont r a (bound at &lt;interactive&gt;:2:12)<br/>        f :: a -&gt; b (bound at &lt;interactive&gt;:2:10)<br/>        fmap :: (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:2:5)</pre>
<p>The type of our hole is more helpful here. Now we know (if we were previously uncertain) that we somehow need to use <code>f</code> to turn the <code>a</code> into a <code>b</code>. We also know that <code>Cont</code> takes a parameter, let’s add that in and see if it helps.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    fmap f cont <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:32: error:<br/>    • Found hole: _ :: r<br/>      Where: ‘r’ is a rigid type variable bound by the instance declaration at &lt;interactive&gt;:1:10<br/>    • In the expression: _<br/>      In the second argument of ‘(<span>&dollar;</span>)’, namely ‘\ k -&gt; _’<br/>      In the expression: Cont <span>&dollar;</span> \ k -&gt; _<br/>    • Relevant bindings include<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:2:27)<br/>        cont :: Cont r a (bound at &lt;interactive&gt;:2:12)<br/>        f :: a -&gt; b (bound at &lt;interactive&gt;:2:10)<br/>        fmap :: (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:2:5)</pre>
<p>In general, we know all of our definitions will be of the form <code>Cont $ \k -&gt; _</code> and that’s a safe starting point. We now know that we need to use <code>k</code> on the result of applying <code>f</code> to some <code>a</code> to finally result in an <code>r</code>, but where does the <code>a</code> come from? The only thing we can do at this point is ‘unwrap’ the <code>cont</code> using <code>&gt;&gt;-</code>. What happens when we do that?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    fmap f cont <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> cont <span class="fu">&gt;&gt;-</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:41: error:<br/>    • Found hole: _ :: a -&gt; r<br/>      Where: ‘r’ is a rigid type variable bound by the instance declaration at &lt;interactive&gt;:1:10<br/>             ‘a’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 fmap :: forall a b. (a -&gt; b) -&gt; Cont r a -&gt; Cont r b<br/>               at &lt;interactive&gt;:2:5<br/>    • In the second argument of ‘&gt;&gt;-’, namely ‘_’<br/>      In the expression: cont &gt;&gt;- _<br/>      In the second argument of ‘(<span>&dollar;</span>)’, namely ‘\ k -&gt; cont &gt;&gt;- _’<br/>    • Relevant bindings include<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:2:27)<br/>        cont :: Cont r a (bound at &lt;interactive&gt;:2:12)<br/>        f :: a -&gt; b (bound at &lt;interactive&gt;:2:10)<br/>        fmap :: (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:2:5)</pre>
<p>It looks like we might have everything we need to complete this definition! We can create a function of type <code>a -&gt; r</code> by composing <code>k</code> and <code>f</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    fmap f cont <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> cont <span class="fu">&gt;&gt;-</span> (k <span class="fu">.</span> f)</code></pre></div>
<p>It worked! This definition states that <code>fmap</code> works by creating a continuation that expects a callback of the new type. This is pretty exciting! Let’s continue to <code>Applicative</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    pure a <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:27: error:<br/>    • Found hole: _ :: r<br/>      Where: ‘r’ is a rigid type variable bound by the instance declaration at &lt;interactive&gt;:1:10<br/>    • In the expression: _<br/>      In the second argument of ‘(<span>&dollar;</span>)’, namely ‘\ k -&gt; _’<br/>      In the expression: Cont <span>&dollar;</span> \ k -&gt; _<br/>    • Relevant bindings include<br/>        k :: a -&gt; r (bound at &lt;interactive&gt;:2:22)<br/>        a :: a (bound at &lt;interactive&gt;:2:10)<br/>        pure :: a -&gt; Cont r a (bound at &lt;interactive&gt;:2:5)</pre>
<p>That was pretty easy. We need an <code>r</code> and we have an <code>a</code> and a <code>k</code> that takes an <code>a</code> to an <code>r</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    pure a <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> k a</code></pre></div>
<p>This matches our intuition from above: creating a continuation involves hiding a value behind a function that can access it. On to <code>&lt;*&gt;</code>!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    pure a  <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> k a
    f <span class="fu">&lt;*&gt;</span> a <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:3:28: error:<br/>    • Found hole: _ :: r<br/>      Where: ‘r’ is a rigid type variable bound by the instance declaration at &lt;interactive&gt;:1:10<br/>    • In the expression: _<br/>      In the second argument of ‘(<span>&dollar;</span>)’, namely ‘\ k -&gt; _’<br/>      In the expression: Cont <span>&dollar;</span> \ k -&gt; _<br/>    • Relevant bindings include<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:3:23)<br/>        a :: Cont r a (bound at &lt;interactive&gt;:3:11)<br/>        f :: Cont r (a -&gt; b) (bound at &lt;interactive&gt;:3:5)<br/>        (&lt;*&gt;) :: Cont r (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:3:5)</pre>
<p>From above, we know we can ‘unwrap’ <code>Cont</code> values using <code>&gt;&gt;-</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    pure a  <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> k a
    f <span class="fu">&lt;*&gt;</span> a <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> f <span class="fu">&gt;&gt;-</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:3:34: error:<br/>    • Found hole: _ :: (a -&gt; b) -&gt; r<br/>      Where: ‘r’ is a rigid type variable bound by the instance declaration at &lt;interactive&gt;:1:10<br/>             ‘b’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 (&lt;*&gt;) :: forall a b. Cont r (a -&gt; b) -&gt; Cont r a -&gt; Cont r b<br/>               at &lt;interactive&gt;:3:7<br/>             ‘a’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 (&lt;*&gt;) :: forall a b. Cont r (a -&gt; b) -&gt; Cont r a -&gt; Cont r b<br/>               at &lt;interactive&gt;:3:7<br/>    • In the second argument of ‘&gt;&gt;-’, namely ‘_’<br/>      In the expression: f &gt;&gt;- _<br/>      In the second argument of ‘(<span>&dollar;</span>)’, namely ‘\ k -&gt; f &gt;&gt;- _’<br/>    • Relevant bindings include<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:3:23)<br/>        a :: Cont r a (bound at &lt;interactive&gt;:3:11)<br/>        f :: Cont r (a -&gt; b) (bound at &lt;interactive&gt;:3:5)<br/>        (&lt;*&gt;) :: Cont r (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:3:5)</pre>
<p>Let’s keep going.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    pure a  <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> k a
    f <span class="fu">&lt;*&gt;</span> a <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> f <span class="fu">&gt;&gt;-</span> \f&#39; <span class="ot">-&gt;</span> a <span class="fu">&gt;&gt;-</span> \a&#39; <span class="ot">-&gt;</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:3:54: error:<br/>    • Found hole: _ :: r<br/>      Where: ‘r’ is a rigid type variable bound by the instance declaration at &lt;interactive&gt;:1:10<br/>    • In the expression: _<br/>      In the second argument of ‘&gt;&gt;-’, namely ‘\ a' -&gt; _’<br/>      In the expression: a &gt;&gt;- \ a' -&gt; _<br/>    • Relevant bindings include<br/>        a' :: a (bound at &lt;interactive&gt;:3:48)<br/>        f' :: a -&gt; b (bound at &lt;interactive&gt;:3:35)<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:3:23)<br/>        a :: Cont r a (bound at &lt;interactive&gt;:3:11)<br/>        f :: Cont r (a -&gt; b) (bound at &lt;interactive&gt;:3:5)<br/>        (&lt;*&gt;) :: Cont r (a -&gt; b) -&gt; Cont r a -&gt; Cont r b (bound at &lt;interactive&gt;:3:5)</pre>
<p>Perfect, we want an <code>r</code> and we have</p>
<ul>
<li>an <code>a</code> (<code>a'</code>)</li>
<li>a function from <code>a</code> to <code>b</code> (<code>f'</code>)</li>
<li>a function from <code>b</code> to <code>r</code> (<code>k</code>)</li>
</ul>
<p>Let’s put them together.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    pure a  <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> k a
    f <span class="fu">&lt;*&gt;</span> a <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> f <span class="fu">&gt;&gt;-</span> \f&#39; <span class="ot">-&gt;</span> a <span class="fu">&gt;&gt;-</span> \a&#39; <span class="ot">-&gt;</span> k (f&#39; a&#39;)</code></pre></div>
<p>Okay, we unwrap the function and the argument and rewrap them in a fresh continuation, not too differently from how we defined <code>fmap</code>. Sweet! On to the big M!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:28: error:<br/>    • Found hole: _ :: r<br/>      Where: ‘r’ is a rigid type variable bound by the instance declaration at &lt;interactive&gt;:1:10<br/>    • In the expression: _<br/>      In the second argument of ‘(<span>&dollar;</span>)’, namely ‘\ k -&gt; _’<br/>      In the expression: Cont <span>&dollar;</span> \ k -&gt; _<br/>    • Relevant bindings include<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:2:23)<br/>        f :: a -&gt; Cont r b (bound at &lt;interactive&gt;:2:11)<br/>        a :: Cont r a (bound at &lt;interactive&gt;:2:5)<br/>        (&gt;&gt;=) :: Cont r a -&gt; (a -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:5)</pre>
<p>As before, our first order of business is to unwrap the <code>a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> a <span class="fu">&gt;&gt;-</span> \a&#39; <span class="ot">-&gt;</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:41: error:<br/>    • Found hole: _ :: r<br/>      Where: ‘r’ is a rigid type variable bound by the instance declaration at &lt;interactive&gt;:1:10<br/>    • In the expression: _<br/>      In the second argument of ‘&gt;&gt;-’, namely ‘\ a' -&gt; _’<br/>      In the expression: a &gt;&gt;- \ a' -&gt; _<br/>    • Relevant bindings include<br/>        a' :: a (bound at &lt;interactive&gt;:2:35)<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:2:23)<br/>        f :: a -&gt; Cont r b (bound at &lt;interactive&gt;:2:11)<br/>        a :: Cont r a (bound at &lt;interactive&gt;:2:5)<br/>        (&gt;&gt;=) :: Cont r a -&gt; (a -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:5)</pre>
<p>We can apply <code>f</code> to this unwrapped value to get a continuation that we can unwrap again.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> a <span class="fu">&gt;&gt;-</span> \a&#39; <span class="ot">-&gt;</span> f a&#39; <span class="fu">&gt;&gt;-</span> \f&#39; <span class="ot">-&gt;</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:57: error:<br/>    • Found hole: _ :: r<br/>      Where: ‘r’ is a rigid type variable bound by the instance declaration at &lt;interactive&gt;:1:10<br/>    • In the expression: _<br/>      In the second argument of ‘&gt;&gt;-’, namely ‘\ f' -&gt; _’<br/>      In the expression: f a' &gt;&gt;- \ f' -&gt; _<br/>    • Relevant bindings include<br/>        f' :: b (bound at &lt;interactive&gt;:2:51)<br/>        a' :: a (bound at &lt;interactive&gt;:2:35)<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:2:23)<br/>        f :: a -&gt; Cont r b (bound at &lt;interactive&gt;:2:11)<br/>        a :: Cont r a (bound at &lt;interactive&gt;:2:5)<br/>        (&gt;&gt;=) :: Cont r a -&gt; (a -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:5)</pre>
<p>We want an <code>r</code> and we have <code>k</code> and <code>f'</code>. Let’s put them together!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span>
    a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> a <span class="fu">&gt;&gt;-</span> \a&#39; <span class="ot">-&gt;</span> f a&#39; <span class="fu">&gt;&gt;-</span> \f&#39; <span class="ot">-&gt;</span> k f&#39;</code></pre></div>
<p>And that’s it! The <a href="http://blog.sigfpe.com/2008/12/mother-of-all-monads.html">mother of all monads</a> boils down to some tedious and almost mechanical wrapping and unwrapping. I think it’s cool how mundane it is.</p>
<p>Let’s have a crack at something more involved. A lot of the magic in continuations is accessed via <code>callCC</code>, which takes a function and calls it with the current continuation, hence the name. How would we define it?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b
callCC f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> _</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:25: error:<br/>    • Found hole: _ :: r<br/>      Where: ‘r’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b<br/>               at &lt;interactive&gt;:1:11<br/>    • In the expression: _<br/>      In the second argument of ‘(<span>&dollar;</span>)’, namely ‘\ k -&gt; _’<br/>      In the expression: Cont <span>&dollar;</span> \ k -&gt; _<br/>    • Relevant bindings include<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:2:20)<br/>        f :: (b -&gt; Cont r a) -&gt; Cont r b (bound at &lt;interactive&gt;:2:8)<br/>        callCC :: ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:1)</pre>
<p>Our definition involves <code>b</code>, but the only <code>b</code> we have available is wrapped up in <code>f</code>. We need to provide an argument of a certain type to <code>f</code>, and then unwrap the result of that? Time to bring out the big guns: multiple typed holes!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b
callCC f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> f _1 <span class="fu">&gt;&gt;-</span> _2</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:27: error:<br/>    • Found hole: _1 :: b -&gt; Cont r a<br/>      Where: ‘r’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b<br/>               at &lt;interactive&gt;:1:11<br/>             ‘a’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b<br/>               at &lt;interactive&gt;:1:11<br/>             ‘b’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b<br/>               at &lt;interactive&gt;:1:11<br/>      Or perhaps ‘_1’ is mis-spelled, or not in scope<br/>    • In the first argument of ‘f’, namely ‘_1’<br/>      In the first argument of ‘&gt;&gt;-’, namely ‘f _1’<br/>      In the expression: f _1 &gt;&gt;- _2<br/>    • Relevant bindings include<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:2:20)<br/>        f :: (b -&gt; Cont r a) -&gt; Cont r b (bound at &lt;interactive&gt;:2:8)<br/>        callCC :: ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:1)<br/>&lt;interactive&gt;:2:34: error:<br/>    • Found hole: _2 :: b -&gt; r<br/>      Where: ‘r’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b<br/>               at &lt;interactive&gt;:1:11<br/>             ‘b’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b<br/>               at &lt;interactive&gt;:1:11<br/>      Or perhaps ‘_2’ is mis-spelled, or not in scope<br/>    • In the second argument of ‘&gt;&gt;-’, namely ‘_2’<br/>      In the expression: f _1 &gt;&gt;- _2<br/>      In the second argument of ‘(<span>&dollar;</span>)’, namely ‘\ k -&gt; f _1 &gt;&gt;- _2’<br/>    • Relevant bindings include<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:2:20)<br/>        f :: (b -&gt; Cont r a) -&gt; Cont r b (bound at &lt;interactive&gt;:2:8)<br/>        callCC :: ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:1)</pre>
<p>Great, <code>k</code> fits perfectly into the second hole. That was easy.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b
callCC f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> f _ <span class="fu">&gt;&gt;-</span> k</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:27: error:<br/>    • Found hole: _ :: b -&gt; Cont r a<br/>      Where: ‘r’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b<br/>               at &lt;interactive&gt;:1:11<br/>             ‘a’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b<br/>               at &lt;interactive&gt;:1:11<br/>             ‘b’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b<br/>               at &lt;interactive&gt;:1:11<br/>    • In the first argument of ‘f’, namely ‘_’<br/>      In the first argument of ‘&gt;&gt;-’, namely ‘f _’<br/>      In the expression: f _ &gt;&gt;- k<br/>    • Relevant bindings include<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:2:20)<br/>        f :: (b -&gt; Cont r a) -&gt; Cont r b (bound at &lt;interactive&gt;:2:8)<br/>        callCC :: ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:1)</pre>
<p>We’re being asked to provide a function that takes one argument and returns a continuation. Let’s fill in the boilerplate and see where that takes us.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b
callCC f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> f (\b <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="fu">$</span> \k&#39; <span class="ot">-&gt;</span> _) <span class="fu">&gt;&gt;-</span> k</code></pre></div>
<style>/* Styles used for the Hoogle display in the pager */
.hoogle-doc {
display: block;
padding-bottom: 1.3em;
padding-left: 0.4em;
}
.hoogle-code {
display: block;
font-family: monospace;
white-space: pre;
}
.hoogle-text {
display: block;
}
.hoogle-name {
color: green;
font-weight: bold;
}
.hoogle-head {
font-weight: bold;
}
.hoogle-sub {
display: block;
margin-left: 0.4em;
}
.hoogle-package {
font-weight: bold;
font-style: italic;
}
.hoogle-module {
font-weight: bold;
}
.hoogle-class {
font-weight: bold;
}
.get-type {
color: green;
font-weight: bold;
font-family: monospace;
display: block;
white-space: pre-wrap;
}
.show-type {
color: green;
font-weight: bold;
font-family: monospace;
margin-left: 1em;
}
.mono {
font-family: monospace;
display: block;
}
.err-msg {
color: red;
font-style: italic;
font-family: monospace;
white-space: pre;
display: block;
}
#unshowable {
color: red;
font-weight: bold;
}
.err-msg.in.collapse {
padding-top: 0.7em;
}
.highlight-code {
white-space: pre;
font-family: monospace;
}
.suggestion-warning { 
font-weight: bold;
color: rgb(200, 130, 0);
}
.suggestion-error { 
font-weight: bold;
color: red;
}
.suggestion-name {
font-weight: bold;
}
</style>
<pre class='err-msg'>&lt;interactive&gt;:2:48: error:<br/>    • Found hole: _ :: r<br/>      Where: ‘r’ is a rigid type variable bound by<br/>               the type signature for:<br/>                 callCC :: forall b r a. ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b<br/>               at &lt;interactive&gt;:1:11<br/>    • In the expression: _<br/>      In the second argument of ‘(<span>&dollar;</span>)’, namely ‘\ k' -&gt; _’<br/>      In the expression: Cont <span>&dollar;</span> \ k' -&gt; _<br/>    • Relevant bindings include<br/>        k' :: a -&gt; r (bound at &lt;interactive&gt;:2:42)<br/>        b :: b (bound at &lt;interactive&gt;:2:29)<br/>        k :: b -&gt; r (bound at &lt;interactive&gt;:2:20)<br/>        f :: (b -&gt; Cont r a) -&gt; Cont r b (bound at &lt;interactive&gt;:2:8)<br/>        callCC :: ((b -&gt; Cont r a) -&gt; Cont r b) -&gt; Cont r b (bound at &lt;interactive&gt;:2:1)</pre>
<p>And we’re done! We can get an <code>r</code> by applying <code>k</code> to <code>b</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b
callCC f <span class="fu">=</span> <span class="dt">Cont</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> f (\b <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="fu">$</span> \k&#39; <span class="ot">-&gt;</span> k b) <span class="fu">&gt;&gt;-</span> k</code></pre></div>
<p>A closer look at the definition reveals that <code>k'</code> is unused, and this function provides <code>f</code> with the option to exit early if desired, or continue as normal. There’s a good explanation of why and how this works at <a href="https://github.com/quchen/articles/blob/master/cont_monad.md#special-api-function-callcc">the aforementioned article</a>.</p>
<p>Still a bit wary? That’s fair. I like to poke at the definitions, <a href="https://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-Cont.html">read the source</a>, look at how Gabriel Gonzales <a href="http://www.haskellforall.com/2014/04/how-continuation-monad-works.html">explains it</a>, and have a cup of tea and think about life for a while. Whatever works for you!</p>
<p>If you looked at the source, you might have noticed something interesting: The definition for the ContT monad transformer is identical! Here it is below.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ContT</span> r m a <span class="fu">=</span> <span class="dt">ContT</span> {<span class="ot"> (&gt;&gt;-) ::</span> (a <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> m r }

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span>
    fmap f cont <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> cont <span class="fu">&gt;&gt;-</span> (k <span class="fu">.</span> f)

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span>
    pure a  <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> k a
    f <span class="fu">&lt;*&gt;</span> a <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> f <span class="fu">&gt;&gt;-</span> \f&#39; <span class="ot">-&gt;</span> a <span class="fu">&gt;&gt;-</span> \a&#39; <span class="ot">-&gt;</span> k (f&#39; a&#39;)

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ContT</span> r m) <span class="kw">where</span>
    a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> a <span class="fu">&gt;&gt;-</span> \a&#39; <span class="ot">-&gt;</span> f a&#39; <span class="fu">&gt;&gt;-</span> \f&#39; <span class="ot">-&gt;</span> k f&#39;
    
<span class="ot">callCC ::</span> ((b <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m a) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m b) <span class="ot">-&gt;</span> <span class="dt">ContT</span> r m b
callCC f <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> \k <span class="ot">-&gt;</span> f (\b <span class="ot">-&gt;</span> <span class="dt">ContT</span> <span class="fu">$</span> \k&#39; <span class="ot">-&gt;</span> k b) <span class="fu">&gt;&gt;-</span> k</code></pre></div>
<p>I love being able to interact with these definitions like this. This is really how I want to program, and I’d encourage you to try it! The notebook is <a href="https://github.com/vaibhavsagar/notebooks/blob/master/notebooks/Continuation.ipynb">here</a> for you to play with if you have IHaskell set up. IHaskell isn’t just useful for programming: I even used it to <a href="https://github.com/vaibhavsagar/notebooks/blob/master/notebooks/DiscoveringContinuationsWithTypedHoles.ipynb">write this blog post</a>!</p>
<p>I feel like I should end with something profound about continuations, but I’ll instead link you to <a href="http://teh.id.au/posts/2017/05/10/lambdajam-slides/index.html">this presentation by Tim Humphries</a> and once again nudge you to try typed holes the next time you’re in a Haskell bind (pun very much intended).</p>
<p>Thanks to Iain McCoy, <a href="https://jvns.ca/">Julia Evans</a>, and <a href="https://ivanthetricourne.github.io/">Carl Factora</a> for their feedback and suggestions on this post.</p>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = 'https://vaibhavsagar.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
]]></summary>
</entry>
<entry>
    <title>Getting to RC</title>
    <link href="http://vaibhavsagar.com/blog/2017/02/26/getting-to-rc/index.html" />
    <id>http://vaibhavsagar.com/blog/2017/02/26/getting-to-rc/index.html</id>
    <published>2017-02-26T00:00:00Z</published>
    <updated>2017-02-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 26 February 2017
    
</div>
<div class="info">
    
        Tags: <a href="/tags/misc.html">misc</a>, <a href="/tags/RC.html">RC</a>
    
</div>

<p>You wouldn’t know it from looking at my blog, but I attended a batch at the Recurse Center from August to early November last year, and it was the best experience of my life. Many Recursers write a return statement afterwards reflecting on their time there, and in the process of writing mine I realised I have a lot to say about my journey getting there in the first place. Other posts in this vein are <a href="http://blog.jfo.click/how-i-went-to-rc/">this one</a> by Jeff Fowler and <a href="http://haroldtreen.github.io/tech/recurse/2017/02/26/applying-twice-to-the-recurse-center/">this one</a> by Harold Treen.</p>
<p>At the end of 2013, I’d just completed by undergraduate degree and the CSIRO in Australia generously bent the rules for me by allowing me to do a student internship anyway. I was taking a quick break and browsing Reddit when I encountered a blog post about Hacker School. The details are in a server log somewhere, but I’m reasonably certain it was a Julia Evans post, and they’re tonally consistent on this subject so we’ll pretend it was <a href="https://jvns.ca/blog/2014/02/15/how-was-hacker-school/">this particular one</a>. I had <a href="https://www.youtube.com/watch?v=2p1dS9hoptU">an immediate and visceral reaction</a> to learning about this magical place, but because of my financial and visa situation at the time I put it in the back of my mind and mostly forgot about it.</p>
<p>Less than two years later, I became an Australian citizen. The citizenship process limits how much time you can spend overseas, but as far as I’m aware it’s open season after you get your passport sorted. I was discussing this with my mum when she asked me what I would do next with my life. Things were going pretty well for me at work and the Canberra spring was springing, so I was pretty content as I was, but she pushed for a better answer until I recalled RC. She encouraged me to apply, which for her meant nagging me every week until I submitted my application. Thanks Ma &lt;3.</p>
<p>I wasn’t accepted the first time. I was incredibly nervous and flustered during my interview, and I didn’t have a good idea of what I wanted to accomplish during my batch beyond vague ideas of learning all the Haskell. At one point my interviewer asked me how I would measure my progress, and I had no idea. I even thought I did okay and the rejection email stung when it arrived a few days later. However, I still believed that I was a good fit for RC. It helped that the <a href="https://www.recurse.com/faq">FAQ</a> states “It’s not uncommon […] to admit people who we had previously rejected”. I decided to reapply in a few months.</p>
<p>In the meantime, I realised I didn’t have to wait until RC to begin learning Haskell. I was a regular attendee of <a href="https://www.meetup.com/CanFPG/">CanFP</a> but still unsure of how to bridge the gap between learning about lenses and monads and writing real code that does things. I considered myself a pretty decent user of Git and people talk about how Git is functional, so I offered to give <a href="http://vaibhavsagar.com/git-it-going/">a presentation I had prepared before</a> a second time. The co-founder I spoke to didn’t like that idea, but he had been looking into how Git is implemented, and he said he’d love to hear a talk on Git internals in Haskell. I had my project.</p>
<p>A few months later, things had gone pear-shaped for me on the work front and we were heading into the Canberra winter. I left my job and reapplied to RC. In my mind the worst that could have happened had already happened, so I was much more relaxed. My interviewer this time had attended RC when they were like me at the end of 2013, and I think we were able to relate to each other better. I’d learned some Haskell by working on my Git thing, which I called <a href="https://github.com/vaibhavsagar/duffer/tree/4e4beb35f39d957ff1ccaf187dee3272deb58870">duffer</a> and I progressed to the pairing interview. The pairing interview was my first experience pair programming, and I think it went well, because I got an acceptance email this time.</p>
<p>Although I was applying in April, I applied to the batch starting in August because my mum’s 50th birthday was in July and attending that was non-negotiable. I was skeptical of my ability to line up a job starting in November and it didn’t make sense to hang out in Canberra with nothing to do, so I packed up my life and moved (and myself) back to Jakarta.</p>
<p>I’d given the <a href="https://github.com/vaibhavsagar/duffer/blob/7a312355ebeacc38f553c71afcd90b3941c0069c/presentation/presentation.md">presentation on duffer</a> but it turned out that Haskell and Git were both more interesting than I realised, and so I continued working on it.</p>
<p>Both my parents <a href="http://infotech.co.id/">work in IT</a> so their hope was that I would be able to help them with some projects they were working on until I left for my batch. Instead, what I ended up doing was showing up at work and ignoring them for the rest of the day in favour of my project. This was not the best idea for my relationship with my parents, but I definitely got a lot better at Haskell. Fortunately for me my parents are incredibly supportive :).</p>
<p>My mum celebrated her birthday in Bali, and I insisted on bringing my laptop so I could keep my Github commit streak going. This turned out to a good decision because that day the RC mailing list thread welcoming new batchlings was started. I ducked out of celebrations and spent a while agonising over the perfect introduction.</p>
<p>Two weeks later I was in New York.</p>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = 'https://vaibhavsagar.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
]]></summary>
</entry>
<entry>
    <title>A Simple Key-Value Store with Servant</title>
    <link href="http://vaibhavsagar.com/blog/2017/01/24/simple-kv-store/index.html" />
    <id>http://vaibhavsagar.com/blog/2017/01/24/simple-kv-store/index.html</id>
    <published>2017-01-24T00:00:00Z</published>
    <updated>2017-01-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 24 January 2017
    
</div>
<div class="info">
    
        Tags: <a href="/tags/programming.html">programming</a>, <a href="/tags/haskell.html">haskell</a>
    
</div>

<p>The <a href="http://haskell-servant.readthedocs.io/en/stable/tutorial/Server.html#nested-apis">meat of the Servant tutorial</a> starts with an imposing list of language extensions and imports and only gets more confusing from there. I don’t think this gives newbies (i.e. me) the best first impression of Servant. Let’s build the simplest possible key-value store with it instead.</p>
<p>We’re going to write this as a <code>stack</code> script so everything is in one file.</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#!/usr/bin/env stack</span></code></pre></div>
<p>Let’s import the modules we need.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">{- stack --resolver lts-7 --install-ghc runghc</span>
<span class="co">    --package aeson</span>
<span class="co">    --package servant-server</span>
<span class="co">    --package text</span>
<span class="co">    --package transformers</span>
<span class="co">    --package unordered-containers</span>
<span class="co">    --package warp</span>
<span class="co">    -}</span></code></pre></div>
<p>At minimum we need <code>servant-server</code> for Servant goodness and <code>warp</code> to actually run our web service. The plan is to create an <code>IORef</code> holding a <code>HashMap</code> and use that as our store, which is why we need <code>unordered-containers</code>. I’d like to store arbitrary JSON, therefore <code>aeson</code>, and I think our keys should be <code>Text</code>, because <code>aeson</code> and <code>Text</code> are great together. That leaves <code>transformers</code>, which we need because of <code>liftIO</code>.</p>
<p>It turns out that we only need two language extensions for this example.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span></code></pre></div>
<p>As far as I can tell, both these extensions are needed for Servant’s cute API specification EDSL. We’ll let you have this one, Servant.</p>
<p>Time for a (hopefully manageable) list of imports!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.IO.Class</span>   (liftIO)
<span class="kw">import </span><span class="dt">Data.Aeson</span>               (<span class="dt">Value</span>)
<span class="kw">import </span><span class="dt">Data.IORef</span>               (<span class="dt">IORef</span>, newIORef, readIORef, atomicModifyIORef&#39;)
<span class="kw">import </span><span class="dt">Data.HashMap.Strict</span>      (<span class="dt">HashMap</span>, lookup, insert, empty)
<span class="kw">import </span><span class="dt">Data.Text</span>                (<span class="dt">Text</span>)
<span class="kw">import </span><span class="dt">Network.Wai.Handler.Warp</span> (run)
<span class="kw">import </span><span class="dt">System.Environment</span>       (getArgs)
<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span>           (lookup)
<span class="kw">import </span><span class="dt">Servant</span></code></pre></div>
<p>All imports are explicit except <code>Servant</code>’s.</p>
<p>Speaking of the EDSL:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">API</span>
    <span class="fu">=</span>    <span class="st">&quot;get&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;key&quot;</span> <span class="dt">Text</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">&#39;[JSON] (Maybe Value)</span>
    <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;put&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;key&quot;</span> <span class="dt">Text</span>
        <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> <span class="ch">&#39;[JSON] Value     :&gt; Put &#39;</span>[<span class="dt">JSON</span>] <span class="dt">Text</span></code></pre></div>
<p>This API has two endpoints: a “/get/:key” endpoint that provides the value associated with a key if the key exists in our store, or a “put/:key” endpoint that allows us to associate some JSON with a key, returning the key used. How this fits together is still a bit magical to me, but <a href="http://kseo.github.io/posts/2017-01-20-how-servant%27s-type-safe-links-work.html">this blog post</a> provides the best explanation I’ve read so far. The section of the Servant tutorial <a href="http://haskell-servant.readthedocs.io/en/stable/tutorial/ApiType.html">on the API specification EDSL</a> is also quite good.</p>
<p>Let’s define a type synonym so we don’t have to keep writing <code>IORef (HashMap Text Value)</code> over and over again:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Store</span> <span class="fu">=</span> <span class="dt">IORef</span> (<span class="dt">HashMap</span> <span class="dt">Text</span> <span class="dt">Value</span>)</code></pre></div>
<p>Servant uses the same operator to define the type and the serving action:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">server ::</span> <span class="dt">Store</span> <span class="ot">-&gt;</span> <span class="dt">Server</span> <span class="dt">API</span>
server store <span class="fu">=</span> getValue store <span class="fu">:&lt;|&gt;</span> putValue store</code></pre></div>
<p>The order in which these actions are composed needs to match the order used in the API definition.</p>
<p>Next we define <code>getValue</code> and <code>putValue</code>. We need actions of type <code>Handler</code>, which is <code>ExceptT ServantErr IO</code>, so we <code>liftIO</code> as necessary:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getValue ::</span> <span class="dt">Store</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> (<span class="dt">Maybe</span> <span class="dt">Value</span>)
getValue store key <span class="fu">=</span> liftIO <span class="fu">$</span> lookup key <span class="fu">&lt;$&gt;</span> readIORef store

<span class="ot">putValue ::</span> <span class="dt">Store</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Text</span>
putValue store key value <span class="fu">=</span> liftIO <span class="fu">$</span> atomicModifyIORef&#39; store modify
    <span class="kw">where</span> modify kv <span class="fu">=</span> (insert key value kv, key)</code></pre></div>
<p>Almost there. We declare the API we want to serve:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">kvAPI ::</span> <span class="dt">Proxy</span> <span class="dt">API</span>
kvAPI <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>Once again, Kwang Yul Seo has <a href="http://kseo.github.io/posts/2017-01-15-data-proxy.html">a great blog post</a> on this.</p>
<p>Finally, we define our entry point:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
    port <span class="ot">&lt;-</span> read <span class="fu">.</span> head <span class="fu">&lt;$&gt;</span><span class="ot"> getArgs ::</span> <span class="dt">IO</span> <span class="dt">Int</span>
    run port <span class="fu">.</span> serve kvAPI <span class="fu">.</span> server <span class="fu">=&lt;&lt;</span> newIORef empty</code></pre></div>
<p>To recap: we define our API as a type, our handlers, and the type we want to serve, and then we plug it all together.</p>
<p>And we’re done! We can now <code>chmod +x KVStore.hs</code> (or whatever you called the file) and run it: <code>./KVStore.hs 8081</code>.</p>
<p>I hope this provides a better starting point for learning Servant. If desired, the full script is available <a href="https://gist.github.com/vaibhavsagar/694e0a823c5a4a5b52ddb4277b55ba1d">here</a>.</p>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = 'https://vaibhavsagar.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
]]></summary>
</entry>
<entry>
    <title>Monad Anti-tutorial</title>
    <link href="http://vaibhavsagar.com/blog/2016/10/12/monad-anti-tutorial/index.html" />
    <id>http://vaibhavsagar.com/blog/2016/10/12/monad-anti-tutorial/index.html</id>
    <published>2016-10-12T00:00:00Z</published>
    <updated>2016-10-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 12 October 2016
    
</div>
<div class="info">
    
        Tags: <a href="/tags/programming.html">programming</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/monads.html">monads</a>
    
</div>

<p>I think becoming familiar with the mechanics of working with monads is more important than the question of what a monad is. For this reason, I think monad tutorials solve the wrong problem. I’m giving you a monad anti-tutorial instead, where I don’t try to explain what a monad is but I do try to show you how to use them.</p>
<p>I’m assuming basic familiarity with Haskell’s syntax, but even if you’re not I hope you’ll still be able to follow this.</p>
<p>Let’s start with a definition. <code>Monad</code> in Haskell is a typeclass, which is very much like an interface in many other languages. Because Haskell is not object-oriented, it has types conform to typeclasses instead of objects conforming to interfaces, and each type can declare that it implements a particular typeclass by supplying definitions for each function that the typeclass specifies. <code>Monad</code> looks very much like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">    return ::</span> a   <span class="ot">-&gt;</span> m a
<span class="ot">    (&gt;&gt;=)  ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code></pre></div>
<p>This means that for any type <code>m</code>, if you provide two function definitions called <code>return</code> and <code>(&gt;&gt;=)</code> (pronounced ‘bind’) with the correct type signatures, you’ve made a <code>Monad</code> instance!</p>
<p>There are two things I think are confusing about this definition:</p>
<ol style="list-style-type: decimal">
<li><p><code>return</code> is a regular function whose meaning is unrelated to the <code>return</code> statement in most other programming languages.</p></li>
<li><p>Haskell allows you to define infix operators by surrounding them in parentheses, and this one looks a bit odd and vaguely threatening with its spiky edges.</p></li>
</ol>
<p>There are some laws that well-behaved implementations are supposed to observe:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return a <span class="fu">&gt;&gt;=</span> f           <span class="fu">=</span>  f a
m <span class="fu">&gt;&gt;=</span> return             <span class="fu">=</span>  m
m <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> f x <span class="fu">&gt;&gt;=</span> g)  <span class="fu">=</span>  (m <span class="fu">&gt;&gt;=</span> f) <span class="fu">&gt;&gt;=</span> g</code></pre></div>
<p>I include these because they’re an important part of what a <code>Monad</code> is. These laws aren’t enforced by the typeclass definition so it is possible to define unlawful instances. That’s a very bad idea though.</p>
<p>And that’s all. Really.</p>
<p>So what’s all the hype about?</p>
<p>One reason might be that Haskell has syntax sugar for this particular typeclass. This syntax sugar is known as <code>do</code>-notation, and it allows you to write code that looks like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo a b <span class="fu">=</span> <span class="kw">do</span>
    a&#39; <span class="ot">&lt;-</span> a
    b&#39; <span class="ot">&lt;-</span> b
    return (a&#39; <span class="fu">+</span> b&#39;)</code></pre></div>
<p>that then gets rewritten to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foo a b <span class="fu">=</span>
    a <span class="fu">&gt;&gt;=</span> \a&#39; <span class="ot">-&gt;</span>
    b <span class="fu">&gt;&gt;=</span> \b&#39; <span class="ot">-&gt;</span>
    return (a&#39; <span class="fu">+</span> b&#39;)</code></pre></div>
<p>If you want to define variables in between you can use</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">bar a b <span class="fu">=</span> <span class="kw">do</span>
    a&#39; <span class="ot">&lt;-</span> a
    <span class="kw">let</span> a&#39;&#39; <span class="fu">=</span> a&#39; <span class="fu">+</span> <span class="dv">1</span>
    b&#39; <span class="ot">&lt;-</span> b
    return (a&#39;&#39; <span class="fu">+</span> b&#39;)</code></pre></div>
<p>and this becomes</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">bar a b <span class="fu">=</span>
    a <span class="fu">&gt;&gt;=</span> \a&#39; <span class="ot">-&gt;</span>
    <span class="kw">let</span> a&#39;&#39; <span class="fu">=</span> a&#39; <span class="fu">+</span> <span class="dv">1</span> <span class="kw">in</span>
    b <span class="fu">&gt;&gt;=</span> \b&#39; <span class="ot">-&gt;</span>
    return (a&#39;&#39; <span class="fu">+</span> b)</code></pre></div>
<p>Sometimes you don’t care about the variable on the left hand side of the <code>&lt;-</code>, and you can omit it like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">baz a b <span class="fu">=</span> <span class="kw">do</span>
    a
    b&#39; <span class="ot">&lt;-</span> b
    return b&#39;</code></pre></div>
<p>which desugars to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">baz a b <span class="fu">=</span>
    a <span class="fu">&gt;&gt;=</span> \_  <span class="ot">-&gt;</span>
    b <span class="fu">&gt;&gt;=</span> \b&#39; <span class="ot">-&gt;</span>
    return b&#39;</code></pre></div>
<p>I’ll be using the above definitions in my examples, so if you find yourself wondering where <code>bar</code> came from a bit later, check back here.</p>
<p>I think it’s worth spending time on understanding <code>do</code> notation and converting between the sugared and desugared representations because:</p>
<ol style="list-style-type: decimal">
<li><p>Familiarity with <code>do</code> notation will allow you to effectively use monads, whether or not you feel you understand them.</p></li>
<li><p>Doing this will teach you (or at least help you learn) the monad laws.</p></li>
</ol>
<p>But enough about that. Let’s walk through some contrived examples to see how we can use the same typeclass (and the same functions) to do a bunch of very different things!</p>
<p>I’d like to start with the <code>Maybe</code> type, which allows us to work with possibly <code>null</code> values in a way I think is better than most other approaches. The implementation (or <code>instance</code>) of <code>Monad</code> looks like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span>
    return v         <span class="fu">=</span> <span class="dt">Just</span> v
    (<span class="fu">&gt;&gt;=</span>) <span class="dt">Nothing</span>  _ <span class="fu">=</span> <span class="dt">Nothing</span>
    (<span class="fu">&gt;&gt;=</span>) (<span class="dt">Just</span> v) f <span class="fu">=</span> f v</code></pre></div>
<p>and in use it looks like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> foo (<span class="dt">Just</span> <span class="dv">1</span>) (<span class="dt">Just</span> <span class="dv">2</span>)
<span class="dt">Just</span> <span class="dv">3</span>
λ<span class="fu">&gt;</span> foo <span class="dt">Nothing</span> (<span class="dt">Just</span> <span class="dv">2</span>)
<span class="dt">Nothing</span>
λ<span class="fu">&gt;</span> foo (<span class="dt">Just</span> <span class="dv">1</span>) <span class="dt">Nothing</span>
<span class="dt">Nothing</span>
λ<span class="fu">&gt;</span> bar (<span class="dt">Just</span> <span class="dv">1</span>) (<span class="dt">Just</span> <span class="dv">2</span>)
<span class="dt">Just</span> <span class="dv">4</span></code></pre></div>
<p>This captures the idea that if any of the parameters is <code>Nothing</code>, the overall result should also be <code>Nothing</code>. The cool part is that we don’t need to worry about this when defining <code>foo</code>, because the underlying implementation takes care of it for us.</p>
<p>In a language like Python, we don’t really have a way to abstract away the fact that an input can be possibly null, and we have to specifically account for this possibility. Similar code in Python would look like</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> foo(a, b):
   <span class="cf">if</span> a <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> b <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:
      <span class="cf">return</span> a <span class="op">+</span> b
   <span class="cf">else</span>:
      <span class="cf">return</span> <span class="va">None</span></code></pre></div>
<p>and this code would not work without modification for any of the following examples.</p>
<p>A second example is the <code>List</code> type. A valid instance looks like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span>
    return v   <span class="fu">=</span> [v]
    (<span class="fu">&gt;&gt;=</span>)  v f <span class="fu">=</span> concatMap f v</code></pre></div>
<p>and you would use this like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> foo [<span class="dv">1</span>, <span class="dv">2</span>] [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]
[<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]
λ<span class="fu">&gt;</span> foo [] [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]
[]
λ<span class="fu">&gt;</span> bar [<span class="dv">1</span>, <span class="dv">2</span>] [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]
[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]</code></pre></div>
<p>Where a <code>Maybe</code> can be one of two possible values, a <code>List</code> is an arbitrary number of values.</p>
<p>In Python this would be a list comprehension:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> foo(a, b):
   <span class="cf">return</span> [a_<span class="op">+</span>b_ <span class="cf">for</span> a_ <span class="kw">in</span> a <span class="cf">for</span> b_ <span class="kw">in</span> b]</code></pre></div>
<p>which, again, is too specific to work with any of the other examples.</p>
<p>The <code>Maybe</code> type could be thought of as a box containing either one or no elements, and similarly <code>List</code> may be thought of as a box containing an arbitrary number of elements. It may be tempting to think of all monads as boxes of some kind, but monads are more general than that. Let’s look at the <code>Reader</code> type, which allows us to <code>ask</code> for some value that can be passed in later (in some circles this is called dependency injection):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Reader</span> e a <span class="fu">=</span> <span class="dt">Reader</span> {<span class="ot">runReader ::</span> e <span class="ot">-&gt;</span> a}

ask <span class="fu">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> e)

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> e) <span class="kw">where</span>
   return a           <span class="fu">=</span> <span class="dt">Reader</span> (\_ <span class="ot">-&gt;</span> a)
   (<span class="fu">&gt;&gt;=</span>) (<span class="dt">Reader</span> r) f <span class="fu">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> runReader (f (r e)) e)</code></pre></div>
<p>I had to look this one up. I don’t expect you to immediately understand this implementation, my point is that this is bog-standard Haskell code. It’s a bit more interesting to use:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="fu">=</span> <span class="kw">do</span>
   value <span class="ot">&lt;-</span> ask
   return (value <span class="fu">+</span> <span class="dv">1</span>)

y <span class="fu">=</span> <span class="kw">do</span>
   value <span class="ot">&lt;-</span> ask
   return (value <span class="fu">+</span> <span class="dv">2</span>)

λ<span class="fu">&gt;</span> runReader (foo x y) <span class="dv">1</span>
<span class="dv">5</span>
λ<span class="fu">&gt;</span> runReader (foo x y) <span class="dv">2</span>
<span class="dv">7</span>
λ<span class="fu">&gt;</span> runReader (bar x y) <span class="dv">1</span>
<span class="dv">6</span></code></pre></div>
<p>I have no idea how you’d do this in Python, but I can guarantee it’s not general either.</p>
<p>Finally, let’s look at the <code>IO</code> type, which I find a bit scary. I don’t really understand how it’s implemented. so I’ll be skipping that section. Fortunately, we know how to use it, because we are familiar with the interface, so let’s go straight to that.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">getInt <span class="fu">=</span> <span class="kw">do</span>
   input <span class="ot">&lt;-</span> baz (putStr <span class="st">&quot;Enter integer: &quot;</span>) getLine
   <span class="kw">let</span> int <span class="fu">=</span> read<span class="ot"> input ::</span> <span class="dt">Int</span>
   return int

λ<span class="fu">&gt;</span> foo getInt getInt
<span class="dt">Enter</span> integer<span class="fu">:</span> <span class="dv">1</span>
<span class="dt">Enter</span> integer<span class="fu">:</span> <span class="dv">2</span>
<span class="dv">3</span>
λ<span class="fu">&gt;</span> bar getInt getInt
<span class="dt">Enter</span> integer<span class="fu">:</span> <span class="dv">1</span>
<span class="dt">Enter</span> integer<span class="fu">:</span> <span class="dv">2</span>
<span class="dv">4</span></code></pre></div>
<p>Okay, enough examples. As you can see, we’ve used the same interface to deal with failure, an arbitrary number of values, an extra parameter, and input/output. There are many useful monad instances in Haskell, from container types such as Set and Map to abstractions such as Writer and State, through to control flow as implemented by the Cont monad.</p>
<p>If you can make your type conform to the typeclass, Haskell will give you a pretty general and flexible API to work with it. Even if you don’t completely understand what’s going on with a certain type, you know enough to use it based on your knowledge of the interface. As far as I’m concerned, this is the point of monads in Haskell.</p>
<p>Thanks to <a href="http://jamesporter.me/">James Porter</a>, <a href="https://nick-platt.com/">Nick Platt</a>, and <a href="http://composition.al/">Lindsey Kuper</a> for their feedback on this post.</p>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = 'https://vaibhavsagar.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
]]></summary>
</entry>
<entry>
    <title>Data Is Code</title>
    <link href="http://vaibhavsagar.com/blog/2016/09/29/data-is-code/index.html" />
    <id>http://vaibhavsagar.com/blog/2016/09/29/data-is-code/index.html</id>
    <published>2016-09-29T00:00:00Z</published>
    <updated>2016-09-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 29 September 2016
    
</div>
<div class="info">
    
        Tags: <a href="/tags/programming.html">programming</a>
    
</div>

<blockquote>
<p>Code is just smart data, and data is just dumb code.</p>
<ul>
<li>Structure and Interpretation of Computer Programs</li>
</ul>
</blockquote>
<p>I’m going to try to convince you that data is code. Strap yourselves in!</p>
<p>A <a href="https://en.wikipedia.org/wiki/Cons">cons cell</a> is a way of representing a pair, and it has two operations, <a href="https://en.wikipedia.org/wiki/CAR_and_CDR"><code>car</code> and <code>cdr</code></a>, to access the first and second elements of the pair respectively. In Python, we could construct and access cons cells as follows:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">cons <span class="op">=</span> <span class="kw">lambda</span> a: <span class="kw">lambda</span> b: (a, b)
car  <span class="op">=</span> <span class="kw">lambda</span> cell: cell[<span class="dv">0</span>]
cdr  <span class="op">=</span> <span class="kw">lambda</span> cell: cell[<span class="dv">1</span>]</code></pre></div>
<p>Let’s create a pair and get the second element:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> p <span class="op">=</span> cons(<span class="dv">1</span>)(cons(<span class="dv">2</span>)(()))
<span class="op">&gt;&gt;&gt;</span> car(cdr(p))
<span class="dv">2</span></code></pre></div>
<p>It turns out that cons cells are all you need to implement singly linked lists. For example, lists in Lisp are implemented as a series of nested cons cells. A list is either empty (represented above by <code>()</code>) or a cons cell where the first element of the pair is the head of the list and the second element of the pair is the rest of the list. Using our above definitions in Python, the list <code>[0, 1, 2, 3]</code> would be represented as (0, (1, (2, (3, ())))). In code, this would be:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">cons(<span class="dv">0</span>)(cons(<span class="dv">1</span>)(cons(<span class="dv">2</span>)(cons(<span class="dv">3</span>)(()))))</code></pre></div>
<p>One way of visualising the above list is as follows:</p>
<pre><code>  cons
  / \
 0 cons
   / \
  1 cons
    / \
   2 cons
     / \
    3  ()</code></pre>
<p>Suppose we wanted to access the second element of this list. We could express this as the <code>car</code> of the <code>cdr</code> of this list. In code:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> example <span class="op">=</span> cons(<span class="dv">0</span>)(cons(<span class="dv">1</span>)(cons(<span class="dv">2</span>)(cons(<span class="dv">3</span>)(()))))
<span class="op">&gt;&gt;&gt;</span> car(cdr(example))
<span class="dv">1</span></code></pre></div>
<p>So far we’ve defined functions that wrap Python’s tuples, and we’re still in data land, working with those tuples. But it doesn’t have to be this way.</p>
<p>You may have noticed that my definitions above were all functions of one argument. This was not entirely coincidental: cons cells as described above are very similar to <a href="https://en.wikipedia.org/wiki/Church_encoding#Church_pairs">Church pairs</a>, which are a way of representing pairs in the lambda calculus. Let’s make a minor change to the above definitions:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">pair <span class="op">=</span> <span class="kw">lambda</span> a: <span class="kw">lambda</span> b: <span class="kw">lambda</span> f: f(a)(b)
fst  <span class="op">=</span> <span class="kw">lambda</span> p: p(<span class="kw">lambda</span> a: <span class="kw">lambda</span> b: a)
snd  <span class="op">=</span> <span class="kw">lambda</span> p: p(<span class="kw">lambda</span> a: <span class="kw">lambda</span> b: b)
nil  <span class="op">=</span> <span class="kw">lambda</span> a: a</code></pre></div>
<p>We can recreate the pair above:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> p <span class="op">=</span> pair(<span class="dv">1</span>)(pair(<span class="dv">2</span>)(nil))
<span class="op">&gt;&gt;&gt;</span> fst(snd(p))
<span class="dv">2</span></code></pre></div>
<p>Our pair <code>p</code> is now a function, but it is representing the same data as above.</p>
<p>As an aside, the functions we use in <code>fst</code> and <code>snd</code> are <a href="https://en.wikipedia.org/wiki/Church_encoding#Church_Booleans">Church booleans</a> that encode <code>true</code> and <code>false</code> in the lambda calculus. We can rewrite our definitions with this new knowledge:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">true  <span class="op">=</span> <span class="kw">lambda</span> a: <span class="kw">lambda</span> b: a
false <span class="op">=</span> <span class="kw">lambda</span> a: <span class="kw">lambda</span> b: b
fst   <span class="op">=</span> <span class="kw">lambda</span> p: p(true)
snd   <span class="op">=</span> <span class="kw">lambda</span> p: p(false)</code></pre></div>
<p>We can perform the same operations as before to get the second element of our list:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="op">&gt;&gt;&gt;</span> example <span class="op">=</span> pair(<span class="dv">0</span>)(pair(<span class="dv">1</span>)(pair(<span class="dv">2</span>)(pair(<span class="dv">3</span>)(nil))))
<span class="op">&gt;&gt;&gt;</span> fst(snd(example))
<span class="dv">1</span></code></pre></div>
<p>Now we’ve moved to function land, and there are no tuples in sight. All we need are functions of one argument, which is convenient because this is all that lambda calculus gives us. Fortunately, lambda calculus is <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a> and therefore enough.</p>
<p>Our code is represented as bits in memory i.e. data, but our data can be represented as functions i.e. code. You might say that bits and bytes are the lowest level representation and therefore somehow more fundamental than code, but even our data is just an undistinguished pattern of 1s and 0s without some code to make sense of it. It really is turtles all the way down.</p>
<p>There are much more comprehensive treatments of this material available online. I’m aware of <a href="http://matt.might.net/articles/js-church/">Matt Might’s</a> and <a href="http://jtauber.com/blog/2008/11/26/church_encoding_in_python/">James Tauber’s</a>.</p>
<p>Many thanks to <a href="http://www.notesfromandy.com/">Andy Lee</a>, <a href="http://juansoto.me/">Juan Soto</a>, and <a href="http://sranso.com/">Sarah Ransohoff</a> for their excellent feedback on on this post.</p>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = 'https://vaibhavsagar.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
]]></summary>
</entry>
<entry>
    <title>Using The Writer Monad Outside Logging</title>
    <link href="http://vaibhavsagar.com/blog/2016/07/24/writer-delta/index.html" />
    <id>http://vaibhavsagar.com/blog/2016/07/24/writer-delta/index.html</id>
    <published>2016-07-24T00:00:00Z</published>
    <updated>2016-07-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 24 July 2016
    
</div>
<div class="info">
    
        Tags: <a href="/tags/programming.html">programming</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/monads.html">monads</a>
    
</div>

<p>I hadn’t given much thought to the Writer monad before today, unlike the Reader and State monads, and part of the reason is that all the tutorials I encountered online focused on using it for logging. Although this is an obvious use case, I haven’t had to do much logging in Haskell so far and so I incorrectly assumed that I didn’t need to know about the Writer monad at all. However, I found a use for it outside logging and thought this might be worth sharing. This usage depends on two facts about Haskell:</p>
<ol style="list-style-type: decimal">
<li>The Writer monad’s output can be any Monoid, such as strings, lists, sets, etc.</li>
<li>ByteString is a Monoid.</li>
</ol>
<p>Git Packfiles store some entries as deltas against other entries. The delta format is a bit hairy to parse, but it consists of a sequence of either copy or insert instructions. Copy instructions specify an offset in the source and a length of bytes to copy, whereas insert instructions specify a series of bytes to be copied as is.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span>

<span class="kw">data</span> <span class="dt">DeltaInstruction</span>
    <span class="fu">=</span> <span class="dt">CopyInstruction</span>   <span class="dt">Int</span> <span class="dt">Int</span>
    <span class="fu">|</span> <span class="dt">InsertInstruction</span> <span class="dt">B.ByteString</span>
    <span class="kw">deriving</span> (<span class="dt">Show</span>)</code></pre></div>
<p>An instruction can be interpreted with reference to a source to result in a ByteString.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">substring ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span>
substring offset length bytestring <span class="fu">=</span> B.take length (B.drop offset bytestring)

<span class="co">-- Under this interpretation, `InsertInstruction` corresponds to `const`</span>
<span class="co">-- and `CopyInstruction` corresponds to `substring`.</span>
<span class="ot">interpretInstruction ::</span> <span class="dt">DeltaInstruction</span> <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span>
interpretInstruction instruction source <span class="fu">=</span> <span class="kw">case</span> instruction <span class="kw">of</span>
    <span class="dt">InsertInstruction</span> string        <span class="ot">-&gt;</span> string
    <span class="dt">CopyInstruction</span>   offset length <span class="ot">-&gt;</span> substring offset length source</code></pre></div>
<p>The concatenation of a list of interpreted instructions is a resolved delta.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">applyInstructions&#39; ::</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> [<span class="dt">DeltaInstruction</span>] <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span>
applyInstructions&#39; source dest []     <span class="fu">=</span> dest
applyInstructions&#39; source dest (i<span class="fu">:</span>is) <span class="fu">=</span> <span class="kw">let</span>
    dest&#39; <span class="fu">=</span> B.append dest <span class="fu">$</span> interpretInstruction i source
    <span class="kw">in</span> applyInstructions&#39; source dest&#39; is</code></pre></div>
<p>For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:</span>set <span class="fu">-</span><span class="dt">XOverloadedStrings</span>
testSource <span class="fu">=</span> <span class="st">&quot;tree 9977d7726a568347a513a6b061b87fd687322650\nparent e05bba28b796e7af7e5d981955327621a6c43a5f\nauthor Vaibhav Sagar &lt;EMAILADDRESS@gmail.com&gt; 1467760597 +0800\ncommitter Vaibhav Sagar &lt;EMAILADDRESS@gmail.com&gt; 1467781641 +0800\n\nUse record wildcards.\n&quot;</span><span class="ot"> ::</span> <span class="dt">B.ByteString</span>
testInstructions <span class="fu">=</span> [<span class="dt">InsertInstruction</span> <span class="st">&quot;tree d8dce7c53feb5fcaca4bef87106d3f9e4e50e6e&quot;</span>,<span class="dt">CopyInstruction</span> <span class="dv">44</span> <span class="dv">167</span>,<span class="dt">InsertInstruction</span> <span class="st">&quot;60597&quot;</span>,<span class="dt">CopyInstruction</span> <span class="dv">216</span> <span class="dv">30</span>]
applyInstructions&#39; testSource B.empty testInstructions</code></pre></div>
<pre><code>&quot;tree d8dce7c53feb5fcaca4bef87106d3f9e4e50e6e0\nparent e05bba28b796e7af7e5d981955327621a6c43a5f\nauthor Vaibhav Sagar &lt;EMAILADDRESS@gmail.com&gt; 1467760597 +0800\ncommitter Vaibhav Sagar &lt;EMAILADDRESS@gmail.com&gt; 1467760597 +0800\n\nUse record wildcards.\n&quot;</code></pre>
<p>Although this works, it isn’t particularly elegant and it would be nice to abstract away the details of the empty ByteString and the append. Luckily, these correspond to the <code>mempty</code> and <code>mappend</code> methods of a Monoid, and since the Writer monad works with monoids, we might be able to use it. Let’s start by defining a monadic action that appends an interpreted instruction and returns the source we fed it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Writer</span>

<span class="ot">applyInstruction ::</span> <span class="dt">DeltaInstruction</span> <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> <span class="dt">B.ByteString</span> <span class="dt">B.ByteString</span>
applyInstruction instruction source <span class="fu">=</span> writer (source, interpretInstruction instruction source)</code></pre></div>
<p>Our action takes two parameters and so we <code>map</code> it to our list of instructions. This gives us a list of actions expecting a source buffer to operate on.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">:</span>t map applyInstruction testInstructions</code></pre></div>
<pre><code>map applyInstruction testInstructions :: [ByteString -&gt; Writer ByteString ByteString]</code></pre>
<p>We need to reduce this list to a single value while executing each action in sequence, which implies a fold. <code>foldM</code> looks like what we need; according to the documentation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldM f a1 [x1, x2, <span class="fu">...</span>, xm] <span class="fu">==</span>
<span class="kw">do</span>
    a2 <span class="ot">&lt;-</span> f a1 x1
    a3 <span class="ot">&lt;-</span> f a2 x2
    <span class="fu">...</span>
    f am xm</code></pre></div>
<p>The only wrinkle is that <code>f</code> needs to take the argument first and the action second. We can accomplish this by defining</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f a b <span class="fu">=</span> b a</code></pre></div>
<p>or</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">=</span> flip (<span class="fu">$</span>)</code></pre></div>
<p>Putting it all together, we have</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">applyInstructions ::</span> <span class="dt">B.ByteString</span> <span class="ot">-&gt;</span> [<span class="dt">DeltaInstruction</span>] <span class="ot">-&gt;</span> <span class="dt">B.ByteString</span>
applyInstructions source instructions <span class="fu">=</span> execWriter <span class="fu">$</span> foldM (flip (<span class="fu">$</span>)) source <span class="fu">$</span> map applyInstruction instructions
applyInstructions testSource testInstructions <span class="fu">==</span> applyInstructions&#39; testSource B.empty testInstructions</code></pre></div>
<pre><code>True</code></pre>
<p>And there you have it, a use of Writer that has absolutely nothing to do with logging!</p>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = 'https://vaibhavsagar.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
]]></summary>
</entry>
<entry>
    <title>You Could Have Invented The State Monad</title>
    <link href="http://vaibhavsagar.com/blog/2016/06/17/haskell-state/index.html" />
    <id>http://vaibhavsagar.com/blog/2016/06/17/haskell-state/index.html</id>
    <published>2016-06-17T00:00:00Z</published>
    <updated>2016-06-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 17 June 2016
    
</div>
<div class="info">
    
        Tags: <a href="/tags/programming.html">programming</a>, <a href="/tags/haskell.html">haskell</a>, <a href="/tags/monads.html">monads</a>
    
</div>

<p>I’m attempting <a href="https://github.com/NICTA/course">NICTA/course</a> a second time. I gave up the last time because none of the State exercises were making sense and I found myself leaning so heavily on the solutions that I wasn’t actually learning anything. This time I was much better prepared after watching lots of <a href="http://www.meetup.com/CanFPG/">CanFPG</a> talks, reading lots of blog posts and writing a little Haskell, and I easily cleared the State hurdle. In fact, I’m now going to demonstrate how you (yes, <em>you</em>) could have come up with it (with a little help).</p>
<p>The fundamental insight of state is that it can be represented by a function that takes a value of type <code>s</code> and returns a tuple of some value <code>a</code> and a new value of type <code>s</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a,s) }</code></pre></div>
<p>Given such a type, what would its <code>Functor</code> instance look like?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">State</span> s) <span class="kw">where</span>
<span class="ot">  (&lt;$&gt;) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> <span class="dt">State</span> s b</code></pre></div>
<p>Our implementation should be another State that takes a value <code>s0</code>, passes it to the second argument <code>sa</code> (resulting in <code>(a, s1)</code>) and calls the function <code>fn</code> on <code>a</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  (<span class="fu">&lt;$&gt;</span>) fn (<span class="dt">State</span> sa) <span class="fu">=</span> <span class="dt">State</span> (\s0 <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s1) <span class="fu">=</span> sa s0 <span class="kw">in</span> (fn a, s1))</code></pre></div>
<p>This is a State that takes <code>s0</code> and returns <code>(b, s1)</code>, which is exactly what we wanted.</p>
<p>Let’s look at the <code>Applicative</code> instance next:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">State</span> s) <span class="kw">where</span>
<span class="ot">  pure  ::</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> s a
<span class="ot">  (&lt;*&gt;) ::</span> <span class="dt">State</span> s (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> <span class="dt">State</span> s b</code></pre></div>
<p>The implementation for <code>pure</code> explains where the <code>a</code> in our State comes from. Given some <code>a</code>, return a State that, when fed a value <code>s</code>, results in <code>(a,s)</code>. It practically writes itself.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  pure a <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (a,s))</code></pre></div>
<p><code>(&lt;*&gt;)</code> is a bit trickier, because we’re dealing with both the State the function is in and the State its argument is in. The implementation should be a State that takes a value <code>s0</code>, feeds it to <code>sa</code> to get <code>(fn, s1)</code>, feeds <code>s1</code> to <code>sb</code> to get <code>(a, s2)</code>, and calls <code>fn</code> on <code>a</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  (<span class="fu">&lt;*&gt;</span>) (<span class="dt">State</span> sa) (<span class="dt">State</span> sb) <span class="fu">=</span>
    <span class="dt">State</span> (\s0 <span class="ot">-&gt;</span> <span class="kw">let</span> (fn, s1) <span class="fu">=</span> sa s0
                      (a,  s2) <span class="fu">=</span> sb s1
                  <span class="kw">in</span> (fn a, s2))</code></pre></div>
<p>The hardest thing is remembering to thread <code>s0</code> through <code>sa</code> and <code>sb</code> so that we don’t lose any state on the way. We can usually follow the types but they don’t help in this specific case.</p>
<p>Finally, let’s look at the <code>Monad</code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span>
<span class="ot">  (&gt;&gt;=) ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">State</span> s b) <span class="ot">-&gt;</span> <span class="dt">State</span> s b</code></pre></div>
<p>As with all our previous implementations, it has the form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  (<span class="fu">&gt;&gt;=</span>) (<span class="dt">State</span> sa) fn <span class="fu">=</span> <span class="dt">State</span> (\s0 <span class="ot">-&gt;</span> <span class="kw">let</span> <span class="fu">???</span> <span class="kw">in</span> <span class="fu">???</span>)</code></pre></div>
<p>We know that we need to feed <code>s0</code> to <code>sa</code> to get an <code>a</code> to apply to <code>fn</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  (<span class="fu">&gt;&gt;=</span>) (<span class="dt">State</span> sa) fn <span class="fu">=</span>
    <span class="dt">State</span> (\s0 <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s1) <span class="fu">=</span> sa s0
                      <span class="fu">???</span>     <span class="fu">=</span> fn a
                  <span class="kw">in</span> <span class="fu">???</span>)</code></pre></div>
<p>The result of <code>fn a</code> is a <code>State sb</code> but we need to return a tuple of <code>(b, s)</code>. We can obtain one by feeding <code>s1</code> to <code>sb</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  (<span class="fu">&gt;&gt;=</span>) (<span class="dt">State</span> sa) fn <span class="fu">=</span>
    <span class="dt">State</span> (\s0 <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s1)  <span class="fu">=</span> sa s0
                      <span class="dt">State</span> sb <span class="fu">=</span> fn a
                  <span class="kw">in</span> sb s1)</code></pre></div>
<p>Success!</p>
<p>Let’s define a few functions to make our lives easier. <code>get</code> returns a State that, when fed some <code>s</code>, returns <code>(s,s)</code>. This allows us to expose <code>s</code> for direct modification:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">get ::</span> <span class="dt">State</span> s s
get <span class="fu">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (s, s))</code></pre></div>
<p><code>put</code> allows us to store a State that ignores the <code>s</code> passed to it later:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()
put s <span class="fu">=</span> <span class="dt">State</span> (\_ <span class="ot">-&gt;</span> ((),s))</code></pre></div>
<p>Sometimes we want the <code>s</code> and not the <code>a</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">exec ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
exec (<span class="dt">State</span> sa) s <span class="fu">=</span> snd <span class="fu">$</span> sa s</code></pre></div>
<p>At other times we want the <code>a</code> and not the <code>s</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
eval (<span class="dt">State</span> sa) s <span class="fu">=</span> fst <span class="fu">$</span> sa s</code></pre></div>
<p>With all this machinery in place, we can do this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span><span class="fu">&gt;</span> exec (<span class="kw">do</span> i <span class="ot">&lt;-</span> get; put (i<span class="fu">+</span><span class="dv">1</span>); return ()) <span class="dv">0</span>
<span class="dv">1</span></code></pre></div>
<p>I still couldn’t believe that this worked the first time I tried it, so let’s desugar this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    <span class="kw">do</span> i <span class="ot">&lt;-</span> get; put (i<span class="fu">+</span><span class="dv">1</span>); return ()
 <span class="fu">==</span> get <span class="fu">&gt;&gt;=</span> \i <span class="ot">-&gt;</span> put (i<span class="fu">+</span><span class="dv">1</span>) <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> pure ()
 <span class="fu">==</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (s, s))    <span class="fu">&gt;&gt;=</span> \i <span class="ot">-&gt;</span>
    <span class="dt">State</span> (\_ <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>)) <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
    <span class="dt">State</span> (\s <span class="ot">-&gt;</span> ((), s))</code></pre></div>
<p>Let’s simplify from the bottom up. By the definition of <code>(&gt;&gt;=)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    (<span class="fu">&gt;&gt;=</span>) (<span class="dt">State</span> (\_ <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>))) (\_ <span class="ot">-&gt;</span> (<span class="dt">State</span> (\s <span class="ot">-&gt;</span> ((), s)))) <span class="fu">=</span>
      <span class="dt">State</span> (\s0 <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s1)  <span class="fu">=</span> (\_ <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>)) s0
                     <span class="co">-- (a, s1)  = ((), i+1)</span>
                        <span class="dt">State</span> sb <span class="fu">=</span> (\_ <span class="ot">-&gt;</span> (<span class="dt">State</span> (\s <span class="ot">-&gt;</span> ((), s)))) a
                     <span class="co">--       sb = (\s -&gt; ((), s))</span>
                    <span class="kw">in</span> sb s1)
                     <span class="co">-- ((), i+1)</span>
<span class="fu">==</span> <span class="dt">State</span> (\s0 <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>))
<span class="fu">==</span> <span class="dt">State</span> (\_  <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>))</code></pre></div>
<p>Plugging that back in, we have</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">State</span> (\s <span class="ot">-&gt;</span> (s,s)) <span class="fu">&gt;&gt;=</span> \i <span class="ot">-&gt;</span> <span class="dt">State</span> (\_ <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>))</code></pre></div>
<p>Which we can simplify in the same way:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    (<span class="fu">&gt;&gt;=</span>) (<span class="dt">State</span> (\s <span class="ot">-&gt;</span> (s,s))) (\i <span class="ot">-&gt;</span> <span class="dt">State</span> (\_ <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>))) <span class="fu">=</span>
      <span class="dt">State</span> (\s0 <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s1)  <span class="fu">=</span> (\s <span class="ot">-&gt;</span> (s,s)) s0
                     <span class="co">-- (a, s1)  = (s0, s0)</span>
                        <span class="dt">State</span> sb <span class="fu">=</span> (\i <span class="ot">-&gt;</span> <span class="dt">State</span> (\_ <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>))) a
                     <span class="co">--       sb = (\_ -&gt; ((), s0+1))</span>
                    <span class="kw">in</span> sb s1)
                     <span class="co">-- ((), s0+1)</span>
 <span class="fu">==</span> <span class="dt">State</span> (\s0 <span class="ot">-&gt;</span> ((), s0<span class="fu">+</span><span class="dv">1</span>))
 <span class="fu">==</span> <span class="dt">State</span> (\i  <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>))</code></pre></div>
<p>Finally, we have</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">    exec (<span class="dt">State</span> (\i <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>))) <span class="dv">0</span>
 <span class="fu">==</span> snd <span class="fu">$</span> runState (<span class="dt">State</span> (\i <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>))) <span class="dv">0</span>
 <span class="fu">==</span> snd <span class="fu">$</span> (\i <span class="ot">-&gt;</span> ((), i<span class="fu">+</span><span class="dv">1</span>)) <span class="dv">0</span>
 <span class="fu">==</span> snd <span class="fu">$</span> ((), <span class="dv">1</span>)
 <span class="fu">==</span> <span class="dv">1</span></code></pre></div>
<p>This is my favourite thing about Haskell: the fact that it is built on abstractions that can be reasoned about in such a rigorous manner.</p>
<p>In fact, with some inspired renaming, <a href="http://www.haskellforall.com/2014/04/how-continuation-monad-works.html">you too could have invented the continuation monad</a>.</p>

<div id="disqus_thread"></div>
<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = 'https://vaibhavsagar.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
]]></summary>
</entry>

</feed>
