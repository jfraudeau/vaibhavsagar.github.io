<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Vaibhav Sagar's blog</title>
    <link href="https://vaibhavsagar.com/atom.xml" rel="self" />
    <link href="https://vaibhavsagar.com" />
    <id>https://vaibhavsagar.com/atom.xml</id>
    <author>
        <name>Vaibhav Sagar</name>
        <email>vaibhavsagar@gmail.com</email>
    </author>
    <updated>2018-11-03T00:00:00Z</updated>
    <entry>
    <title>Moving Towards Dialogue</title>
    <link href="https://vaibhavsagar.com/blog/2018/11/03/moving-towards-dialogue/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/11/03/moving-towards-dialogue/index.html</id>
    <published>2018-11-03T00:00:00Z</published>
    <updated>2018-11-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on  3 November 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/idris/index.html">idris</a>
    
</div>

<p><em>This blog post is essentially a transcript of <a href="https://www.youtube.com/watch?v=0oo8wIi2qBE">a 10-minute talk I gave at !!Con</a>, the slides for which are available <a href="https://vaibhavsagar.com/presentations/typed-holes/">here</a>.</em></p>
<p>Let’s talk about typed holes. What’s a typed hole? A definition I like is <em>“a placeholder for an expression with a known type and an unknown value”</em>.</p>
<p>Why are typed holes useful? Because they allow the language to help us write programs! To demonstrate, let’s look at some code in Python, a language that lacks this feature.</p>
<p>Suppose I want to write a function that takes another function and a list and applies the function to each element of that list. A first stab might look like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): <span class="cf">return</span> []</a></code></pre></div>
<p>This is obviously wrong: this function ignores its arguments and gives us an empty list each time. This is no good, but what’s worse is that Python will accept this definition without complaint. It doesn’t seem to know (or care).</p>
<p>Let’s try again. I hear the way to do things with lists in Python is to use a list comprehension, so I make sure to use one of those this time:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): [f(e) <span class="cf">for</span> e <span class="kw">in</span> ls]</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">...</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="op">&gt;&gt;&gt;</span> plusOne <span class="op">=</span> <span class="kw">lambda</span> i: i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(<span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]))</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="va">None</span></a></code></pre></div>
<p>But this definition is still wrong, because I forgot to put a <code>return</code> statement in! Again, Python will happily accept this.</p>
<p>I’m getting a bit frustrated at this point, so I look at how <code>map</code> is actually implemented. It uses a generator comprehension instead of a list comprehension, which makes it more general somehow, so I make sure to use that, and I remember to put a <code>return</code> statement in this time:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): <span class="cf">return</span> (f(e) <span class="cf">for</span> e <span class="kw">in</span> ls)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">...</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(<span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]))</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="op">&lt;</span>generator <span class="bu">object</span> <span class="bu">map</span>.<span class="op">&lt;</span><span class="bu">locals</span><span class="op">&gt;</span>.<span class="op">&lt;</span>genexpr<span class="op">&gt;</span> at <span class="bn">0x7ffb92103ca8</span><span class="op">&gt;</span></a></code></pre></div>
<p>And now instead of giving me something useful, this function gives me an address in memory, which seems especially pointless.</p>
<p>I give up. This example seems contrived, but over the course of my relationship with Python, which is more than a decade long now, I’ve seen the same dynamic play out embarrassingly many times. How do I write programs that work? Surely this is a simple question with a straightforward answer.</p>
<p>Indeed, the most common response I get when I ask this question is to write tests. That sounds reasonable, so let’s do that:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls):</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">...     <span class="bu">print</span>(<span class="st">&quot;Where are your tests now?&quot;</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">...     <span class="cf">return</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">...</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="op">&gt;&gt;&gt;</span> <span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">Where are your tests now?</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="va">True</span></a></code></pre></div>
<p>Okay, my test passes, so everything must be good, right?</p>
<p>I contend that tests are necessary, but not sufficient. They are problematic for at least two reasons:</p>
<ol type="1">
<li>They are only as good as the specification they imply for how a program should behave. If that specification is incomplete or wrong, no amount of tests will guarantee software that works.</li>
<li>The language doesn’t understand tests, by which I mean that it’s extremely difficult to automatically go from a failing test to the part of the code where the error lives. The programmer has to do the legwork of tracking down the bug based on essentially one bit of information in many cases.</li>
</ol>
<p>Fortunately, tests aren’t the only specification of how a program should behave. Types can also serve as specifications, and they have the advantage that they are extremely well integrated into the language in a way tests usually are not.</p>
<p>What does this mean in practice? Let’s look at Haskell. Haskell is statically typed, which means it expects to know the types of all the expressions in your program at compile time. This is nothing special though, lots of other languages also claim to be statically typed. What is special about Haskell though is that it has type inference, which means that you don’t have to annotate expressions with their types most of the time because the compiler can figure it out. If you put these two features together, you get typed holes!</p>
<p>Let’s try to write that same program in Haskell with typed holes. To start, let’s create a file called <code>Main.hs</code> with the following contents:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">map f ls <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">main <span class="fu">=</span> print ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>To automate the cycle of loading this file into GHCi every time we make a change, we’re going to use <a href="https://github.com/ndmitchell/ghcid"><code>ghcid</code></a>, which does essentially that and not much else. This is the result of running <code>ghcid Main.hs</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb6-1" data-line-number="1">Main.hs:4:12: error:</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    • Found hole: _ :: [b]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">               the type signature for:</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    • In the expression: _</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">      In an equation for ‘map’: map f ls = _</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    • Relevant bindings include</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  |</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">4 | map f ls = _</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  |            ^</a></code></pre></div>
<p>I’d suggest ignoring the middle and instead focusing on the top, which tells us the type of the hole, and the bottom, which tells us which bindings are in scope that we can use to fill in the hole.</p>
<p>In this case we aren’t learning anything new, and we already know that the hole is of type <code>[b]</code>, but it’s useful to know that our view of the world agrees with GHC’s. Of the bindings available to us, <code>ls</code> looks like the most promising, and we can split it into one of two cases: an empty list, or some element and the rest of the list. We can put a typed hole on the right hand side of each case alternative:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">map f ls <span class="fu">=</span> <span class="kw">case</span> ls <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    [] <span class="ot">-&gt;</span> _1</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> _2</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">main <span class="fu">=</span> print ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>And our <code>ghcid</code> output changes:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb8-1" data-line-number="1">Main.hs:5:11-12: error:</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    • Found hole: _1 :: [b]</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">               the type signature for:</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">      Or perhaps ‘_1’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    • In the expression: _1</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">      In a case alternative: [] -&gt; _1</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      In the expression:</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        case ls of</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">          [] -&gt; _1</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">          x : xs -&gt; _2</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    • Relevant bindings include</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  |</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">5 |     [] -&gt; _1</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">  |           ^^</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">Main.hs:6:13-14: error:</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">    • Found hole: _2 :: [b]</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb8-24" data-line-number="24">               the type signature for:</a>
<a class="sourceLine" id="cb8-25" data-line-number="25">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb8-26" data-line-number="26">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb8-27" data-line-number="27">      Or perhaps ‘_2’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb8-28" data-line-number="28">    • In the expression: _2</a>
<a class="sourceLine" id="cb8-29" data-line-number="29">      In a case alternative: x : xs -&gt; _2</a>
<a class="sourceLine" id="cb8-30" data-line-number="30">      In the expression:</a>
<a class="sourceLine" id="cb8-31" data-line-number="31">        case ls of</a>
<a class="sourceLine" id="cb8-32" data-line-number="32">          [] -&gt; _1</a>
<a class="sourceLine" id="cb8-33" data-line-number="33">          x : xs -&gt; _2</a>
<a class="sourceLine" id="cb8-34" data-line-number="34">    • Relevant bindings include</a>
<a class="sourceLine" id="cb8-35" data-line-number="35">        xs :: [a] (bound at Main.hs:6:7)</a>
<a class="sourceLine" id="cb8-36" data-line-number="36">        x :: a (bound at Main.hs:6:5)</a>
<a class="sourceLine" id="cb8-37" data-line-number="37">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb8-38" data-line-number="38">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb8-39" data-line-number="39">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb8-40" data-line-number="40">  |</a>
<a class="sourceLine" id="cb8-41" data-line-number="41">6 |     x:xs -&gt; _2</a>
<a class="sourceLine" id="cb8-42" data-line-number="42">  |             ^^</a></code></pre></div>
<p>We haven’t learned anything new about the types, but we can make progress another way. The only sensible thing to put on the right hand side when given an empty list is another empty list, and after splitting a list apart the most reasonable thing to do is to combine two other things into a new list:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">map f ls <span class="fu">=</span> <span class="kw">case</span> ls <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> _1<span class="fu">:</span>_2</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10"></a>
<a class="sourceLine" id="cb9-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">main <span class="fu">=</span> print ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Now the output gets a little more interesting:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb10-1" data-line-number="1">Main.hs:6:13-14: error:</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">    • Found hole: _1 :: b</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">               the type signature for:</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">      Or perhaps ‘_1’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    • In the first argument of ‘(:)’, namely ‘_1’</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">      In the expression: _1 : _2</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">      In a case alternative: x : xs -&gt; _1 : _2</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">    • Relevant bindings include</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">        xs :: [a] (bound at Main.hs:6:7)</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">        x :: a (bound at Main.hs:6:5)</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">  |</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">6 |     x:xs -&gt; _1:_2</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">  |             ^^</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">Main.hs:6:16-17: error:</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">    • Found hole: _2 :: [b]</a>
<a class="sourceLine" id="cb10-22" data-line-number="22">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">               the type signature for:</a>
<a class="sourceLine" id="cb10-24" data-line-number="24">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb10-25" data-line-number="25">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb10-26" data-line-number="26">      Or perhaps ‘_2’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb10-27" data-line-number="27">    • In the second argument of ‘(:)’, namely ‘_2’</a>
<a class="sourceLine" id="cb10-28" data-line-number="28">      In the expression: _1 : _2</a>
<a class="sourceLine" id="cb10-29" data-line-number="29">      In a case alternative: x : xs -&gt; _1 : _2</a>
<a class="sourceLine" id="cb10-30" data-line-number="30">    • Relevant bindings include</a>
<a class="sourceLine" id="cb10-31" data-line-number="31">        xs :: [a] (bound at Main.hs:6:7)</a>
<a class="sourceLine" id="cb10-32" data-line-number="32">        x :: a (bound at Main.hs:6:5)</a>
<a class="sourceLine" id="cb10-33" data-line-number="33">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb10-34" data-line-number="34">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb10-35" data-line-number="35">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb10-36" data-line-number="36">  |</a>
<a class="sourceLine" id="cb10-37" data-line-number="37">6 |     x:xs -&gt; _1:_2</a>
<a class="sourceLine" id="cb10-38" data-line-number="38">  |                ^^</a></code></pre></div>
<p>Our first hole is now of type <code>b</code>, and we see that it’s possible to get a value of this type by applying <code>f</code> to <code>x</code>. The second hole is still of type <code>[b]</code>, and we see that the most reasonable way to get a value of this type is to recurse, using <code>map</code> with <code>f</code> and <code>xs</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">map f ls <span class="fu">=</span> <span class="kw">case</span> ls <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> f x<span class="fu">:</span> map f xs</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"></a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">main <span class="fu">=</span> print ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>And <code>ghcid</code> is satisfied:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb12-1" data-line-number="1">All good (1 module, at &lt;time&gt;)</a></code></pre></div>
<p>It compiles! But does it work?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" data-line-number="1">$ <span class="ex">runhaskell</span> Main.hs</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ex">True</span></a></code></pre></div>
<p>Fantastic! We were able to ask the compiler for hints and get useful answers back. This is a gigantic improvement over anything I’m aware of in Python land.</p>
<p>Unfortunately, there is a catch: this program is too easy to break. Let me demonstrate my favourite way:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">map f ls <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8"></a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">main <span class="fu">=</span> print ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>The astute reader will notice that this is the Haskell equivalent of the obviously broken Python program we started with. Here is what <code>ghcid</code> has to say:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb15-1" data-line-number="1">All good (1 module, at &lt;time&gt;)</a></code></pre></div>
<p>So what’s going on here? It turns out an empty list is a valid list of any type. Is it a list of Strings? Yup. Is it a list of Ints? Sure!</p>
<p>One way of avoiding this class of incorrect program is to specify that the input and the output lists should be of the same length. It’s possible to do this in Haskell, but it is a lot of work. Can we do better?</p>
<p>Enter Idris.</p>
<p>Idris is a functional programming language with a more sophisticated type system than Haskell’s. Unfortunately it trades off some type inference to achieve this, so it’s not strictly better than Haskell in every way. It has excellent built-in editor support, and therefore has fancier typed holes!</p>
<p>Let’s try to implement <code>map</code> again:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb16-8" data-line-number="8"></a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"></a>
<a class="sourceLine" id="cb16-11" data-line-number="11"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13"></a>
<a class="sourceLine" id="cb16-14" data-line-number="14"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Instead of implementing <code>map</code> on lists, we’ll use a more interesting type called <code>Vect</code> which is essentially a list that knows about its length. A <code>Vect</code> can either be <code>Nil</code> of length <code>0</code> or an element on the front of another <code>Vect</code> of some length <code>length</code> giving us a new <code>Vect</code> of length <code>length + 1</code>. I’ve also gone ahead defined equality on these <code>Vect</code>s because I use it in <code>main</code>.</p>
<p>Loading the file into the Idris REPL gives us access to the editor integration:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb17-1" data-line-number="1">$ <span class="ex">idris</span> Main.idr</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">     <span class="ex">____</span>    __     _</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">    <span class="ex">/</span>  _/___/ /____(_)<span class="ex">____</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    <span class="ex">/</span> // __  / ___/ / ___/     Version 1.3.0</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  <span class="ex">_/</span> // /_/ / /  / (__  )      <span class="ex">http</span>://www.idris-lang.org/</a>
<a class="sourceLine" id="cb17-6" data-line-number="6"> <span class="ex">/___</span>/\<span class="ex">__</span>,_/_/  /_/____/       Type :? for help</a>
<a class="sourceLine" id="cb17-7" data-line-number="7"></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="ex">Idris</span> is free software with ABSOLUTELY NO WARRANTY.</a>
<a class="sourceLine" id="cb17-9" data-line-number="9"><span class="ex">For</span> details type :warranty.</a>
<a class="sourceLine" id="cb17-10" data-line-number="10"><span class="ex">Type</span> checking ./Main.idr</a>
<a class="sourceLine" id="cb17-11" data-line-number="11"><span class="ex">Holes</span>: Main.map</a>
<a class="sourceLine" id="cb17-12" data-line-number="12"><span class="ex">*Main</span><span class="op">&gt;</span></a></code></pre></div>
<p>In vim, I can use <code>&lt;localleader&gt;d</code> with the cursor on <code>map</code> to fill in a skeleton definition:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb18-8" data-line-number="8"></a>
<a class="sourceLine" id="cb18-9" data-line-number="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">map f x <span class="fu">=</span> <span class="ot">?map_rhs</span></a>
<a class="sourceLine" id="cb18-11" data-line-number="11"></a>
<a class="sourceLine" id="cb18-12" data-line-number="12"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14"></a>
<a class="sourceLine" id="cb18-15" data-line-number="15"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Using <code>&lt;localleader&gt;t</code> with the cursor on the typed hole provides a type for us:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb19-1" data-line-number="1">  b : Type</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  a : Type</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  f : a -&gt; b</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  length : Nat</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  x : Vect length a</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">--------------------------------------</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">map_rhs : Vect length b</a></code></pre></div>
<p>But we don’t need to go down this route. We can make Idris do a case-split for us with <code>&lt;localleader&gt;c</code> with the cursor on <code>x</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb20-8" data-line-number="8"></a>
<a class="sourceLine" id="cb20-9" data-line-number="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">map f [] <span class="fu">=</span> <span class="ot">?map_rhs_1</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> <span class="ot">?map_rhs_2</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12"></a>
<a class="sourceLine" id="cb20-13" data-line-number="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb20-15" data-line-number="15"></a>
<a class="sourceLine" id="cb20-16" data-line-number="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Again, as with our Haskell example, the only sensible output when the input is an empty <code>Vect</code> is another empty <code>Vect</code>. We think so, but what does Idris think? It has a nifty feature called “proof search” that can search the space of all possible programs that fit and choose the first one. We can use this with <code>&lt;localleader&gt;o</code> (‘o’ is for obvious):</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb21-4" data-line-number="4"></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb21-8" data-line-number="8"></a>
<a class="sourceLine" id="cb21-9" data-line-number="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">map f [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> <span class="ot">?map_rhs_2</span></a>
<a class="sourceLine" id="cb21-12" data-line-number="12"></a>
<a class="sourceLine" id="cb21-13" data-line-number="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb21-14" data-line-number="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb21-15" data-line-number="15"></a>
<a class="sourceLine" id="cb21-16" data-line-number="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb21-17" data-line-number="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>And we get the result we expect. This works for the simple case, but does it work for the more complex one?</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb22-8" data-line-number="8"></a>
<a class="sourceLine" id="cb22-9" data-line-number="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">map f [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> f x <span class="ot">::</span> map f y</a>
<a class="sourceLine" id="cb22-12" data-line-number="12"></a>
<a class="sourceLine" id="cb22-13" data-line-number="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb22-14" data-line-number="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-15" data-line-number="15"></a>
<a class="sourceLine" id="cb22-16" data-line-number="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb22-17" data-line-number="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>It does!</p>
<p>What happens when we try to break this like we broke our Haskell program?</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb23-4" data-line-number="4"></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb23-8" data-line-number="8"></a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">map f [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb23-12" data-line-number="12"></a>
<a class="sourceLine" id="cb23-13" data-line-number="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15"></a>
<a class="sourceLine" id="cb23-16" data-line-number="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>This is what Idris has to say:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb24-1" data-line-number="1">*Main&gt; :r</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">Type checking ./Main.idr</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">Main.idr:11:18-19:</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">   |</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">11 | map f (x :: y) = []</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">   |                  ~~</a>
<a class="sourceLine" id="cb24-7" data-line-number="7">When checking right hand side of Main.map with expected type</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">        Vect (1 + length) b</a>
<a class="sourceLine" id="cb24-9" data-line-number="9"></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">Type mismatch between</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">        Vect 0 a (Type of [])</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">and</a>
<a class="sourceLine" id="cb24-13" data-line-number="13">        Vect (S length) b (Expected type)</a>
<a class="sourceLine" id="cb24-14" data-line-number="14"></a>
<a class="sourceLine" id="cb24-15" data-line-number="15">Specifically:</a>
<a class="sourceLine" id="cb24-16" data-line-number="16">        Type mismatch between</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">                0</a>
<a class="sourceLine" id="cb24-18" data-line-number="18">        and</a>
<a class="sourceLine" id="cb24-19" data-line-number="19">                S length</a>
<a class="sourceLine" id="cb24-20" data-line-number="20"></a>
<a class="sourceLine" id="cb24-21" data-line-number="21">Holes: Main.map</a></code></pre></div>
<p>We get a useful and informative error message.</p>
<p>And we’ve done it! You can download and use these languages today. When using other languages with static types, I always felt that they existed merely as busywork and I essentially had to shove them down the compiler’s throat in order to get it to accept my program, and I feel the opposite way about these languages. In other words, types are friends, not food! They can help you design your program, write that program, and even debug it if necessary.</p>
<p>One aspect of programming that always bothered me was my perception of the compiler (or interpreter) as some sort of gatekeeper whose job was to dismiss my program until it met some arbitrary standard. Even worse, I would find myself writing a program that passed but was subtly incorrect, and I would iterate on this process, writing a series of subtly incorrect programs without any guidance from my tools. Discovering typed holes and the style of programming they enable has shown me a different approach, where I can open up a dialogue with my language and collaborate on writing a program whose correctness I am more confident of.</p>
<p>That’s all I have to say about typed holes, but there’s recently been interesting work on untyped holes that I would like to mention briefly. Suppose you like the idea of holes but not the idea of types, or you work in a language that isn’t statically typed and you want some of these benefits. What you could do is:</p>
<ol type="1">
<li>Write a program with gaps where you’re unsure what should happen (we’ll call this a <em>sketch</em>)</li>
<li>Write some test cases that the correct program should satisfy</li>
<li>Feed both these things to a SAT/SMT solver (a clever program with a bag of tricks)</li>
<li>???</li>
<li>Profit!!!</li>
</ol>
<p>The solver churns through the space of all prossible programs and picks the one that passes the tests, giving us the correct program we wanted!</p>
<p>This sounds great in theory, so why aren’t we doing this yet? There is (predictably) a catch, which is that this is still a research topic for now. You can read <a href="https://people.csail.mit.edu/asolar/papers/thesis.pdf">Armando Solar-Lezama’s PhD thesis on this</a>, and systems like <a href="http://comcom.csail.mit.edu/comcom/#Synquid">Synquid</a> and <a href="https://github.com/webyrd/Barliman">Barliman</a> demonstrate the current state of the art. I think it’s especially interesting that Synquid has both typed and untyped holes, which suggests to me that it is the most promising approach.</p>
<p>I’ll leave you with some resources about typed holes, particularly Conor McBride’s presentations at <a href="https://www.youtube.com/watch?v=3U3lV5VPmOU">YOW! Lambda Jam</a> and <a href="https://skillsmatter.com/skillscasts/8893-is-a-type-a-lifebuoy-or-a-lamp">Haskell eXchange</a> that are rich with insight. There’s also <a href="https://www.shimweasel.com/2015/02/17/typed-holes-for-beginners">a tutorial by Mark Wotton</a>, and finally <a href="http://hazel.org/">Hazel</a>, which is a live functional programming environment with typed holes!</p>
<p>I hope I’ve encouraged you to try this style of programming for yourself. There’s never been a better time to do it.</p>
]]></summary>
</entry>
<entry>
    <title>HAMTs from Scratch</title>
    <link href="https://vaibhavsagar.com/blog/2018/07/29/hamts-from-scratch/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/07/29/hamts-from-scratch/index.html</id>
    <published>2018-07-29T00:00:00Z</published>
    <updated>2018-07-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 29 July 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>
    
</div>

<p><em>This blog post is also an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/hamt/HAMTsFromScratch.ipynb">IHaskell notebook</a> and the source is available <a href="https://github.com/vaibhavsagar/notebooks/tree/master/hamt/hamt">separately</a>.</em></p>
<p>I wanted an explanation for HAMTs (Hash Array Mapped Tries) that was more detailed than <a href="https://idea.popcount.org/2012-07-25-introduction-to-hamt/">Marek Majkowski’s introduction</a> and more approachable than <a href="https://lampwww.epfl.ch/papers/idealhashtrees.pdf"><em>Ideal Hash Trees</em> by Phil Bagwell</a>, the paper that introduced them. If you haven’t heard of them before, HAMTs are a way of efficiently representing a hashtable as a <a href="https://en.wikipedia.org/wiki/Trie">trie</a>, and although they were first envisioned as a mutable data structure they are easily adapted to work as a <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structure</a>. They form the backbone of the <a href="http://hackage.haskell.org/package/unordered-containers"><code>unordered-containers</code></a> library but the <a href="https://github.com/tibbe/unordered-containers/blob/efa43a2ab09dc6eb72893d12676a8e188cb4ca63/Data/HashMap/Base.hs">implementation has been lovingly optimised</a> to the point where I found it impenetrable. <a href="https://github.com/ezyang/hamt/blob/a43559795630980eb16ab832a003d8e6acd21cf6/HAMT.hs">Edward Z. Yang’s implementation</a> is much easier to follow and after adapting it I think I’m in a good place to provide my own take on them.</p>
<p>Let’s start with a few imports! I’ll be using these packages:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/base"><code>base</code></a></li>
<li><a href="http://hackage.haskell.org/package/bytestring"><code>bytestring</code></a></li>
<li><a href="http://hackage.haskell.org/package/memory"><code>memory</code></a></li>
<li><a href="http://hackage.haskell.org/package/pretty-show"><code>pretty-show</code></a></li>
<li><a href="http://hackage.haskell.org/package/timeit"><code>timeit</code></a></li>
<li><a href="http://hackage.haskell.org/package/vector"><code>vector</code></a></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Bits</span>             (<span class="dt">Bits</span> (bit, complement, popCount, shiftR, (.&amp;.), (.|.)),</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">                              <span class="dt">FiniteBits</span> (finiteBitSize))</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.ByteArray.Hash</span>   (<span class="dt">FnvHash32</span> (..), fnv1Hash)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.ByteString.Char8</span> (pack)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Data.Char</span>             (intToDigit)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Semigroup</span>        ((&lt;&gt;))</a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Vector</span>           (<span class="dt">Vector</span>, drop, singleton, take, (!), (//))</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Word</span>             (<span class="dt">Word16</span>, <span class="dt">Word32</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Numeric</span>               (showIntAtBase)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Prelude</span>               <span class="kw">hiding</span> (drop, lookup, take)</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">System.TimeIt</span>         (timeIt)</a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span>      (pPrint)</a></code></pre></div>
<p>We’re going to be doing some bit twiddling. To make this easier to follow I’m going to define a <code>newtype</code> whose <code>Show</code> instance displays the binary representation.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">newtype</span> <span class="dt">Binary</span> a <span class="fu">=</span> <span class="dt">Binary</span> a</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="kw">deriving</span> (<span class="dt">Enum</span>, <span class="dt">Ord</span>, <span class="dt">Real</span>, <span class="dt">Integral</span>, <span class="dt">Eq</span>, <span class="dt">Num</span>, <span class="dt">Bits</span>, <span class="dt">FiniteBits</span>)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">instance</span> (<span class="dt">FiniteBits</span> a, <span class="dt">Show</span> a, <span class="dt">Integral</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Binary</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    show (<span class="dt">Binary</span> n) <span class="fu">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        str <span class="fu">=</span> showIntAtBase <span class="dv">2</span> intToDigit n <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        size <span class="fu">=</span> finiteBitSize n</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">        <span class="kw">in</span> replicate (size <span class="fu">-</span> length str) <span class="ch">&#39;0&#39;</span> <span class="fu">&lt;&gt;</span> str</a></code></pre></div>
<p>Using this <code>newtype</code> we can turn this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="dv">24732</span><span class="ot"> ::</span> <span class="dt">Word16</span></a></code></pre></div>
<pre><code>24732</code></pre>
<p>into this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dv">24732</span><span class="ot"> ::</span> <span class="dt">Binary</span> <span class="dt">Word16</span></a></code></pre></div>
<pre><code>0110000010011100</code></pre>
<p>I’m going to use 32-bit hashes (because they’re more convenient to display than 64-bit ones) and 16-bit bitmaps.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Hash</span> <span class="fu">=</span> <span class="dt">Binary</span> <span class="dt">Word32</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">type</span> <span class="dt">Bitmap</span> <span class="fu">=</span> <span class="dt">Binary</span> <span class="dt">Word16</span></a></code></pre></div>
<p>The width of bitmaps is <span class="math inline">2<sup><em>n</em></sup></span> where <span class="math inline"><em>n</em></span> is the number of bits of the hash that we use at each level of the tree (more on this below). I’m setting <span class="math inline"><em>n</em> = 4</span> which is what <code>unordered-containers</code> uses (as of this writing), but we could e.g. set <span class="math inline"><em>n</em> = 5</span> and use 32-bit bitmaps if we wanted.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">bitsPerSubkey ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">bitsPerSubkey <span class="fu">=</span> <span class="dv">4</span></a></code></pre></div>
<p><code>Shift</code> is a multiple of <span class="math inline"><em>n</em></span> that we will use to focus on the correct part of the hash.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Shift</span> <span class="fu">=</span> <span class="dt">Int</span></a></code></pre></div>
<p>I’m also going to define a <code>Hashable</code> class to decouple the choice of a hash function from the implementation of <code>HAMT</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Hashable</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    hash ::</span> a <span class="ot">-&gt;</span> <span class="dt">Hash</span></a></code></pre></div>
<p>For convenience, we’ll use the FNV-1 hash function with strings.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">String</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    hash s <span class="fu">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">        <span class="dt">FnvHash32</span> h <span class="fu">=</span> fnv1Hash (pack s)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">        <span class="kw">in</span> <span class="dt">Binary</span> h</a></code></pre></div>
<p>Here’s what it looks like in practice.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">hash <span class="st">&quot;1&quot;</span><span class="ot"> ::</span> <span class="dt">Binary</span> <span class="dt">Word32</span></a></code></pre></div>
<pre><code>00000101000011000101110100101110</code></pre>
<p>A HAMT can be</p>
<ul>
<li>empty (<code>None</code>)</li>
<li>a leaf node with the hash, the key, and the value (<code>Leaf</code>)</li>
<li>a node with a bitmap and a (non-empty) vector of child HAMTs (<code>Many</code>)</li>
</ul>
<p>I’ve chosen to ignore the possibility of collisions, but we could handle them by adding an extra constructor, e.g. <code>Colliding</code> with a hash and a vector of key-value pairs.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Leaf</span> <span class="dt">Hash</span> key value</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    <span class="fu">|</span> <span class="dt">Many</span> <span class="dt">Bitmap</span> (<span class="dt">Vector</span> (<span class="dt">HAMT</span> key value))</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="ot">empty ::</span> <span class="dt">HAMT</span> k v</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">empty <span class="fu">=</span> <span class="dt">None</span></a></code></pre></div>
<p>We’ll need some helper functions for vectors:</p>
<ul>
<li><code>insertAt</code> inserts an element at a specified index, shifting elements to the right forwards</li>
<li><code>updateAt</code> replaces an element at a specified index with a new element</li>
<li><code>deleteAt</code> removes an element at an index, shifting elements to the right backwards</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ot">insertAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">insertAt vector index a <span class="fu">=</span> take index vector <span class="fu">&lt;&gt;</span> singleton a <span class="fu">&lt;&gt;</span> drop index vector</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">updateAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">updateAt vector index a <span class="fu">=</span> vector <span class="fu">//</span> [(index, a)]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="ot">deleteAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">deleteAt vector index <span class="fu">=</span> take index vector <span class="fu">&lt;&gt;</span> drop (index<span class="fu">+</span><span class="dv">1</span>) vector</a></code></pre></div>
<h3 id="insert">Insert</h3>
<p>I think the bit manipulation functions are crucial to understanding what’s going on, so I’m going to motivate them by trying to define <code>insert</code> without them and coming up with them as they are needed. This initial definition won’t be quite right so I’ll call it <code>insert_</code> to differentiate it from the correct <code>insert'</code> function I present later. The type signature for <code>insert_</code> is</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">insert_ ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a></code></pre></div>
<p>Inserting a key-value pair into an empty HAMT gives us a single leaf node:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">insert_ hash key value <span class="dt">None</span> <span class="fu">=</span> <span class="dt">Leaf</span> hash key value</a></code></pre></div>
<p>Inserting a key-value pair into a single leaf node where the hashes match gives us an updated leaf node (because we’re pretending collisions don’t exist):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">insert_ hash key value (<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">    <span class="fu">|</span> hash <span class="fu">==</span> leafHash <span class="fu">=</span> <span class="dt">Leaf</span> hash key value</a></code></pre></div>
<p>Inserting into a HAMT consisting of a single leaf node where the hashes don’t match upgrades that leaf node to a <code>Many</code> node and inserts the key-value pair into that <code>Many</code> node:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">insert_ hash key value leaf<span class="fu">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">    <span class="fu">|</span> hash <span class="fu">/=</span> leafHash <span class="fu">=</span> insert_ key value (<span class="dt">Many</span> someBitmap (singleton leaf))</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">    <span class="kw">where</span> someBitmap <span class="fu">=</span> undefined</a></code></pre></div>
<h4 id="bit-masking">Bit Masking</h4>
<p>Where does <code>someBitmap</code> come from? Time for an example! Let’s start with a <code>Leaf (hash &quot;1&quot;) &quot;1&quot; 1</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">h <span class="fu">=</span> hash <span class="st">&quot;1&quot;</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">leaf <span class="fu">=</span> <span class="dt">Leaf</span> h <span class="st">&quot;1&quot;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">leaf</a></code></pre></div>
<pre><code>Leaf 00000101000011000101110100101110 &quot;1&quot; 1</code></pre>
<p><code>someBitMap</code> is a 16-bit bitmap where the number of bits set (the <code>popCount</code>) is the length of the vector, which in this case is <span class="math inline">1</span>. We want to set one bit, but which bit? We carve off the last <span class="math inline"><em>n</em></span> bits using a mask:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">subkeyMask ::</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2">subkeyMask <span class="fu">=</span> (bit bitsPerSubkey) <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">subkeyMask</a></code></pre></div>
<pre><code>0000000000001111</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="co">--     0101110100101110</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="co">-- .&amp;. 0000000000001111</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="co">-----------------------</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4"><span class="co">--     0000000000001110</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5"></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">fragment <span class="fu">=</span> fromIntegral h <span class="fu">.&amp;.</span> subkeyMask</a>
<a class="sourceLine" id="cb24-7" data-line-number="7"></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">fragment</a></code></pre></div>
<pre><code>0000000000001110</code></pre>
<p>Then we interpret that fragment as a number:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="dt">Binary</span> position <span class="fu">=</span> fragment</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">position</a></code></pre></div>
<pre><code>14</code></pre>
<p>Finally, we set that bit and we have our bitmap:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="ot">someBitmap ::</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">someBitmap <span class="fu">=</span> <span class="dt">Binary</span> <span class="fu">$</span> bit <span class="fu">$</span> fromIntegral position</a>
<a class="sourceLine" id="cb28-3" data-line-number="3"></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">someBitmap</a></code></pre></div>
<pre><code>0100000000000000</code></pre>
<p>We’re going to be doing this a lot, so I’ll define this as <code>bitMask_</code>. The extra <code>_</code> is because it isn’t quite right for the same reason as <code>insert_</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="ot">bitMask_ ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">bitMask_ hash <span class="fu">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">    fragment <span class="fu">=</span> fromIntegral hash <span class="fu">.&amp;.</span> subkeyMask</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">    <span class="dt">Binary</span> position <span class="fu">=</span> fragment</a>
<a class="sourceLine" id="cb30-5" data-line-number="5">    <span class="kw">in</span> <span class="dt">Binary</span> (bit (fromIntegral position))</a></code></pre></div>
<p>Let’s look at the <code>Many</code> case. If we try inserting into a node where the bit in the bitmap corresponding to the mask is <code>0</code>, this means that there is an empty slot in the vector. We can insert a leaf node into this slot and set the corresponding bit in the bitmap to <code>1</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">insert_ hash key value (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb31-2" data-line-number="2">    <span class="fu">|</span> bitmap <span class="fu">.&amp;.</span> mask <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">        leaf <span class="fu">=</span> <span class="dt">Leaf</span> (hash key) key value</a>
<a class="sourceLine" id="cb31-4" data-line-number="4">        vector&#39; <span class="fu">=</span> insertAt vector index leaf</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">        bitmap&#39; <span class="fu">=</span> bitmap <span class="fu">.|.</span> mask</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">        <span class="kw">in</span> <span class="dt">Many</span> bitmap&#39; vector&#39;</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">        mask <span class="fu">=</span> bitMask_ hash</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">        index <span class="fu">=</span> undefined</a></code></pre></div>
<h4 id="mask-indexing">Mask Indexing</h4>
<p>What <code>index</code> do we use? This is where <code>popCount</code> makes an appearance. Let’s demonstrate by inserting <code>(&quot;10&quot;, 2)</code> into our example. First we get the mask corresponding to <code>hash &quot;10&quot;</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">mask <span class="fu">=</span> bitMask_ (hash <span class="st">&quot;10&quot;</span>)</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">mask</a></code></pre></div>
<pre><code>0000010000000000</code></pre>
<p>Next we want to find the number of lower bits that have been set. We use <code>mask - 1</code> as a mask:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">mask <span class="fu">-</span> <span class="dv">1</span></a></code></pre></div>
<pre><code>0000001111111111</code></pre>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="co">--     0100000000000000</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="co">-- .&amp;. 0000001111111111</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3"><span class="co">-----------------------</span></a>
<a class="sourceLine" id="cb36-4" data-line-number="4"><span class="co">--     0000000000000000</span></a>
<a class="sourceLine" id="cb36-5" data-line-number="5"></a>
<a class="sourceLine" id="cb36-6" data-line-number="6">masked <span class="fu">=</span> someBitmap <span class="fu">.&amp;.</span> (mask <span class="fu">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb36-7" data-line-number="7"></a>
<a class="sourceLine" id="cb36-8" data-line-number="8">masked</a></code></pre></div>
<pre><code>0000000000000000</code></pre>
<p>Then we count the number of bits set with <code>popCount</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1">index <span class="fu">=</span> popCount masked</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"></a>
<a class="sourceLine" id="cb38-3" data-line-number="3">index</a></code></pre></div>
<pre><code>0</code></pre>
<p>And this is the index we need to insert at! We’ll call this <code>maskIndex</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="ot">maskIndex ::</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">maskIndex bitmap mask <span class="fu">=</span> popCount (bitmap <span class="fu">.&amp;.</span> (mask <span class="fu">-</span> <span class="dv">1</span>))</a></code></pre></div>
<p>The final case is where the bit in the bitmap is already set. We need to recursively update the HAMT at the corresponding index:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1">insert_ hash key value (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">    <span class="fu">|</span> bitmap <span class="fu">.&amp;.</span> mask <span class="fu">==</span> <span class="dv">1</span> <span class="fu">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb41-3" data-line-number="3">        subtree&#39; <span class="fu">=</span> insert_ hash key value (vector <span class="fu">!</span> index) <span class="co">-- WRONG!</span></a>
<a class="sourceLine" id="cb41-4" data-line-number="4">        vector&#39; <span class="fu">=</span> updateAt vector index subtree&#39;</a>
<a class="sourceLine" id="cb41-5" data-line-number="5">        <span class="kw">in</span> <span class="dt">Many</span> bitmap vector&#39;</a>
<a class="sourceLine" id="cb41-6" data-line-number="6">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-7" data-line-number="7">        mask <span class="fu">=</span> bitMask_ hash</a>
<a class="sourceLine" id="cb41-8" data-line-number="8">        index <span class="fu">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>But this definition is wrong, because instead of carving off the last <span class="math inline"><em>n</em></span> bits of <code>hash</code>, we want to recursively carve off the next <span class="math inline"><em>n</em></span> bits!</p>
<h4 id="shifting">Shifting</h4>
<p>This is what’s missing from our definition, a <code>shift</code> parameter corresponding to how far up the <code>hash</code> we’re looking. This is why we defined <code>Shift</code> above. Taking this extra parameter into account, our bit manipulation functions now become:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">subkeyMask ::</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2">subkeyMask <span class="fu">=</span> (bit bitsPerSubkey) <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb42-3" data-line-number="3"></a>
<a class="sourceLine" id="cb42-4" data-line-number="4"><span class="ot">maskIndex ::</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb42-5" data-line-number="5">maskIndex bitmap mask <span class="fu">=</span> popCount (bitmap <span class="fu">.&amp;.</span> (mask <span class="fu">-</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb42-6" data-line-number="6"></a>
<a class="sourceLine" id="cb42-7" data-line-number="7"><span class="ot">subkey ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb42-8" data-line-number="8">subkey hash shift <span class="fu">=</span> fromIntegral <span class="fu">$</span> (fromIntegral <span class="fu">$</span> shiftR hash shift) <span class="fu">.&amp;.</span> subkeyMask</a>
<a class="sourceLine" id="cb42-9" data-line-number="9"></a>
<a class="sourceLine" id="cb42-10" data-line-number="10"><span class="ot">bitMask ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb42-11" data-line-number="11">bitMask hash shift <span class="fu">=</span> bit (subkey hash shift)</a></code></pre></div>
<p>We plumb through this <code>shift</code> parameter, only modifying it in the final case, to give us the correct definitions of <code>insert'</code> and <code>insert</code>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="ot">insert ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">insert key value hamt <span class="fu">=</span> insert&#39; <span class="dv">0</span> (hash key) key value hamt</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"></a>
<a class="sourceLine" id="cb43-4" data-line-number="4"><span class="ot">insert&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">insert&#39; shift hash key value <span class="dt">None</span> <span class="fu">=</span> <span class="dt">Leaf</span> hash key value</a>
<a class="sourceLine" id="cb43-6" data-line-number="6"></a>
<a class="sourceLine" id="cb43-7" data-line-number="7">insert&#39; shift hash key value leaf<span class="fu">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb43-8" data-line-number="8">    <span class="fu">|</span> hash <span class="fu">==</span> leafHash <span class="fu">=</span> <span class="dt">Leaf</span> hash key value</a>
<a class="sourceLine" id="cb43-9" data-line-number="9">    <span class="fu">|</span> otherwise <span class="fu">=</span> insert&#39; shift hash key value (<span class="dt">Many</span> (bitMask leafHash shift) (singleton leaf))</a>
<a class="sourceLine" id="cb43-10" data-line-number="10"></a>
<a class="sourceLine" id="cb43-11" data-line-number="11">insert&#39; shift hash key value (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb43-12" data-line-number="12">    <span class="fu">|</span> bitmap <span class="fu">.&amp;.</span> mask <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb43-13" data-line-number="13">        leaf <span class="fu">=</span> <span class="dt">Leaf</span> hash key value</a>
<a class="sourceLine" id="cb43-14" data-line-number="14">        vector&#39; <span class="fu">=</span> insertAt vector index leaf</a>
<a class="sourceLine" id="cb43-15" data-line-number="15">        bitmap&#39; <span class="fu">=</span> bitmap <span class="fu">.|.</span> mask</a>
<a class="sourceLine" id="cb43-16" data-line-number="16">        <span class="kw">in</span> <span class="dt">Many</span> bitmap&#39; vector&#39;</a>
<a class="sourceLine" id="cb43-17" data-line-number="17">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb43-18" data-line-number="18">        subtree <span class="fu">=</span> vector <span class="fu">!</span> index</a>
<a class="sourceLine" id="cb43-19" data-line-number="19">        subtree&#39; <span class="fu">=</span> insert&#39; (shift<span class="fu">+</span>bitsPerSubkey) hash key value subtree</a>
<a class="sourceLine" id="cb43-20" data-line-number="20">        vector&#39; <span class="fu">=</span> updateAt vector index subtree&#39;</a>
<a class="sourceLine" id="cb43-21" data-line-number="21">        <span class="kw">in</span> <span class="dt">Many</span> bitmap vector&#39;</a>
<a class="sourceLine" id="cb43-22" data-line-number="22">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-23" data-line-number="23">        mask <span class="fu">=</span> bitMask hash shift</a>
<a class="sourceLine" id="cb43-24" data-line-number="24">        index <span class="fu">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>Now we can construct HAMTs and inspect them! I’ll define a <code>fromList</code> function and use <code>pPrint</code> from <code>pretty-show</code> to highlight the tree structure:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="ot">fromList ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> [(key, value)] <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb44-2" data-line-number="2">fromList <span class="fu">=</span> foldr (uncurry insert) empty</a>
<a class="sourceLine" id="cb44-3" data-line-number="3"></a>
<a class="sourceLine" id="cb44-4" data-line-number="4">example <span class="fu">=</span> fromList [(<span class="st">&quot;1&quot;</span>, <span class="dv">1</span>), (<span class="st">&quot;10&quot;</span>, <span class="dv">2</span>), (<span class="st">&quot;100&quot;</span>, <span class="dv">3</span>), (<span class="st">&quot;1000&quot;</span>, <span class="dv">4</span>)]</a>
<a class="sourceLine" id="cb44-5" data-line-number="5"></a>
<a class="sourceLine" id="cb44-6" data-line-number="6">pPrint example</a></code></pre></div>
<pre><code>Many
  0100010000000000
  [ Many
      0000000100100000
      [ Leaf 00100000011101101010111101011010 &quot;10&quot; 2
      , Leaf 10001010111100101011011010001010 &quot;1000&quot; 4
      ]
  , Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<h3 id="lookup">Lookup</h3>
<p>Compared to <code>insert</code>, <code>lookup</code> is a walk in the park. It’s implemented along the same lines as <code>insert</code>:</p>
<ul>
<li>on <code>None</code> nodes, it fails</li>
<li>on <code>Leaf</code> nodes, it succeeds if the hashes match</li>
<li>on <code>Many</code> nodes, it fails if the bit isn’t set, and recurses into the child node otherwise</li>
</ul>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1">lookup<span class="ot"> ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">Maybe</span> value</a>
<a class="sourceLine" id="cb46-2" data-line-number="2">lookup key hamt <span class="fu">=</span> lookup&#39; <span class="dv">0</span> (hash key) hamt</a>
<a class="sourceLine" id="cb46-3" data-line-number="3"></a>
<a class="sourceLine" id="cb46-4" data-line-number="4"><span class="ot">lookup&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">Maybe</span> value</a>
<a class="sourceLine" id="cb46-5" data-line-number="5">lookup&#39; shift hash <span class="dt">None</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb46-6" data-line-number="6"></a>
<a class="sourceLine" id="cb46-7" data-line-number="7">lookup&#39; shift hash (<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb46-8" data-line-number="8">    <span class="fu">|</span> hash <span class="fu">==</span> leafHash <span class="fu">=</span> <span class="dt">Just</span> leafValue</a>
<a class="sourceLine" id="cb46-9" data-line-number="9">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb46-10" data-line-number="10"></a>
<a class="sourceLine" id="cb46-11" data-line-number="11">lookup&#39; shift hash (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb46-12" data-line-number="12">    <span class="fu">|</span> bitmap <span class="fu">.&amp;.</span> mask <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb46-13" data-line-number="13">    <span class="fu">|</span> otherwise <span class="fu">=</span> lookup&#39; (shift<span class="fu">+</span>bitsPerSubkey) hash (vector <span class="fu">!</span> index)</a>
<a class="sourceLine" id="cb46-14" data-line-number="14">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-15" data-line-number="15">        mask <span class="fu">=</span> bitMask hash shift</a>
<a class="sourceLine" id="cb46-16" data-line-number="16">        index <span class="fu">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>Let’s quickly confirm that it works.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1">lookup <span class="st">&quot;100&quot;</span> example</a></code></pre></div>
<pre><code>Just 3</code></pre>
<h4 id="memoising-fibonacci">Memoising Fibonacci</h4>
<p>We now have enough of an API to use this as a hashtable! Let’s use it to memoise the calculation of the Fibonacci sequence. The naive implementation does a lot of unnecessary recomputation:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2">fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb49-3" data-line-number="3">fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb49-4" data-line-number="4">fib n <span class="fu">=</span> fib (n<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> fib (n<span class="fu">-</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb49-5" data-line-number="5"></a>
<a class="sourceLine" id="cb49-6" data-line-number="6">timeIt <span class="fu">$</span> print <span class="fu">$</span> fib <span class="dv">30</span></a></code></pre></div>
<pre><code>1346269
CPU time:   1.31s</code></pre>
<p>We can memoise it by storing previously calculated results and using them if they are available:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2">    hash int <span class="fu">=</span> <span class="dt">Binary</span> (fromIntegral int)</a>
<a class="sourceLine" id="cb51-3" data-line-number="3"></a>
<a class="sourceLine" id="cb51-4" data-line-number="4"><span class="ot">fib&#39; ::</span> <span class="dt">HAMT</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">HAMT</span> <span class="dt">Int</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb51-5" data-line-number="5">fib&#39; table <span class="dv">0</span> <span class="fu">=</span> (<span class="dv">1</span>, insert <span class="dv">0</span> <span class="dv">1</span> table)</a>
<a class="sourceLine" id="cb51-6" data-line-number="6">fib&#39; table <span class="dv">1</span> <span class="fu">=</span> (<span class="dv">1</span>, insert <span class="dv">1</span> <span class="dv">1</span> table)</a>
<a class="sourceLine" id="cb51-7" data-line-number="7">fib&#39; table n <span class="fu">=</span> <span class="kw">case</span> lookup n table <span class="kw">of</span></a>
<a class="sourceLine" id="cb51-8" data-line-number="8">    <span class="dt">Just</span> i <span class="ot">-&gt;</span> (i, table)</a>
<a class="sourceLine" id="cb51-9" data-line-number="9">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb51-10" data-line-number="10">        (i1, table&#39;)  <span class="fu">=</span> fib&#39; table  (n<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb51-11" data-line-number="11">        (i2, table&#39;&#39;) <span class="fu">=</span> fib&#39; table&#39; (n<span class="fu">-</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb51-12" data-line-number="12">        <span class="kw">in</span> (i1 <span class="fu">+</span> i2, insert n (i1 <span class="fu">+</span> i2) table&#39;&#39;)</a>
<a class="sourceLine" id="cb51-13" data-line-number="13"></a>
<a class="sourceLine" id="cb51-14" data-line-number="14"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb51-15" data-line-number="15">fib n <span class="fu">=</span> fst <span class="fu">$</span> fib&#39; empty n</a>
<a class="sourceLine" id="cb51-16" data-line-number="16"></a>
<a class="sourceLine" id="cb51-17" data-line-number="17">timeIt <span class="fu">$</span> print <span class="fu">$</span> fib <span class="dv">30</span></a></code></pre></div>
<pre><code>1346269
CPU time:   0.00s</code></pre>
<h3 id="delete">Delete</h3>
<p>Finally we come to <code>delete</code>, which is only a little more complex than <code>lookup</code>. It needs to make sure that no <code>Many</code> node has a child <code>None</code> node, so if a <code>None</code> node:</p>
<ul>
<li>is an only child, it will replace the parent node</li>
<li>has any sibling nodes, it will be removed from the parent node’s bitmap and vector</li>
</ul>
<p><code>Leaf</code> nodes similarly replace their parents if they are the only child.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="ot">delete ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb53-2" data-line-number="2">delete key hamt <span class="fu">=</span> delete&#39; <span class="dv">0</span> (hash key) hamt</a>
<a class="sourceLine" id="cb53-3" data-line-number="3"></a>
<a class="sourceLine" id="cb53-4" data-line-number="4"><span class="ot">delete&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb53-5" data-line-number="5">delete&#39; shift hash <span class="dt">None</span> <span class="fu">=</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb53-6" data-line-number="6"></a>
<a class="sourceLine" id="cb53-7" data-line-number="7">delete&#39; shift hash leaf<span class="fu">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb53-8" data-line-number="8">    <span class="fu">|</span> hash <span class="fu">==</span> leafHash <span class="fu">=</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb53-9" data-line-number="9">    <span class="fu">|</span> otherwise <span class="fu">=</span> leaf</a>
<a class="sourceLine" id="cb53-10" data-line-number="10"></a>
<a class="sourceLine" id="cb53-11" data-line-number="11">delete&#39; shift hash many<span class="fu">@</span>(<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb53-12" data-line-number="12">    <span class="fu">|</span> bitmap <span class="fu">.&amp;.</span> mask <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> many</a>
<a class="sourceLine" id="cb53-13" data-line-number="13">    <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb53-14" data-line-number="14">        subtree <span class="fu">=</span> vector <span class="fu">!</span> index</a>
<a class="sourceLine" id="cb53-15" data-line-number="15">        subtree&#39; <span class="fu">=</span> delete&#39; (shift<span class="fu">+</span>bitsPerSubkey) hash subtree</a>
<a class="sourceLine" id="cb53-16" data-line-number="16">        <span class="kw">in</span> <span class="kw">case</span> subtree&#39; <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-17" data-line-number="17">            <span class="dt">None</span> <span class="ot">-&gt;</span> <span class="kw">if</span> length vector <span class="fu">==</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb53-18" data-line-number="18">                <span class="kw">then</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb53-19" data-line-number="19">                <span class="kw">else</span> <span class="dt">Many</span> (bitmap <span class="fu">.&amp;.</span> complement mask) (deleteAt vector index)</a>
<a class="sourceLine" id="cb53-20" data-line-number="20">            <span class="dt">Leaf</span>{} <span class="ot">-&gt;</span> <span class="kw">if</span> length vector <span class="fu">==</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb53-21" data-line-number="21">                <span class="kw">then</span> subtree&#39;</a>
<a class="sourceLine" id="cb53-22" data-line-number="22">                <span class="kw">else</span>  <span class="dt">Many</span> bitmap (updateAt vector index subtree&#39;)</a>
<a class="sourceLine" id="cb53-23" data-line-number="23">            <span class="dt">Many</span>{} <span class="ot">-&gt;</span> <span class="dt">Many</span> bitmap (updateAt vector index subtree&#39;)</a>
<a class="sourceLine" id="cb53-24" data-line-number="24">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb53-25" data-line-number="25">        mask <span class="fu">=</span> bitMask hash shift</a>
<a class="sourceLine" id="cb53-26" data-line-number="26">        index <span class="fu">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>Let’s see this in action.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1">pPrint <span class="fu">$</span> delete <span class="st">&quot;1000&quot;</span> example</a></code></pre></div>
<pre><code>Many
  0100010000000000
  [ Many
      0000000000100000 [ Leaf 00100000011101101010111101011010 &quot;10&quot; 2 ]
  , Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<p>It’s possible to have a situation where we have a <code>Many</code> node with only one child, because our replacement behaviour checks the length of the vector before any elements are removed from it. However, removing the last leaf will correctly delete the parent node.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1">pPrint <span class="fu">$</span> delete <span class="st">&quot;10&quot;</span> <span class="fu">$</span> delete <span class="st">&quot;1000&quot;</span> example</a></code></pre></div>
<pre><code>Many
  0100000000000000
  [ Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<p>And we’re done! I hope you understand HAMTs better than when you started reading this.</p>
<p>If you want to use this for something other than educational purposes, I would recommend adding logic to deal with hash collisions, which I intentionally omitted. There’s also some low-hanging fruit in terms of performance optimisations. The first thing that comes to mind is an additional <code>Full</code> constructor for the case where all bits in the bitmap are set, and the next thing is the use of unsafe vector functions that omit bounds checking.</p>
<p>Thanks to <a href="https://twitter.com/evanborden">Evan Borden</a>, <a href="https://twitter.com/candeira">Javier Candeira</a>, <a href="https://hypirion.com/">Jean Niklas L’orange</a>, <a href="http://mjhopkins.github.io/">Mark Hopkins</a>, and <a href="https://teh.id.au/">Tim Humphries</a> for comments and feedback.</p>
]]></summary>
</entry>
<entry>
    <title>Trees That Shrink</title>
    <link href="https://vaibhavsagar.com/blog/2018/06/19/trees-that-shrink/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/06/19/trees-that-shrink/index.html</id>
    <published>2018-06-19T00:00:00Z</published>
    <updated>2018-06-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 19 June 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p><em>This blog post is also available as an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/trees-that-shrink/TreesThatShrink.ipynb">IHaskell notebook</a>.</em></p>
<p>I read <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf">this paper</a> a while ago and people seemed pretty excited about it, although I couldn’t see why. Fortunately, someone posed me an interesting problem recently and in the process of tackling it I think I understand now.</p>
<p>Suppose we have a simple algebraic data type representing the lambda calculus with <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a>, which are a way of avoiding the messy problem of variable names:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Lit</span> a</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="fu">|</span> <span class="dt">Abs</span> (<span class="dt">Expr</span> a)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">App</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>So far so good! Now we want to have let bindings in this language, and we’ve decided that we want named variables as well while we’re at it because de Bruijn indices are not so much fun to work with. We dutifully define another data type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Expr&#39;</span> a</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Lit&#39;</span> a</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">Var&#39;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    <span class="fu">|</span> <span class="dt">Abs&#39;</span> (<span class="dt">Expr&#39;</span> a)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">App&#39;</span> (<span class="dt">Expr&#39;</span> a) (<span class="dt">Expr&#39;</span> a)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="fu">|</span> <span class="dt">Let&#39;</span> <span class="dt">String</span> (<span class="dt">Expr&#39;</span> a) (<span class="dt">Expr&#39;</span> a)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>Let bindings can be easily desugared into lambda abstractions as follows:</p>
<pre><code>let &lt;n&gt; = &lt;x&gt; in &lt;y&gt; &lt;=&gt; (\n -&gt; y) x</code></pre>
<p>which will help us to write a simpler evaluator. However, we’d also like to make sure the desugaring has been implemented correctly, perhaps by converting to some intermediate state where both the name and the correct de Bruijn index coexist peacefully. We have a couple of options, none of which are great:</p>
<ol type="1">
<li>Define a third data type and then write an indexing pass that converts <code>Var String</code> to <code>Var (String, Int)</code> and then a desugaring pass that converts that to <code>Expr a</code>.</li>
<li>Work entirely within the bigger data type, forget about indexing, and throw errors whenever a <code>Let</code> is encountered after a desugaring pass.</li>
<li>Combine the desugaring and indexing passes into one, and forget about keeping track of the desugaring.</li>
</ol>
<p>Let’s implement the third:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">desugarAndAnonymise ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr&#39;</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">desugarAndAnonymise env expr <span class="fu">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    <span class="dt">Lit&#39;</span> a <span class="ot">-&gt;</span> <span class="dt">Lit</span> a</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="dt">Var&#39;</span> name <span class="ot">-&gt;</span> <span class="dt">Var</span> (env <span class="fu">Map.!</span> name)</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    <span class="dt">Abs&#39;</span> expr&#39; <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">        env&#39;  <span class="fu">=</span> Map.map succ env</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">        <span class="kw">in</span> <span class="dt">Abs</span> (desugarAndAnonymise env&#39; expr&#39;)</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    <span class="dt">App&#39;</span> f x <span class="ot">-&gt;</span> <span class="dt">App</span> (desugarAndAnonymise env f) (desugarAndAnonymise env x)</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    <span class="dt">Let&#39;</span> n v expr&#39; <span class="ot">-&gt;</span> desugarAndAnonymise env (<span class="dt">App&#39;</span> (<span class="dt">Abs&#39;</span> expr&#39;) v)</a></code></pre></div>
<p>That wasn’t a lot of fun to write, I have no idea if I did the conversion from names to indices correctly, and there’s no easy way to check if I did.</p>
<p>These problems are (barely) manageable in this case, but what if we want to add more syntax sugar or share this data type with other libraries that have different use cases? We’d either have to write variations on a theme over and over again or say goodbye to type safety. It also becomes harder and harder to decompose our functions into smaller ones that only do one thing. There has to be a better way!</p>
<p>This is the subject of <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf">Trees that Grow</a> by Shayan Najd and Simon Peyton Jones. They noticed the need for this approach when looking at GHC’s abstract syntax tree type but the idiom is generally applicable.</p>
<p>The first insight is that defining different data types for each use case is the wrong approach. Conceptually all these data types are the same type, just with different annotations or decoration, and we should be able to define the base data type with enough extensibility to accommodate all the other use cases.</p>
<p>The second insight is that we can use some of GHC’s fancier features to ease the pain of working with this ridiculously extensible data type, such as type families and pattern synonyms.</p>
<p>The third insight is that this can be made to work with other language features, such as generalised abstract data types and existentials! We won’t use this here, but it’s great to know that it’s possible.</p>
<p>Let’s see how we can use it to solve our problem. The first thing to do is turn on some language extensions, as with anything moderately fun in Haskell:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">{-# LANGUAGE PatternSynonyms   #-}</span></a></code></pre></div>
<p>The next steps are:</p>
<ol type="1">
<li>Add a type parameter to the data type declaration.</li>
<li>Add a field to each constructor with a new data type that uses this parameter (and any others).</li>
<li>Add an extra constructor to enable extending this data type, also with a new data type as in step 2.</li>
<li>Define type families for each of the new data types you declared in steps 2 and 3.</li>
</ol>
<p>And we’re done! This is what that looks like for our example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExpX</span> i a</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">LitX</span> (<span class="dt">XLit</span> i a) a</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">VarX</span> (<span class="dt">XVar</span> i a)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="fu">|</span> <span class="dt">AbsX</span> (<span class="dt">XAbs</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">AppX</span> (<span class="dt">XApp</span> i a) (<span class="dt">ExpX</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="fu">|</span> <span class="dt">ExpX</span> (<span class="dt">XExp</span> i a)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="kw">type</span> family <span class="dt">XLit</span> i a</a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="kw">type</span> family <span class="dt">XVar</span> i a</a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="kw">type</span> family <span class="dt">XAbs</span> i a</a>
<a class="sourceLine" id="cb6-11" data-line-number="11"><span class="kw">type</span> family <span class="dt">XApp</span> i a</a>
<a class="sourceLine" id="cb6-12" data-line-number="12"><span class="kw">type</span> family <span class="dt">XExp</span> i a</a></code></pre></div>
<p>The next thing to do is to reconstruct our original data type with no extensions. To do this we’ll need to use the <a href="http://hackage.haskell.org/package/base/docs/Data-Void.html"><code>Data.Void</code></a> package:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">void ::</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">void <span class="fu">=</span> error <span class="st">&quot;Attempt to evaluate void&quot;</span></a></code></pre></div>
<p>Now we can define <code>ExpUD</code> (UD for “undecorated”) using <code>Int</code> for our <code>Var</code> like we originally wanted and <code>Void</code> for all other extension points. It might get frustrating to construct and work with these values by hand, so we can use pattern synonyms to ease this pain.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ExpUD</span> a <span class="fu">=</span> <span class="dt">ExpX</span> <span class="dt">UD</span> a</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">data</span> <span class="dt">UD</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">UD</span> a <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">UD</span> a <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">UD</span> a <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">UD</span> a <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">UD</span> a <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">pattern <span class="dt">LitUD</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">pattern <span class="dt">LitUD</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    <span class="kw">where</span> <span class="dt">LitUD</span> a <span class="fu">=</span> <span class="dt">LitX</span> void a</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">pattern <span class="dt">VarUD</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">pattern <span class="dt">VarUD</span> i <span class="ot">&lt;-</span> <span class="dt">VarX</span> i</a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    <span class="kw">where</span> <span class="dt">VarUD</span> i <span class="fu">=</span> <span class="dt">VarX</span> i</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">pattern <span class="dt">AbsUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">pattern <span class="dt">AbsUD</span> a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> _ a</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    <span class="kw">where</span> <span class="dt">AbsUD</span> a <span class="fu">=</span> <span class="dt">AbsX</span> void a</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">pattern <span class="dt">AppUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">pattern <span class="dt">AppUD</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">    <span class="kw">where</span> <span class="dt">AppUD</span> f a <span class="fu">=</span> <span class="dt">AppX</span> void f a</a></code></pre></div>
<p>This is unfortunately a bit boilerplate-y, but now we can define that intermediate data type that uses named variables as well as de Bruijn indices! As a bonus, we can now have named parameters to lambdas, which would not have been possible with the approach we tried to use above.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ExpAnn</span> a <span class="fu">=</span> <span class="dt">ExpX</span> <span class="dt">Ann</span> a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Ann</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Ann</span> a <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Ann</span> a <span class="fu">=</span> (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Ann</span> a <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Ann</span> a <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Ann</span> a <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">pattern <span class="dt">LitAnn</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">pattern <span class="dt">LitAnn</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    <span class="kw">where</span> <span class="dt">LitAnn</span> a <span class="fu">=</span> <span class="dt">LitX</span> void a</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">pattern <span class="dt">VarAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-13" data-line-number="13">pattern <span class="dt">VarAnn</span> s i <span class="ot">&lt;-</span> <span class="dt">VarX</span> (s,i)</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">    <span class="kw">where</span> <span class="dt">VarAnn</span> s i <span class="fu">=</span> <span class="dt">VarX</span> (s, i)</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">pattern <span class="dt">AbsAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-16" data-line-number="16">pattern <span class="dt">AbsAnn</span> s a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    <span class="kw">where</span> <span class="dt">AbsAnn</span> s a <span class="fu">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">pattern <span class="dt">AppAnn</span><span class="ot"> ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">pattern <span class="dt">AppAnn</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">    <span class="kw">where</span> <span class="dt">AppAnn</span> f a <span class="fu">=</span> <span class="dt">AppX</span> void f a</a></code></pre></div>
<p>Now for my favourite part, where we add let bindings! We achieve this by using a tuple to represent <code>let &lt;name&gt; = &lt;expr&gt; in &lt;expr&gt;</code> as <code>(&lt;name&gt;, &lt;expr&gt;, &lt;expr&gt;)</code>, and we use named variables and parameters in this representation.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ExpLet</span> a <span class="fu">=</span> <span class="dt">ExpX</span> <span class="dt">Let</span> a</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Let</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Let</span> a <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Let</span> a <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Let</span> a <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Let</span> a <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Let</span> a <span class="fu">=</span> (<span class="dt">String</span>, <span class="dt">ExpLet</span> a, <span class="dt">ExpLet</span> a)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8"></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">pattern <span class="dt">LitLet</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">pattern <span class="dt">LitLet</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">    <span class="kw">where</span> <span class="dt">LitLet</span> a <span class="fu">=</span> <span class="dt">LitX</span> void a</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">pattern <span class="dt">VarLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">pattern <span class="dt">VarLet</span> s <span class="ot">&lt;-</span> <span class="dt">VarX</span> s</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">    <span class="kw">where</span> <span class="dt">VarLet</span> s <span class="fu">=</span> <span class="dt">VarX</span> s</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">pattern <span class="dt">AbsLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">pattern <span class="dt">AbsLet</span> s a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">    <span class="kw">where</span> <span class="dt">AbsLet</span> s a <span class="fu">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">pattern <span class="dt">AppLet</span><span class="ot"> ::</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">pattern <span class="dt">AppLet</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">    <span class="kw">where</span> <span class="dt">AppLet</span> f a <span class="fu">=</span> <span class="dt">AppX</span> void f a</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">pattern <span class="dt">LetLet</span> n v e <span class="ot">&lt;-</span> <span class="dt">ExpX</span> (n,v,e)</a></code></pre></div>
<p>Now instead of writing a single giant pass, we can write smaller ones!</p>
<p>We can write a desugarer that preserves names and rewrites our let bindings as follows:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">desugar ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">desugar env expr <span class="fu">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="dt">LitLet</span> a <span class="ot">-&gt;</span> <span class="dt">LitAnn</span> a</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="dt">VarLet</span> name <span class="ot">-&gt;</span> <span class="dt">VarAnn</span> name (env <span class="fu">Map.!</span> name)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    <span class="dt">AbsLet</span> name expr&#39; <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">        env&#39;  <span class="fu">=</span> Map.map succ env</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">        env&#39;&#39; <span class="fu">=</span> Map.insert name <span class="dv">0</span> env&#39;</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">        <span class="kw">in</span> <span class="dt">AbsAnn</span> name (desugar env&#39;&#39; expr&#39;)</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    <span class="dt">AppLet</span> f x <span class="ot">-&gt;</span> <span class="dt">AppAnn</span> (desugar env f) (desugar env x)</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    <span class="dt">LetLet</span> n v expr&#39; <span class="ot">-&gt;</span> desugar env (<span class="dt">AppLet</span> (<span class="dt">AbsLet</span> n expr&#39;) v)</a></code></pre></div>
<p>We can also write an anonymiser that throws the names away:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">anonymise ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">anonymise expr <span class="fu">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    <span class="dt">LitAnn</span> a <span class="ot">-&gt;</span> <span class="dt">LitUD</span> a</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    <span class="dt">VarAnn</span> _ i <span class="ot">-&gt;</span> <span class="dt">VarUD</span> i</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    <span class="dt">AbsAnn</span> _ e <span class="ot">-&gt;</span> <span class="dt">AbsUD</span> (anonymise e)</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    <span class="dt">AppAnn</span> f x <span class="ot">-&gt;</span> <span class="dt">AppUD</span> (anonymise f) (anonymise x)</a></code></pre></div>
<p>And finally an evaluator that operates on undecorated expressions:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">eval ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">eval env expr <span class="fu">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="dt">LitUD</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">    <span class="dt">VarUD</span> i <span class="ot">-&gt;</span> env <span class="fu">!!</span> i</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="dt">AbsUD</span> f <span class="ot">-&gt;</span> eval env f</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    <span class="dt">AppUD</span> f x <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">        x&#39; <span class="fu">=</span> eval env x</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">        <span class="kw">in</span> eval (x&#39;<span class="fu">:</span>env) f</a></code></pre></div>
<p>Let’s see it in action!</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">identity <span class="fu">=</span> <span class="dt">AbsLet</span> <span class="st">&quot;i&quot;</span> (<span class="dt">VarLet</span> <span class="st">&quot;i&quot;</span>)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">konst <span class="fu">=</span> (<span class="dt">AbsLet</span> <span class="st">&quot;x&quot;</span> (<span class="dt">AbsLet</span> <span class="st">&quot;y&quot;</span> (<span class="dt">VarLet</span> <span class="st">&quot;x&quot;</span>)))</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">eval [] <span class="fu">.</span> anonymise <span class="fu">.</span> desugar Map.empty <span class="fu">$</span> <span class="dt">AppLet</span> (<span class="dt">AppLet</span> konst (<span class="dt">LitLet</span> <span class="dv">1</span>)) (<span class="dt">LitLet</span> <span class="dv">2</span>)</a></code></pre></div>
<pre><code>2</code></pre>
<p>Awesome! We have composable compiler passes that are easier to write and to think about. Even with this small example, I hope the benefits are clear.</p>
<p>Edit: <a href="https://www.reddit.com/r/haskell/comments/8s75n3/trees_that_shrink/e0x8se2">Edward Kmett points out</a> that using <code>Void</code> makes this approach unnecessarily footgun-prone and suggests using strict fields and <code>()</code> instead. This allows for simpler pattern synonyms and comes with the additional benefit that we can disable constructors with <code>Void</code> so we can actually have trees that shrink:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ExpX</span> i a</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">LitX</span> <span class="fu">!</span>(<span class="dt">XLit</span> i a) a</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">VarX</span> <span class="fu">!</span>(<span class="dt">XVar</span> i a)</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">    <span class="fu">|</span> <span class="dt">AbsX</span> <span class="fu">!</span>(<span class="dt">XAbs</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">AppX</span> <span class="fu">!</span>(<span class="dt">XApp</span> i a) (<span class="dt">ExpX</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    <span class="fu">|</span> <span class="dt">ExpX</span> <span class="fu">!</span>(<span class="dt">XExp</span> i a)</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"></a>
<a class="sourceLine" id="cb16-8" data-line-number="8"><span class="kw">type</span> family <span class="dt">XLit</span> i a</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="kw">type</span> family <span class="dt">XVar</span> i a</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"><span class="kw">type</span> family <span class="dt">XAbs</span> i a</a>
<a class="sourceLine" id="cb16-11" data-line-number="11"><span class="kw">type</span> family <span class="dt">XApp</span> i a</a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="kw">type</span> family <span class="dt">XExp</span> i a</a>
<a class="sourceLine" id="cb16-13" data-line-number="13"></a>
<a class="sourceLine" id="cb16-14" data-line-number="14"><span class="kw">type</span> <span class="dt">ExpUD</span> a <span class="fu">=</span> <span class="dt">ExpX</span> <span class="dt">UD</span> a</a>
<a class="sourceLine" id="cb16-15" data-line-number="15"><span class="kw">data</span> <span class="dt">UD</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">UD</span> a <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb16-17" data-line-number="17"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">UD</span> a <span class="fu">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-18" data-line-number="18"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">UD</span> a <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb16-19" data-line-number="19"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">UD</span> a <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb16-20" data-line-number="20"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">UD</span> a <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-21" data-line-number="21"></a>
<a class="sourceLine" id="cb16-22" data-line-number="22">pattern <span class="dt">LitUD</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-23" data-line-number="23">pattern <span class="dt">LitUD</span> a <span class="fu">=</span> <span class="dt">LitX</span> () a</a>
<a class="sourceLine" id="cb16-24" data-line-number="24">pattern <span class="dt">VarUD</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-25" data-line-number="25">pattern <span class="dt">VarUD</span> i <span class="fu">=</span> <span class="dt">VarX</span> i</a>
<a class="sourceLine" id="cb16-26" data-line-number="26">pattern <span class="dt">AbsUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-27" data-line-number="27">pattern <span class="dt">AbsUD</span> a <span class="fu">=</span> <span class="dt">AbsX</span> () a</a>
<a class="sourceLine" id="cb16-28" data-line-number="28">pattern <span class="dt">AppUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-29" data-line-number="29">pattern <span class="dt">AppUD</span> f a <span class="fu">=</span> <span class="dt">AppX</span> () f a</a>
<a class="sourceLine" id="cb16-30" data-line-number="30"></a>
<a class="sourceLine" id="cb16-31" data-line-number="31"><span class="kw">type</span> <span class="dt">ExpAnn</span> a <span class="fu">=</span> <span class="dt">ExpX</span> <span class="dt">Ann</span> a</a>
<a class="sourceLine" id="cb16-32" data-line-number="32"><span class="kw">data</span> <span class="dt">Ann</span></a>
<a class="sourceLine" id="cb16-33" data-line-number="33"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Ann</span> a <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb16-34" data-line-number="34"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Ann</span> a <span class="fu">=</span> (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb16-35" data-line-number="35"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Ann</span> a <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb16-36" data-line-number="36"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Ann</span> a <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb16-37" data-line-number="37"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Ann</span> a <span class="fu">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-38" data-line-number="38"></a>
<a class="sourceLine" id="cb16-39" data-line-number="39">pattern <span class="dt">LitAnn</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-40" data-line-number="40">pattern <span class="dt">LitAnn</span> a <span class="fu">=</span> <span class="dt">LitX</span> () a</a>
<a class="sourceLine" id="cb16-41" data-line-number="41">pattern <span class="dt">VarAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-42" data-line-number="42">pattern <span class="dt">VarAnn</span> s i <span class="fu">=</span> <span class="dt">VarX</span> (s, i)</a>
<a class="sourceLine" id="cb16-43" data-line-number="43">pattern <span class="dt">AbsAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-44" data-line-number="44">pattern <span class="dt">AbsAnn</span> s a <span class="fu">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb16-45" data-line-number="45">pattern <span class="dt">AppAnn</span><span class="ot"> ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-46" data-line-number="46">pattern <span class="dt">AppAnn</span> f a <span class="fu">=</span> <span class="dt">AppX</span> () f a</a>
<a class="sourceLine" id="cb16-47" data-line-number="47"></a>
<a class="sourceLine" id="cb16-48" data-line-number="48"><span class="kw">type</span> <span class="dt">ExpLet</span> a <span class="fu">=</span> <span class="dt">ExpX</span> <span class="dt">Let</span> a</a>
<a class="sourceLine" id="cb16-49" data-line-number="49"><span class="kw">data</span> <span class="dt">Let</span></a>
<a class="sourceLine" id="cb16-50" data-line-number="50"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Let</span> a <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb16-51" data-line-number="51"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Let</span> a <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb16-52" data-line-number="52"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Let</span> a <span class="fu">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb16-53" data-line-number="53"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Let</span> a <span class="fu">=</span> ()</a>
<a class="sourceLine" id="cb16-54" data-line-number="54"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Let</span> a <span class="fu">=</span> (<span class="dt">String</span>, <span class="dt">ExpLet</span> a, <span class="dt">ExpLet</span> a)</a>
<a class="sourceLine" id="cb16-55" data-line-number="55"></a>
<a class="sourceLine" id="cb16-56" data-line-number="56">pattern <span class="dt">LitLet</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-57" data-line-number="57">pattern <span class="dt">LitLet</span> a <span class="fu">=</span> <span class="dt">LitX</span> () a</a>
<a class="sourceLine" id="cb16-58" data-line-number="58">pattern <span class="dt">VarLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-59" data-line-number="59">pattern <span class="dt">VarLet</span> s <span class="fu">=</span> <span class="dt">VarX</span> s</a>
<a class="sourceLine" id="cb16-60" data-line-number="60">pattern <span class="dt">AbsLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-61" data-line-number="61">pattern <span class="dt">AbsLet</span> s a <span class="fu">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb16-62" data-line-number="62">pattern <span class="dt">AppLet</span><span class="ot"> ::</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-63" data-line-number="63">pattern <span class="dt">AppLet</span> f a <span class="fu">=</span> <span class="dt">AppX</span> () f a</a>
<a class="sourceLine" id="cb16-64" data-line-number="64">pattern <span class="dt">LetLet</span> n v e <span class="ot">&lt;-</span> <span class="dt">ExpX</span> (n,v,e)</a></code></pre></div>
<p>The definitions of <code>desugar</code>, <code>anonymise</code>, and <code>eval</code> are unchanged.</p>
<p>Thanks to <a href="http://andychu.net/">Andy Chu</a> and <a href="https://push.cx/">Peter Bhat Harkins</a> for comments and feedback.</p>
]]></summary>
</entry>
<entry>
    <title>Quick and Easy Nixpkgs Pinning</title>
    <link href="https://vaibhavsagar.com/blog/2018/05/27/quick-easy-nixpkgs-pinning/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/05/27/quick-easy-nixpkgs-pinning/index.html</id>
    <published>2018-05-27T00:00:00Z</published>
    <updated>2018-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 27 May 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/nix/index.html">nix</a>
    
</div>

<p>I love Nix because it makes packaging and using software so easy. For example, here’s a first stab at an expression that makes a recent version of Pandoc available in a <code>nix-shell</code> (be warned, this will take a while the first time!):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="ex">haskellPackages</span> = pkgs.haskellPackages.override {</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="ex">overrides</span> = self: super: {</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.4.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    };</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  };</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  <span class="ex">buildInputs</span> = [ haskellPackages.pandoc ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">} <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>If we save this to <code>default.nix</code> we can use it as follows (unless you’re reading this after the release of NixOS 18.09, more on that below):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="ex">nix-shell</span> default.nix</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">[<span class="ex">nix-shell</span>]$ pandoc --version</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ex">pandoc</span> 2.2</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></a></code></pre></div>
<p>Pandoc is infamously large, so this will probably take a while the first time. Fortunately, Nix caches build artifacts and knows to provide the same output if the inputs are unchanged, so if we immediately try this again a second time it should be nearly instantaneous.</p>
<p>Barring an event like the garbage collection of the Nix store or a change in the expression above, we would like to never rebuild this package again.</p>
<p>Unfortunately, there is a serious flaw with this expression that prevents us from guaranteeing this.</p>
<p>The problem is not immediately obvious, and might only manifest days or weeks later, or when you upgrade NixOS to the next version. The issue is with the second line,</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span><span class="kw">;</span></a></code></pre></div>
<p>where we import the system-wide <code>nixpkgs</code>. If we later update this by running</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="ex">nix-channel</span> --update</a></code></pre></div>
<p>and any of the transitive dependencies of our expression are updated, this will cause a rebuild because Nix will rightly detect that the inputs have changed.</p>
<p>This might be desirable in many cases, but for us it means a lot of waiting for no benefit. We can avoid this by pinning <code>nixpkgs</code> to a known-good commit. One way to do this is by setting the <code>NIX_PATH</code> environment variable, which is where Nix looks for the location of <code>nixpkgs</code>. We could do this as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1">$ <span class="va">NIX_PATH=</span>nixpkgs=<span class="ex">https</span>://github.com/NixOS/nixpkgs-channels/archive/2f6440eb09b7e6e3322720ac91ce7e2cdeb413f9.tar.gz nix-shell default.nix</a></code></pre></div>
<p>which takes advantage of the fact that Nix will transparently download a URL for <code>nixpkgs</code> instead of a filepath. This can quickly get tedious and is easy to forget though. Let’s pin <code>nixpkgs</code> directly in the expression:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="ex">inherit</span> (import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span>) <span class="ex">fetchFromGitHub</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="ex">nixpkgs</span> = fetchFromGitHub {</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="ex">owner</span>  = <span class="st">&quot;NixOS&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="ex">repo</span>   = <span class="st">&quot;nixpkgs-channels&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="fu">rev</span>    = <span class="st">&quot;2f6440eb09b7e6e3322720ac91ce7e2cdeb413f9&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="ex">sha256</span> = <span class="st">&quot;0vb7ikjscrp2rw0dfw6pilxqpjm50l5qg2x2mn1vfh93dkl2aan7&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  };</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="ex">pkgs</span> = import nixpkgs <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  <span class="ex">haskellPackages</span> = pkgs.haskellPackages.override {</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    <span class="ex">overrides</span> = self: super: {</a>
<a class="sourceLine" id="cb6-12" data-line-number="12">      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.4.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    };</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  };</a>
<a class="sourceLine" id="cb6-16" data-line-number="16"><span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="ex">buildInputs</span> = [ haskellPackages.pandoc ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">} <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>Now we use the system-wide <code>nixpkgs</code> only to provide one function, <code>fetchFromGitHub</code>, which we then use to download a specific version of <code>nixpkgs</code> that we import instead. This is easier to use but computing the <code>sha256</code> is frustrating. One trick to keep in mind is that <code>fetchFromGitHub</code> is equivalent to</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1">$ <span class="ex">nix-prefetch-url</span> --unpack https://github.com/<span class="op">&lt;</span>owner<span class="op">&gt;</span>/<span class="op">&lt;</span>repo<span class="op">&gt;</span>/archive/<span class="op">&lt;</span>rev<span class="op">&gt;</span>.tar.gz</a></code></pre></div>
<p>which outputs the correct hash at the end.</p>
<p>What happens if we want to update the pinned version? One workflow I’ve seen suggested is to update the <code>rev</code>, change one character in the <code>sha256</code>, and let the Nix error message tell you the correct hash to use. I think we can do better than this.</p>
<p><a href="https://github.com/expipiplus1">Joe Hermaszewski</a> has a handy tool called <a href="https://github.com/expipiplus1/update-nix-fetchgit">update-nix-fetchgit</a> that parses Nix files and automatically updates any <code>fetchFromGitHub</code> calls to the latest <code>master</code> revision and SHA256 of the repository. This is certainly a lot more convenient, but it doesn’t seem to work for repositories that don’t have a <code>master</code> branch or that we want to update to the <code>HEAD</code> of a different branch. This seems like an unimportant omission except that <code>nixpkgs-channels</code> is one such repository, and we want to update it to the <code>HEAD</code> of e.g. <code>nixos-18.03</code>.</p>
<p>So, we have a tedious manual process on one hand and a quick, efficient, and wrong process on the other. There has to be a better way!</p>
<p>I’ve settled on a solution that uses two extra files: an <code>updater</code> script and a <code>versions.json</code> that stores the arguments to <code>fetchFromGitHub</code> as JSON.</p>
<p>My <code>updater</code> script looks like</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">#! /usr/bin/env nix-shell</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">#! nix-shell -i bash</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="co">#! nix-shell -p curl jq nix</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">set</span> <span class="ex">-eufo</span> pipefail</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="va">FILE=$1</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="va">PROJECT=$2</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="va">BRANCH=${3:-</span>master<span class="va">}</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="va">OWNER=$(</span><span class="ex">jq</span> -r <span class="st">&#39;.[$project].owner&#39;</span> --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="va">REPO=$(</span><span class="ex">jq</span> -r <span class="st">&#39;.[$project].repo&#39;</span> --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13"></a>
<a class="sourceLine" id="cb8-14" data-line-number="14"><span class="va">REV=$(</span><span class="ex">curl</span> <span class="st">&quot;https://api.github.com/repos/</span><span class="va">$OWNER</span><span class="st">/</span><span class="va">$REPO</span><span class="st">/branches/</span><span class="va">$BRANCH</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="ex">jq</span> -r <span class="st">&#39;.commit.sha&#39;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="va">SHA256=$(</span><span class="ex">nix-prefetch-url</span> --unpack <span class="st">&quot;https://github.com/</span><span class="va">$OWNER</span><span class="st">/</span><span class="va">$REPO</span><span class="st">/archive/</span><span class="va">$REV</span><span class="st">.tar.gz&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16"><span class="va">TJQ=$(</span><span class="ex">jq</span> <span class="st">&#39;.[$project] = {owner: $owner, repo: $repo, rev: $rev, sha256: $sha256}&#39;</span> \</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">  --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  --arg owner <span class="st">&quot;</span><span class="va">$OWNER</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  --arg repo <span class="st">&quot;</span><span class="va">$REPO</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-20" data-line-number="20">  --arg rev <span class="st">&quot;</span><span class="va">$REV</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-21" data-line-number="21">  --arg sha256 <span class="st">&quot;</span><span class="va">$SHA256</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">  <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23"><span class="kw">[[</span> <span class="va">$?</span> <span class="ot">==</span> 0<span class="kw"> ]]</span> <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">${TJQ}</span><span class="st">&quot;</span> <span class="op">&gt;</span><span class="kw">|</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span></a></code></pre></div>
<p>It uses <code>curl</code> and <code>jq</code> to interact with the GitHub API and <code>nix</code> to calculate the appropriate hashes.</p>
<p>A simple <code>versions.json</code> looks like</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="dt">&quot;nixpkgs&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    <span class="dt">&quot;owner&quot;</span><span class="fu">:</span> <span class="st">&quot;NixOS&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    <span class="dt">&quot;repo&quot;</span><span class="fu">:</span> <span class="st">&quot;nixpkgs-channels&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    <span class="dt">&quot;rev&quot;</span><span class="fu">:</span> <span class="st">&quot;2f6440eb09b7e6e3322720ac91ce7e2cdeb413f9&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="dt">&quot;sha256&quot;</span><span class="fu">:</span> <span class="st">&quot;0vb7ikjscrp2rw0dfw6pilxqpjm50l5qg2x2mn1vfh93dkl2aan7&quot;</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="fu">}</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="fu">}</span></a></code></pre></div>
<p>And a Nix expression using these files looks like</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="ex">inherit</span> (import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span>) <span class="ex">fetchFromGitHub</span> lib<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="ex">versions</span> = lib.mapAttrs</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    <span class="kw">(</span><span class="ex">_</span>: fetchFromGitHub<span class="kw">)</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="kw">(</span><span class="ex">builtins.fromJSON</span> (builtins.readFile ./versions.json<span class="kw">)</span>);</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  <span class="co"># ./updater versions.json nixpkgs nixos-18.03</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="ex">pkgs</span> = import versions.nixpkgs <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  <span class="ex">haskellPackages</span> = pkgs.haskellPackages.override {</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    <span class="ex">overrides</span> = self: super: {</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.4.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    };</a>
<a class="sourceLine" id="cb10-13" data-line-number="13">  };</a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">  <span class="ex">buildInputs</span> = [ haskellPackages.pandoc ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16">} <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>And the command to update <code>nixpkgs</code> is</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" data-line-number="1">$ <span class="ex">./updater</span> versions.json nixpkgs nixos-18.03</a></code></pre></div>
<p>The reason I went with this approach is that <code>jq</code> is easier and friendlier to use than most of the Nix tooling available, and Nix fortunately has good JSON interoperability. I’ve toyed with the idea of rewriting my updater script in a language that is more robust (possibly Haskell with <a href="https://github.com/haskell-nix/hnix">hnix</a>) but I feel like it’s at a local maximum and I’m happy with the way it works for now.</p>
<p>I hope you find some of the ideas and/or code here useful the next time you’re wondering if you should pin <code>nixpkgs</code> and how to do so!</p>
<p><strong>Appendix 1</strong></p>
<p>If you use Nix 2.0 or newer, the <code>builtins.fetchTarball</code> command takes a <code>sha256</code> which means you can replace <code>fetchFromGitHub</code> and bootstrap without an existing <code>&lt;nixpkgs&gt;</code>! The following code snippet is identical to <code>fetchFromGitHub</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ex">fetcher</span> = { owner, repo, rev, sha256 }: <span class="ex">builtins.fetchTarball</span> {</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="ex">inherit</span> sha256<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="ex">url</span> = <span class="st">&quot;https://github.com/</span><span class="va">${owner}</span><span class="st">/</span><span class="va">${repo}</span><span class="st">/archive/</span><span class="va">${rev}</span><span class="st">.tar.gz&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">};</a></code></pre></div>
<p>Thanks to <a href="https://jarmac.org/">Ahmad Jarara</a>, <a href="https://twitter.com/@chrisczynski">Chris Stryczynski</a>, <a href="https://github.com/garry-cairns">Garry Cairns</a>, <a href="https://haroldtreen.com/">Harold Treen</a>, <a href="https://ren.zone/">Renzo Carbonara</a>, <a href="http://susanpotter.net/">Susan Potter</a>, and <a href="https://twitter.com/tpflug">Tobias Pflug</a> for comments and feedback!</p>
]]></summary>
</entry>
<entry>
    <title>IHaskell on CoCalc!</title>
    <link href="https://vaibhavsagar.com/blog/2018/04/08/ihaskell-cocalc/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/04/08/ihaskell-cocalc/index.html</id>
    <published>2018-04-08T00:00:00Z</published>
    <updated>2018-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on  8 April 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>
    
</div>

<p>IHaskell is now available on <a href="https://cocalc.com/">CoCalc</a>! I’m excited that there are even more options for creating your own IHaskell notebooks without having to install anything.</p>
<p>This is the result of a long collaboration with the lovely people at CoCalc, particularly <a href="https://wstein.org/">William Stein</a> and <a href="http://harald.schil.ly/">Harald Schilly</a>. I’d like to say a little about how this happened, but if you’re not interested you can stop reading here!</p>
<p>During the wonderful and magical time that was my batch at the <a href="https://www.recurse.com/scout/click?t=5ac465e5d3396a7e491e42afac4c5c90">Recurse Center</a>, I fulfilled a long-term goal of <a href="https://www.youtube.com/watch?v=wsNnP3we_R4">speaking at the NYHUG</a>. I was particularly enthusiastic about IHaskell, and <a href="http://gbaz.github.io/">Gershom</a> mentioned that people at SageMathCloud were interested in <a href="https://github.com/sagemathinc/cocalc/issues/125">getting it working</a> and offered to put me in touch.</p>
<p>I immediately encountered an issue where <a href="https://github.com/gibiansky/IHaskell/issues/694">IHaskell wasn’t handling all valid inputs</a> and complained about it on <a href="https://www.recurse.com/blog/112-how-rc-uses-zulip">Zulip</a>. I woke up the next day to find that <a href="https://twitter.com/horrorcheck">Libby Horacek</a> had gone ahead and <a href="https://github.com/gibiansky/IHaskell/pull/697">fixed the issue</a>. What a legend! This was also my first open-source contribution to a Haskell project ever.</p>
<p>I then tried the obvious thing, <code>stack build &amp;&amp; stack install</code> which resulted in a working notebook but an impossible deploy, because they needed the whole installation to be self-contained whereas Stack stores some things in <code>~/.stack</code> and other things in <code>&lt;project&gt;/.stack-work</code>. I (incorrectly) assumed that having <code>ihaskell</code> be a static binary would fix the issue, so then I spent a few weeks faffing around with <a href="https://www.fpcomplete.com/blog/2016/10/static-compilation-with-stack">this</a> which resulted in a static binary and made no difference otherwise.</p>
<p>Frustrated that my first attempt failed, I went silent for a while. My batch ended, I was unemployed for a few more months, I started a new role, and I moved to a new country. Because <a href="https://github.com/gibiansky/IHaskell/pull/716#issuecomment-305934463">I asked at the right time</a>, I became a maintainer of IHaskell and we finally got GHC 8 support! We also dropped GHC 7.10 support, which was <a href="https://github.com/gibiansky/IHaskell/pull/747">controversial</a>.</p>
<p>In the meantime SageMathCloud rebranded to CoCalc and revamped its infrastructure, and <a href="https://github.com/gibiansky/IHaskell/issues/731">they put the feelers out to try again</a>.</p>
<p>I saw that they were still running GHC 7.10 and went silent again, because I didn’t want to use an old version of IHaskell or have the discussion about installing a newer GHC just so I could fiddle some more. Instead, I worked on keeping IHaskell up-to-date and making it easier to use, with PRs for <a href="https://github.com/gibiansky/IHaskell/pull/735">GHC 8.2</a>, <a href="https://github.com/gibiansky/IHaskell/pull/817">GHC 8.4</a> and supporting installation with Nix.</p>
<p>Despite my best efforts, I was still getting lots of questions about installing IHaskell and I got fed up and <a href="https://twitter.com/vbhvsgr/status/975388161898561536">whinged about it on Twitter</a>. In response, Gershom DMed me to ask how the CoCalc stuff was progressing, after which I got back in touch and asked for a newer version of GHC. They obliged with GHC 8.4.</p>
<p>By this time we had realised that Stack wasn’t going to work, so we tried old-style Cabal and new-style Cabal, which both have similar issues with dependencies in <code>~/.cabal</code>. Finally Harald suggested using <code>cabal sandbox</code> and we were able to come up with a working, self-contained IHaskell install.</p>
<p>This would have been impossible without the patience and generosity of everyone involved. All told, it took almost a year and a half to get this working, which doesn’t come across in the <a href="https://twitter.com/cocalc_com/status/982650432928583680">announcement</a>.</p>
]]></summary>
</entry>
<entry>
    <title>IHaskell on mybinder.org</title>
    <link href="https://vaibhavsagar.com/blog/2018/03/31/ihaskell-mybinder/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/03/31/ihaskell-mybinder/index.html</id>
    <published>2018-03-31T00:00:00Z</published>
    <updated>2018-03-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 31 March 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p><a href="https://mybinder.org/">mybinder.org</a> is a website that will freely host a GitHub repository as a collection of interactive Jupyter notebooks. It has excellent built-in support for some of the more popular Jupyter kernels such as Python and Julia, but it also has support for building a <code>Dockerfile</code> of your choosing.</p>
<p>This means that getting an IHaskell installation up and running can be as simple as clicking a link, and I’m happy to report that I’ve gotten this working! You can <a href="https://mybinder.org/v2/gh/gibiansky/IHaskell/master">try it here</a>.</p>
<p>I started with the simplest thing I could think of, which was to install system dependencies and Jupyter to an Ubuntu container and then run <code>stack install ihaskell</code>. You can see the Dockerfile for that <a href="https://github.com/vaibhavsagar/ihaskell-mybinder/blob/6d093c5cd06cde77e13a5a98ae8ce093ba51fee9/Dockerfile">here</a>.</p>
<p>Once I had that working, my next step was to roll these changes into <a href="https://github.com/gibiansky/IHaskell/pull/848">IHaskell’s <code>Dockerfile</code></a> and now everyone can use IHaskell on mybinder.org!</p>
<p>I’ve also <a href="https://hub.docker.com/r/vaibhavsagar/ihaskell/">pushed an image to Docker Hub</a> that you can use as a base for your own repositories. A minimal example of a valid <code>Dockerfile</code> looks something like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">FROM</span> vaibhavsagar/ihaskell:4afa0aee339e</a></code></pre></div>
<p>Ideally I would also like to get this running with Nix, because that approach results in a much smaller image and is easily extensible just by editing <code>default.nix</code>. I have a small repo that <a href="https://github.com/vaibhavsagar/ihaskell-mybinder-nix">builds but doesn’t run on mybinder.org</a>, and I’ve <a href="https://github.com/jupyterhub/binder/issues/87">opened an issue</a>.</p>
<p>I’m pretty excited about what this means for the Jupyter ecosystem and IHaskell in particular, and I’m looking forward to seeing what other people do with this!</p>
]]></summary>
</entry>
<entry>
    <title>Faking Non-NixOS for Stack</title>
    <link href="https://vaibhavsagar.com/blog/2018/03/17/faking-non-nixos-stack/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/03/17/faking-non-nixos-stack/index.html</id>
    <published>2018-03-17T00:00:00Z</published>
    <updated>2018-03-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 17 March 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/nix/index.html">nix</a>
    
</div>

<p>I like most things about NixOS, but one thing I do not like is the way it integrates with <code>stack</code>. Nix’s own Haskell infrastructure works well enough that this is not an issue for my own projects, but sometimes I want to test that the Stack workflow is fine for people using less opinionated distros like Ubuntu.</p>
<p>Fortunately, Nixpkgs includes a handy tool called <code>buildFHSUserEnv</code> which will build a chroot wherein everything is laid out according to the <a href="https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard">Filesystem Hierarchy Standard</a> that most software is accustomed to. This means we can provide an environment with Stack and any dependencies and it will happily run.</p>
<p>Let’s walk through doing this for a package like <a href="https://github.com/gibiansky/IHaskell">IHaskell</a>. We begin by cloning the IHaskell repository and creating a <code>fhsenv.nix</code> with only <code>stack</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="ex">pkgs.haskellPackages.stack</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  ];</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">}</a></code></pre></div>
<p>Entering the chroot and running <code>stack build</code> gives us our first error:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="va">$(</span><span class="ex">nix-build</span> fhsenv.nix<span class="va">)</span><span class="ex">/bin/fhs</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ex">fhs-chrootenv</span>$ stack build</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ex">HttpExceptionRequest</span> Request {</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="ex">host</span>                 = <span class="st">&quot;raw.githubusercontent.com&quot;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="ex">port</span>                 = 443</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="ex">secure</span>               = True</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="ex">requestHeaders</span>       = []</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  <span class="ex">path</span>                 = <span class="st">&quot;/fpco/stackage-content/master/stack/stack-setup-2.yaml&quot;</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="ex">queryString</span>          = <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="ex">method</span>               = <span class="st">&quot;GET&quot;</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  <span class="ex">proxy</span>                = Nothing</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  <span class="ex">rawBody</span>              = False</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  <span class="ex">redirectCount</span>        = 10</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  <span class="ex">responseTimeout</span>      = ResponseTimeoutDefault</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  <span class="ex">requestVersion</span>       = HTTP/1.1</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">}</a>
<a class="sourceLine" id="cb2-17" data-line-number="17"> <span class="kw">(</span><span class="ex">ConnectionFailure</span> Network.BSD.getProtocolByName: does not exist (no such protocol name: tcp<span class="kw">)</span>)</a></code></pre></div>
<p>Looking through the Nixpkgs issue tracker for similar errors reveals that we need the <code>iana-etc</code> package. Let’s add it:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="ex">pkgs.haskellPackages.stack</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="ex">pkgs.iana-etc</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  ];</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">}</a></code></pre></div>
<p>Now it’ll start to download GHC, which takes forever for me. This is the wrong download though, so cancel it and let’s move on. More on this in a bit.</p>
<p>If the download had successfully completed, <code>stack</code> would then have complained that <code>make</code> was unavailable, so we add <code>gnumake</code>. Then it would have complained about the lack of Perl, a missing C compiler, missing <code>libgmp</code>, and no <code>pkg-config</code>, so we add those too. Then it progresses a lot further before it halts, complaining about <code>libtinfo</code> being missing. The closest thing we have is <code>ncurses</code>, so we add that too. Now our expression looks like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    <span class="ex">pkgs.iana-etc</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    <span class="ex">pkgs.haskellPackages.stack</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="ex">pkgs.gcc</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    <span class="ex">pkgs.gmp</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    <span class="ex">pkgs.gnumake</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">    <span class="ex">pkgs.perl</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">    <span class="ex">pkgs.pkgconfig</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">    <span class="ex">pkgs.ncurses</span></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  ];</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">}</a></code></pre></div>
<p>This prompts <code>stack</code> to download a different GHC, but the whole process should complete successfully now.</p>
<p>At this point, we’re in luck, because IHaskell has been configured to work with <code>stack --nix</code>, which means the dependencies <code>stack</code> needs are already specified under the <code>nix.packages</code> key in <code>stack.yaml</code>, and we can copy them into <code>fhsenv.nix</code> to speed up the process of building everything. At this point I found that header files in <code>/usr/include</code> weren’t being found, but this was easy to fix by specifying <code>C_INCLUDE_PATH</code> in the <code>profile</code> attribute. I’d recommend commenting out <code>ihaskell-widgets</code> at this point, because it takes an absurdly long time to compile and doesn’t seem to have any interesting dependencies. The complete <code>fhsenv.nix</code> for <code>stack build</code> and <code>stack test</code> looks like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="ex">pkgs.blas</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    <span class="ex">pkgs.cairo.dev</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    <span class="ex">pkgs.file</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="ex">pkgs.gcc</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="ex">pkgs.glib.dev</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    <span class="ex">pkgs.gmp</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    <span class="ex">pkgs.gnumake</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    <span class="ex">pkgs.haskellPackages.stack</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">    <span class="ex">pkgs.iana-etc</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">    <span class="ex">pkgs.liblapack</span></a>
<a class="sourceLine" id="cb5-16" data-line-number="16">    <span class="ex">pkgs.pango.dev</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    <span class="ex">pkgs.perl</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    <span class="ex">pkgs.pkgconfig</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">    <span class="ex">pkgs.ncurses</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">    <span class="ex">pkgs.zeromq</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">    <span class="ex">pkgs.zlib.dev</span></a>
<a class="sourceLine" id="cb5-22" data-line-number="22">  ];</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">  <span class="ex">profile</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb5-24" data-line-number="24">    <span class="bu">export</span> <span class="va">C_INCLUDE_PATH=</span>/usr/include:<span class="va">$C_INClUDE_PATH</span></a>
<a class="sourceLine" id="cb5-25" data-line-number="25">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">}</a></code></pre></div>
<p>Of course, building IHaskell is no fun if we can’t install it and see it in action. Providing the Jupyter notebook environment is an additional line:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="ex">pkgs.blas</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="ex">pkgs.cairo.dev</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    <span class="ex">pkgs.file</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">    <span class="ex">pkgs.gcc</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    <span class="ex">pkgs.glib.dev</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    <span class="ex">pkgs.gmp</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    <span class="ex">pkgs.gnumake</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">    <span class="ex">pkgs.haskellPackages.stack</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14">    <span class="ex">pkgs.iana-etc</span></a>
<a class="sourceLine" id="cb6-15" data-line-number="15">    <span class="ex">pkgs.liblapack</span></a>
<a class="sourceLine" id="cb6-16" data-line-number="16">    <span class="ex">pkgs.pango.dev</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">    <span class="ex">pkgs.perl</span></a>
<a class="sourceLine" id="cb6-18" data-line-number="18">    <span class="ex">pkgs.pkgconfig</span></a>
<a class="sourceLine" id="cb6-19" data-line-number="19">    <span class="kw">(</span><span class="ex">pkgs.python3.withPackages</span> (ps: [ ps.jupyter ps.notebook ]<span class="kw">)</span>)</a>
<a class="sourceLine" id="cb6-20" data-line-number="20">    <span class="ex">pkgs.ncurses</span></a>
<a class="sourceLine" id="cb6-21" data-line-number="21">    <span class="ex">pkgs.zeromq</span></a>
<a class="sourceLine" id="cb6-22" data-line-number="22">    <span class="ex">pkgs.zlib.dev</span></a>
<a class="sourceLine" id="cb6-23" data-line-number="23">  ];</a>
<a class="sourceLine" id="cb6-24" data-line-number="24">  <span class="ex">profile</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb6-25" data-line-number="25">    <span class="bu">export</span> <span class="va">C_INCLUDE_PATH=</span>/usr/include:<span class="va">$C_INClUDE_PATH</span></a>
<a class="sourceLine" id="cb6-26" data-line-number="26">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb6-27" data-line-number="27">}</a></code></pre></div>
<p>and we can install and run IHaskell as usual:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ex">fhs-chrootenv</span>$ stack build</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ex">fhs-chrootenv</span>$ stack exec -- ihaskell install --stack</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ex">fhs-chrootenv</span>$ stack exec -- jupyter notebook</a></code></pre></div>
<p>Cool!</p>
<p>This expression is available <a href="https://github.com/vaibhavsagar/experiments/blob/master/stack-env-nix/ihaskell.nix">on GitHub</a>.</p>
]]></summary>
</entry>
<entry>
    <title>Revisiting 'Monadic Parsing in Haskell'</title>
    <link href="https://vaibhavsagar.com/blog/2018/02/04/revisiting-monadic-parsing-haskell/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/02/04/revisiting-monadic-parsing-haskell/index.html</id>
    <published>2018-02-04T00:00:00Z</published>
    <updated>2018-02-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on  4 February 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/monads/index.html">monads</a>
    
</div>

<p><em>Translated to <a href="http://clipartmag.com/ru-revisiting-monadic-parsing-haskell">Russian</a> by <a href="http://clipartmag.com/">Clipart Team</a></em></p>
<p><a href="http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf">‘Monadic Parsing in Haskell’</a> is a short paper that laid the groundwork for libraries like Parsec and Attoparsec. Although it was published in 1998 (almost 20 years ago!) it has aged gracefully and the code samples will run with almost no changes. However, the state of the art has advanced since then and I think the use of modern Haskell can make this material simpler to follow and implement.</p>
<p>Monadic parsing in Haskell is what sold me on all three. Before Haskell my experiences with parsing had involved buggy regexes for lexers and wrangling tools like <code>bison</code> and <code>flex</code>, and although I’d heard that Haskell was good for parsing I couldn’t see how this could be the case when I couldn’t find any robust regex libraries! An aside in some documentation pointed me to Attoparsec and when I saw the <a href="https://github.com/bos/attoparsec/blob/master/examples/RFC2616.hs">example RFC2616 parser</a> it seemed like a magic trick. How could it be so small? After a few weeks of trying it myself I was convinced and I’ve never looked back. This was the first application of monads I encountered that actually made my life simpler, and I started to realise that there was more to monads than smugness and being inaccessible to newcomers.</p>
<p>The first change I want to make is the type definition. The paper uses the type</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> [(a,<span class="dt">String</span>)])</a></code></pre></div>
<p>and although this is a famous enough definition that it has <a href="http://www.willamette.edu/~fruehr/haskell/seuss.html">its own rhyme</a>, I think the flexibility of lists is wasted here. The authors don’t use it, and instead define a ‘deterministic choice’ operator <code>(+++)</code> that gives at most one result and use that everywhere instead. There is already a perfectly good datatype in Haskell for lists of at most one element, <code>Maybe</code>, so I’ll use that instead of <code>[]</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>))</a></code></pre></div>
<p>If we rename <code>String</code> to <code>s</code> and <code>Maybe</code> to <code>m</code>, a more interesting pattern is revealed:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Parser</span> s m a <span class="fu">=</span> <span class="dt">Parser</span> (s <span class="ot">-&gt;</span> m (a, s))</a></code></pre></div>
<p>This is <a href="https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-State-Strict.html#t:StateT"><code>StateT</code></a>! Recognising this pattern makes instance definitions much easier, so much easier in fact that GHC can do it for us automatically with <code>-XGeneralizedNewtypeDeriving</code>! For completeness I will resist the temptation to do this, but you can try it yourself with</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> (<span class="dt">StateT</span> <span class="dt">String</span> <span class="dt">Maybe</span> a) <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Alternative</span>, <span class="dt">Monad</span>)</a></code></pre></div>
<p>The second change is also for completeness: the authors jump straight into the <code>Monad</code> instance without defining <code>Functor</code> and <code>Applicative</code> first. To be fair, the <code>Applicative</code> abstraction hadn’t been <a href="http://www.staff.city.ac.uk/~ross/papers/Applicative.html">discovered</a> yet, and this is also the reason why the authors define <code>mzero</code> and <code>mplus</code> (which they call <code>(++)</code>) instead of the more general <code>Alternative</code> methods <code>empty</code> and <code>(&lt;|&gt;)</code>. Because of our <code>Maybe</code> change, defining <code>Alternative</code> means I won’t need to bother with their <code>(+++)</code>.</p>
<p>Finally, I’ll try to avoid do-notation where possible in favour of a more Applicative style using e.g. <code>&lt;*&gt;</code> (which can be pronounced ‘splat’ if you don’t already have a name for it) because most of these parsers don’t require it.</p>
<p>Let’s begin!</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Control.Applicative</span> (<span class="dt">Alternative</span>(..))</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Control.Monad.Trans.State.Strict</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Control.Monad</span> (guard)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Char</span> (isSpace, isDigit, ord)</a></code></pre></div>
<p>For convenience I’ve defined an <code>unParser</code> that unwraps a <code>Parser a</code> to its underlying <code>StateT String Maybe a</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> {<span class="ot"> unParser ::</span> <span class="dt">StateT</span> <span class="dt">String</span> <span class="dt">Maybe</span> a }</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">runParser <span class="fu">=</span> runStateT <span class="fu">.</span> unParser</a></code></pre></div>
<p><code>fmap</code> is as simple as unwrapping the <code>Parser</code> and using the underlying <code>StateT</code>’s <code>fmap</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Parser</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    fmap f p <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> f <span class="fu">&lt;$&gt;</span> unParser p</a></code></pre></div>
<p>More unwrapping for <code>Applicative</code> and <code>Alternative</code>.</p>
<p>The <a href="https://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:Alternative"><code>Alternative</code></a> typeclass allows us to express the idea of running one parser or another parser, resulting in the first successful parse. <code>empty</code> handles the case where both parsers fail, and <code>(&lt;|&gt;)</code> (which can be pronounced ‘alt’) performs the alternation. This is convenient enough on its own, but <code>Alternative</code> also provides <code>many</code> and <code>some</code> which correspond exactly to <code>many</code> and <code>many1</code> from the paper:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- many v = some v &lt;|&gt; pure []</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">-- some v = (:) &lt;$&gt; v &lt;*&gt; many v</span></a></code></pre></div>
<p>but only after replacing <code>[]</code> with <code>Maybe</code> like I’ve done here so that <code>(&lt;|&gt;)</code> corresponds to <code>(+++)</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Parser</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    pure a  <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> pure a</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="ot">    (&lt;*&gt;) ::</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    f <span class="fu">&lt;*&gt;</span> a <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> unParser f <span class="fu">&lt;*&gt;</span> unParser a</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Parser</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="ot">    empty ::</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    empty   <span class="fu">=</span> <span class="dt">Parser</span> empty</a>
<a class="sourceLine" id="cb9-10" data-line-number="10"><span class="ot">    (&lt;|&gt;) ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    a <span class="fu">&lt;|&gt;</span> b <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> unParser a <span class="fu">&lt;|&gt;</span> unParser b</a></code></pre></div>
<p>The <code>Monad</code> definition is slightly more interesting, because we have to manually construct the <code>StateT</code> value, but this also boils down to unwrapping and rewrapping.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Parser</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    (&gt;&gt;=) ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> b</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    a <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">        (a&#39;, s&#39;) <span class="ot">&lt;-</span> runParser a s</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">        runParser (f a&#39;) s&#39;</a></code></pre></div>
<p>Notice that <code>anyChar</code> is the only function below that manually constructs a <code>Parser</code>, and <code>satisfy</code> is the only one that requires the <code>Monad</code> interface.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">anyChar ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">anyChar <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">.</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    []     <span class="ot">-&gt;</span> empty</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    (c<span class="fu">:</span>cs) <span class="ot">-&gt;</span> pure (c, cs)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="ot">satisfy ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">satisfy pred <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">    c <span class="ot">&lt;-</span> anyChar</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    guard <span class="fu">$</span> pred c</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    pure c</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"><span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">char <span class="fu">=</span> satisfy <span class="fu">.</span> (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb11-14" data-line-number="14"></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb11-16" data-line-number="16">string []     <span class="fu">=</span> pure []</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">string (c<span class="fu">:</span>cs) <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> char c <span class="fu">&lt;*&gt;</span> string cs</a></code></pre></div>
<p>Again, <code>many</code> and <code>many1</code> don’t need to be defined because they are provided for free!</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">sepBy ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">sepBy p sep <span class="fu">=</span> (p <span class="ot">`sepBy1`</span> sep) <span class="fu">&lt;|&gt;</span> pure []</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="ot">sepBy1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">sepBy1 p sep <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> p <span class="fu">&lt;*&gt;</span> many (sep <span class="fu">*&gt;</span> p)</a></code></pre></div>
<p>These are almost identical to the definitions in the paper. I’ve included <code>chainr</code> for completeness.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">chainl ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">chainl p op a <span class="fu">=</span> (p <span class="ot">`chainl1`</span> op) <span class="fu">&lt;|&gt;</span> pure a</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="ot">chainl1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">chainl1 p op <span class="fu">=</span> p <span class="fu">&gt;&gt;=</span> rest</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    <span class="kw">where</span> </a>
<a class="sourceLine" id="cb13-7" data-line-number="7">        rest a <span class="fu">=</span> (<span class="kw">do</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">            f <span class="ot">&lt;-</span> op</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">            b <span class="ot">&lt;-</span> p</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">            rest (f a b)) <span class="fu">&lt;|&gt;</span> pure a</a>
<a class="sourceLine" id="cb13-11" data-line-number="11"></a>
<a class="sourceLine" id="cb13-12" data-line-number="12"><span class="ot">chainr ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">chainr p op a <span class="fu">=</span> (p <span class="ot">`chainr1`</span> op) <span class="fu">&lt;|&gt;</span> pure a</a>
<a class="sourceLine" id="cb13-14" data-line-number="14"></a>
<a class="sourceLine" id="cb13-15" data-line-number="15"><span class="ot">chainr1 ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">chainr1 p op <span class="fu">=</span> scan</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18">        scan   <span class="fu">=</span> p <span class="fu">&gt;&gt;=</span> rest</a>
<a class="sourceLine" id="cb13-19" data-line-number="19">        rest a <span class="fu">=</span> (<span class="kw">do</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20">            f <span class="ot">&lt;-</span> op</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">            b <span class="ot">&lt;-</span> scan</a>
<a class="sourceLine" id="cb13-22" data-line-number="22">            rest (f a b)) <span class="fu">&lt;|&gt;</span> pure a</a></code></pre></div>
<p>The only difference here is the replacement of <code>(&gt;&gt;)</code> with <code>(*&gt;)</code>. These have the same effect, except that the latter works on <code>Applicative</code>s and also comes with a counterpart <code>(&lt;*)</code>. When writing parsers I find these especially useful because they allow me to combine multiple parsers together when I only care about the output of one of them, e.g. <code>ignored *&gt; ignored *&gt; value &lt;* ignored</code>. The calculator example uses this in <code>factor</code>.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">space ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">space <span class="fu">=</span> many (satisfy isSpace)</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="ot">token ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">token p <span class="fu">=</span> p <span class="fu">&lt;*</span> space</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="ot">symbol ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">symbol <span class="fu">=</span> token <span class="fu">.</span> string</a>
<a class="sourceLine" id="cb14-9" data-line-number="9"></a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="ot">apply ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb14-11" data-line-number="11">apply p <span class="fu">=</span> runParser (space <span class="fu">*&gt;</span> p)</a></code></pre></div>
<p>The calculator example is almost unchanged.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">expr, term, factor,<span class="ot"> digit ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">expr   <span class="fu">=</span> term   <span class="ot">`chainl1`</span> addop</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">term   <span class="fu">=</span> factor <span class="ot">`chainl1`</span> mulop</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">factor <span class="fu">=</span> digit <span class="fu">&lt;|&gt;</span> (symbol <span class="st">&quot;(&quot;</span> <span class="fu">*&gt;</span> expr <span class="fu">&lt;*</span> symbol <span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">digit  <span class="fu">=</span> subtract (ord <span class="ch">&#39;0&#39;</span>) <span class="fu">.</span> ord <span class="fu">&lt;$&gt;</span> token (satisfy isDigit)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">addop,<span class="ot"> mulop ::</span> <span class="dt">Parser</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">addop <span class="fu">=</span> (symbol <span class="st">&quot;+&quot;</span> <span class="fu">*&gt;</span> pure (<span class="fu">+</span>)) <span class="fu">&lt;|&gt;</span> (symbol <span class="st">&quot;-&quot;</span> <span class="fu">*&gt;</span> pure (<span class="fu">-</span>))</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">mulop <span class="fu">=</span> (symbol <span class="st">&quot;*&quot;</span> <span class="fu">*&gt;</span> pure (<span class="fu">*</span>)) <span class="fu">&lt;|&gt;</span> (symbol <span class="st">&quot;/&quot;</span> <span class="fu">*&gt;</span> pure (div))</a></code></pre></div>
<p>Finally, the payoff!</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">runParser expr <span class="st">&quot;(1 + 2 * 4) / 3 + 5&quot;</span></a></code></pre></div>
<pre><code>Just (8,&quot;&quot;)</code></pre>
<p>What have we gained in 20 years? With only minor changes, the code is more composable and uses finer-grained abstractions. For example, if we change our minds about replacing <code>[]</code> with <code>Maybe</code>, we can switch it back and would only have to update the type signature of <code>apply</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">apply ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(a, <span class="dt">String</span>)]</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">apply p <span class="fu">=</span> runParser (space <span class="fu">*&gt;</span> p) <span class="co">-- the implementation stays the same!</span></a></code></pre></div>
<p>If we want better error messages, we could use a type such as <code>Either String</code> to keep track of locations and error messages. The <a href="http://hackage.haskell.org/package/yoctoparsec"><code>yoctoparsec</code></a> library takes this even further, allowing to you to choose your own stream type.</p>
<p>Another big difference is the <code>Applicative</code> family of functions, which we can leverage whenever we don’t have to branch on a previously parsed value (which turns out to be surprisingly often). I’m a huge fan of the <code>x &lt;$&gt; y &lt;*&gt; z</code> and the <code>ignored *&gt; value &lt;* ignored</code> idioms and I think it’s useful to be able to parse this way.</p>
<p>Otherwise, the code is largely the same and I think it’s pretty incredible that so little has changed in 20 years! This code is available as an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/revisiting-monadic-parsing-haskell/Parser.ipynb">IHaskell notebook</a> if you would like to experiment with it yourself.</p>
<p><em>Edit: I just found <a href="https://lirias.kuleuven.be/bitstream/123456789/499951/1/main.pdf">‘From monoids to near-semirings: the essence of <code>MonadPlus</code> and <code>Alternative</code>’</a>, which demonstrates how my <code>Maybe</code>-based parser doesn’t strictly obey the <code>Alternative</code> laws. Something to keep in mind if you plan to use it or something like it!</em></p>
<p>Thanks to <a href="https://github.com/cqfd">Alan O’Donnell</a>, <a href="https://blogs.ncl.ac.uk/andreymokhov/">Andrey Mokhov</a>, <a href="https://anniecherkaev.com/">Annie Cherkaev</a>, <a href="https://jvns.ca/">Julia Evans</a>, and <a href="https://github.com/rampion/">Noah Luck Easterly</a> for comments and feedback!</p>
]]></summary>
</entry>
<entry>
    <title>Building Static Haskell Binaries with Nix</title>
    <link href="https://vaibhavsagar.com/blog/2018/01/03/static-haskell-nix/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/01/03/static-haskell-nix/index.html</id>
    <published>2018-01-03T00:00:00Z</published>
    <updated>2018-01-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on  3 January 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/nix/index.html">nix</a>, <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p><em>Most of the instructions in this blog post have been improved on in Niklas Hambüchen’s <a href="https://github.com/nh2/static-haskell-nix" class="uri">https://github.com/nh2/static-haskell-nix</a>, so if you’re primarily interesting in getting things working quickly I would recommend looking there first.</em></p>
<p><em>Skip to the end for a faster and easier way of getting this working. All you have to do is clone the linked repo and run <code>nix-build default.nix</code>!</em></p>
<p>The section of the Nixpkgs manual that talks about <a href="https://nixos.org/nixpkgs/manual/#creating-statically-linked-binaries">creating statically linked binaries</a> with Haskell ends with the caveat:</p>
<blockquote>
<p>It’s important to realize, however, that most system libraries in Nix are built as shared libraries only, i.e. there is just no static library available that Cabal could link!</p>
</blockquote>
<p>That sounds like a challenge. Especially when doing it on other platforms is <a href="http://www.kuznero.com/posts/haskell/building-statically-linked-binaries.html">so easy</a>.</p>
<p>On other platforms, building a static binary is meant to be as simple as</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="ex">cabal</span> update</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">$ <span class="ex">cabal</span> install --only-dependencies</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">$ <span class="ex">cabal</span> configure --disable-executable-dynamic --disable-shared --ghc-option=-optl=-static</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">$ <span class="ex">cabal</span> build</a></code></pre></div>
<p>with the magic happening in the second step. On Nix, we do in fact have the necessary static libraries and we can provide them as build inputs but keeping track of the library paths gets hairy quickly. Fortunately Nix has an escape hatch called <code>buildFHSUserEnv</code> that we can use to simulate an environment that <code>cabal</code> is more familiar with.</p>
<p>Let’s put it through its paces by building a simple Scotty web app:</p>
<p><em>blank-me-up.cabal</em></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">name<span class="fu">:</span>                blank<span class="fu">-</span>me<span class="fu">-</span>up</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">version<span class="fu">:</span>             <span class="fl">0.1</span><span class="fu">.</span><span class="fl">0.0</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">license<span class="fu">:</span>             <span class="dt">BSD3</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">build<span class="fu">-</span><span class="kw">type</span><span class="fu">:</span>          <span class="dt">Simple</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">cabal<span class="fu">-</span>version<span class="fu">:</span>       <span class="fu">&gt;=</span><span class="fl">1.10</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">executable blank<span class="fu">-</span>me<span class="fu">-</span>up</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  main<span class="fu">-</span>is<span class="fu">:</span>             Main.hs</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  build<span class="fu">-</span>depends<span class="fu">:</span>       base <span class="fu">&gt;=</span><span class="fl">4.9</span> <span class="fu">&amp;&amp;</span> <span class="fu">&lt;</span><span class="dv">5</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">                     , scotty</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  default<span class="fu">-</span>language<span class="fu">:</span>    <span class="dt">Haskell2010</span></a></code></pre></div>
<p><em>Main.hs</em></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"> <span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Web.Scotty</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Data.Monoid</span> (mconcat)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">main <span class="fu">=</span> scotty <span class="dv">3000</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    get <span class="st">&quot;/:word&quot;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">        beam <span class="ot">&lt;-</span> param <span class="st">&quot;word&quot;</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">        html <span class="fu">$</span> mconcat [<span class="st">&quot;&lt;h1&gt;Scotty, &quot;</span>, beam, <span class="st">&quot; me up!&lt;/h1&gt;&quot;</span>]</a></code></pre></div>
<p>We create <code>static.nix</code>:</p>
<p><em>static.nix</em></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">in</span> <span class="ex">pkgs.buildFHSUserEnv</span> {</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="ex">name</span> = <span class="st">&quot;fhs&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="ex">targetPkgs</span> = pkgs: [</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    <span class="kw">(</span><span class="ex">pkgs.haskellPackages.ghcWithPackages</span> (p: with p<span class="kw">;</span><span class="bu"> [</span> cabal-install ]))</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    pkgs.gmp5.static</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    pkgs.glibc.static</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    pkgs.zlib.static</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    pkgs.zlib.dev</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  ];</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">}</a></code></pre></div>
<p>This defines a chroot where statically linked versions of <code>gmp</code>, <code>glibc</code>, and <code>zlib</code> are available, as well as <code>zlib.h</code>. We enter this environment by running</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1">$ <span class="va">$(</span><span class="ex">nix-build</span> static.nix<span class="va">)</span><span class="ex">/bin/fhs</span></a></code></pre></div>
<p>and then we can run the commands above with only slight modifications:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1">$ <span class="ex">cabal</span> update</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">$ <span class="ex">cabal</span> install --only-dependencies --extra-include-dirs=/usr/include --extra-lib-dirs=/usr/lib</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">$ <span class="ex">cabal</span> configure --disable-executable-dynamic --disable-shared --ghc-option=-optl=-pthread --ghc-option=-optl=-static --ghc-option=-optl=-L/usr/lib</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">$ <span class="ex">cabal</span> build</a></code></pre></div>
<p>The difference is the extra options passed to the linker. After the last command, I get a whole bunch of warnings about</p>
<pre><code>&quot;Using &#39;&lt;function&gt;&#39; in statically linked applications requires at runtime the shared libraries from the glibc version used for linking&quot;</code></pre>
<p>which is definitely something to watch out for if you plan on deploying these executables to a machine that might be running a different version of <code>glibc</code>. A more robust solution is to link against e.g. <code>musl</code> instead of <code>glibc</code>, as Niklas Hambüchen has done <a href="https://github.com/nh2/static-haskell-nix">here</a>. You can confirm that the executable has been statically linked by running</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1">$ <span class="fu">ldd</span> dist/build/blank-me-up/blank-me-up</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">        <span class="ex">not</span> a dynamic executable</a></code></pre></div>
<p>I’ve made this project available <a href="https://github.com/vaibhavsagar/experiments/tree/master/static-haskell-nix">here</a> if you’d like to tweak it. Since this was relatively straightforward, I think it might be possible to do this without <code>buildFHSUserEnv</code>. Maybe I will try that next.</p>
<p>Happy static linking!</p>
<p><strong>Edit 1:</strong> This turned out to be fairly easy. I took the output of</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" data-line-number="1">$ <span class="ex">cabal2nix</span> --shell . <span class="op">&gt;</span> default.nix</a></code></pre></div>
<p>and changed <code>enableSharedExecutables</code>, <code>enableSharedLibraries</code>, and <code>configureFlags</code> as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ex">enableSharedExecutables</span> = false<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ex">enableSharedLibraries</span> = false<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ex">configureFlags</span> = [</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="st">&quot;--ghc-option=-optl=-static&quot;</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="st">&quot;--ghc-option=-optl=-pthread&quot;</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  <span class="st">&quot;--ghc-option=-optl=-L</span><span class="va">${pkgs</span><span class="er">.gmp6.override { withStatic </span><span class="va">=</span> true; <span class="va">}</span><span class="st">}/lib&quot;</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="st">&quot;--ghc-option=-optl=-L</span><span class="va">${pkgs</span><span class="er">.zlib.static</span><span class="va">}</span><span class="st">/lib&quot;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  <span class="st">&quot;--ghc-option=-optl=-L</span><span class="va">${pkgs</span><span class="er">.glibc.static</span><span class="va">}</span><span class="st">/lib&quot;</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">];</a></code></pre></div>
<p>This is also available in the linked repository, and you can pin <code>nixpkgs</code> as follows to get my exact build:</p>
<pre><code>$ nix-build -I nixpkgs=https://github.com/NixOS/nixpkgs-channels/archive/08d245eb31a3de0ad73719372190ce84c1bf3aee.tar.gz default.nix</code></pre>
<p><strong>Edit 2</strong>: <a href="https://github.com/angerman">Moritz Angermann</a> and <a href="https://github.com/nh2">Niklas Hambüchen</a> improved these instructions to be more robust. Thanks Moritz and Niklas!</p>
]]></summary>
</entry>
<entry>
    <title>I Haskell a Git</title>
    <link href="https://vaibhavsagar.com/blog/2017/08/13/i-haskell-a-git/index.html" />
    <id>https://vaibhavsagar.com/blog/2017/08/13/i-haskell-a-git/index.html</id>
    <published>2017-08-13T00:00:00Z</published>
    <updated>2017-08-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 13 August 2017
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/git/index.html">git</a>
    
</div>

<p>I struggled with Git for a long time, and every time I thought I had finally made sense of it, I would accidentally delete a repository or mess up a branch, causing me to question my grasp of what I was doing. I found it very difficult to form a mental model of the tool from the proliferation of seemingly endless command line flags that I had to use to achieve anything meaningful, and the cryptic errors that would inevitably result.</p>
<p>When I finally thought I understood what was going on, I offered to give a talk on it to the local functional group, because Git is functional, right? The co-organisers explained that it wouldn’t be an interesting or useful talk, but a talk on implementing Git in Haskell would be very welcome.</p>
<p>That was enough motivation to start working on a <a href="https://github.com/vaibhavsagar/duffer">Git library</a>, and it turns out that understanding Git from the inside out is far, far easier than whatever I was trying to do earlier. This blog post is my attempt to share that comfort and understanding with you.</p>
<p>I’ve chosen to write this as an IHaskell notebook that is available <a href="https://github.com/vaibhavsagar/notebooks/tree/master/git-from-scratch">here</a>, and I’ve included a <code>default.nix</code> to make things easier if you have Nix installed. You should be able to run</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="va">$(</span><span class="ex">nix-build</span> --no-out-link<span class="va">)</span><span class="ex">/bin/ihaskell-notebook</span></a></code></pre></div>
<p>to open a Jupyter notebook environment with all the dependencies you’ll need to follow along.</p>
<p>GHCi has a handy Vim-inspired feature where a command prefixed with <code>:!</code> is run in the shell, and IHaskell supports this as well, so I’ll be using that heavily to keep everything self-contained.</p>
<p>Let’s start by picking a Git repository. I picked Ethan Schoonover’s <a href="https://github.com/altercation/solarized/">solarized</a> because it’s nontrivial, well-known, and was last updated in 2011, so I’m confident that the hashes here won’t go out of date.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co">-- Start with a clean slate.</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="fu">:!</span><span class="kw">if</span> [ <span class="fu">-</span>d solarized<span class="fu">/</span> ]; <span class="kw">then</span> rm <span class="fu">-</span>rf solarized; fi</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="fu">:!</span>git clone https<span class="fu">://</span>github<span class="fu">.</span>com<span class="fu">/</span>altercation<span class="fu">/</span>solarized</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="fu">:!</span>cd solarized</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="fu">:!</span>git show <span class="co">--format=raw -s</span></a></code></pre></div>
<pre><code>Cloning into &#39;solarized&#39;...



commit e40cd4130e2a82f9b03ada1ca378b7701b1a9110
tree ecd0e58d6832566540a30dfd4878db518d5451d0
parent ab3c5646b41de1b6d95782371289db585ba8aa85
author Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700
committer Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700

    add tmux by @seebi!</code></pre>
<p><code>git show</code> displays the latest commit on the current branch, <code>--format=raw</code> shows it in raw format, and the <code>-s</code> flag suppresses the diff output, which (as we’ll see later) isn’t part of the commit.</p>
<p>The first thing we have to address is the fact that Git has two storage formats: loose objects and packfiles. In the loose object format, each Git object is stored in its own file under the <code>.git/objects</code> directory. In the packfile format, many Git objects are stored in a file under the <code>.git/objects/pack</code> directory with an associated pack index to make lookups feasible.</p>
<p>Loose objects are used below a certain size threshold as an on-disk format, and packfiles are used as a space optimisation and to transfer files over the network because transferring one large file has less overhead than transferring lots of small files. Loose objects are easier to work with, so I’m going to convert the packfiles into loose objects.</p>
<p>If you’d like to learn more about packfiles, my favourite resource is Aditya Mukerjee’s <a href="https://codewords.recurse.com/issues/three/unpacking-git-packfiles">Unpacking Git packfiles</a>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- `git unpack-objects` doesn&#39;t do any unpacking if the objects already exist in the repository</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="fu">:!</span>mv <span class="fu">.</span>git<span class="fu">/</span>objects<span class="fu">/</span>pack<span class="fu">/*</span> <span class="fu">.</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co">-- Stream the packfiles to `git unpack-objects`, which splits them into individual objects and stores them appropriately</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="fu">:!</span>cat <span class="fu">*.</span>pack <span class="fu">|</span> git unpack<span class="fu">-</span>objects</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">-- We don&#39;t need the packfiles any more</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="fu">:!</span>rm <span class="fu">-</span>rf pack<span class="fu">-*</span></a></code></pre></div>
<p>Okay, the packfiles are gone and there are only loose objects now.</p>
<p><code>git show</code> is an example of a ‘porcelain’ command for users to interact with, as opposed to a ‘plumbing’ command that is more low-level and meant for Git itself to use under the hood. The latest commit on the current branch is known as the <code>HEAD</code> commit, and we should be able to use <code>git cat-file -p</code> to get essentially the same output as before (the <code>-p</code> flag means ‘pretty-print’).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">:!</span>git cat<span class="fu">-</span>file <span class="fu">-</span>p <span class="dt">HEAD</span></a></code></pre></div>
<pre><code>tree ecd0e58d6832566540a30dfd4878db518d5451d0
parent ab3c5646b41de1b6d95782371289db585ba8aa85
author Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700
committer Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700

add tmux by @seebi!</code></pre>
<p><code>HEAD</code> is in fact a file that lives at <code>.git/HEAD</code>. Let’s view its contents.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">:!</span>cat <span class="fu">.</span>git<span class="fu">/</span><span class="dt">HEAD</span></a></code></pre></div>
<pre><code>ref: refs/heads/master</code></pre>
<p>This is essentially a symlink in text. <code>refs/heads/master</code> refers to <code>.git/refs/heads/master</code>. What are its contents?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">:!</span>cat <span class="fu">.</span>git<span class="fu">/</span>refs<span class="fu">/</span>heads<span class="fu">/</span>master</a></code></pre></div>
<pre><code>e40cd4130e2a82f9b03ada1ca378b7701b1a9110</code></pre>
<p>Okay, no more pointers! This is a SHA1 hash representing the commit we want. One last <code>git cat-file -p</code>…</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">:!</span>git cat<span class="fu">-</span>file <span class="fu">-</span>p e40cd4130e2a82f9b03ada1ca378b7701b1a9110</a></code></pre></div>
<pre><code>tree ecd0e58d6832566540a30dfd4878db518d5451d0
parent ab3c5646b41de1b6d95782371289db585ba8aa85
author Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700
committer Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700

add tmux by @seebi!</code></pre>
<p>As expected, we get the same output as before. On to something different: <code>e40cd4130e2a82f9b03ada1ca378b7701b1a9110</code> is a reference to an object stored at <code>.git/objects/e4/0cd4130e2a82f9b03ada1ca378b7701b1a9110</code>. The first two characters of the hash are the directory name and the 38 remaining characters are the file name underneath that directory. It’s worth pointing out that all objects are stored in this format, and there’s no separation between object types or anything like that.</p>
<p>This unusual directory structure was chosen as a tradeoff between the number of directories under <code>.git/objects</code> and the number of files under each of those directories. One approach might have been to use 40-character file names and put all objects under <code>.git/objects</code>. However, some filesystems have operations that are <code>O(n)</code> in the number of files in a directory, and working with large repositories would get very slow in this case. Another approach would have been to use the first character of the hash as the directory name, which would lead to at most 16 directories under <code>.git/objects</code>. Git settled on the first two characters, which gives us at most 256 directories.</p>
<p>Let’s confirm that the file does exist, and then look at its contents.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">:!</span>ls <span class="fu">.</span>git<span class="fu">/</span>objects<span class="fu">/</span>e4<span class="fu">/</span>0cd4130e2a82f9b03ada1ca378b7701b1a9110</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="fu">:!</span>cat <span class="fu">.</span>git<span class="fu">/</span>objects<span class="fu">/</span>e4<span class="fu">/</span>0cd4130e2a82f9b03ada1ca378b7701b1a9110 <span class="fu">|</span> xxd</a></code></pre></div>
<pre><code>.git/objects/e4/0cd4130e2a82f9b03ada1ca378b7701b1a9110



00000000: 7801 958e 6d6a 0331 0c44 fbdb a750 0ed0  x...mj.1.D...P..
00000010: e22f d95a 2825 f40c b980 b452 e942 9d0d  ./.Z(%.....R.B..
00000020: ae53 92db d790 5ea0 bf06 1ec3 9b59 f7d6  .S....^......Y..
00000030: b601 31d3 d3e8 6660 ab7a 43d2 4229 6229  ..1...f`.zC.B)b)
00000040: 983d 27af 1f9a a992 0a06 52cc 18d4 bb0b  .=&#39;.......R.....
00000050: 773b 0f60 492b 965c 2407 b520 4517 ac14  w;.`I+.\$.. E...
00000060: 530d 9196 d927 1426 6642 c7d7 f1b9 7738  S....&#39;.&amp;fB....w8
00000070: 75fb 99f1 deb9 c997 c1eb 7696 fd76 9cd3  u.........v..v..
00000080: 93ca 03be ac7b 7b83 90ea 3c15 fd42 f0ec  .....{{...&lt;..B..
00000090: abf7 6ed2 f974 d8ff 1d31 e43f 8763 5518  ..n..t...1.?.cU.
000000a0: ed7a 03b9 c3f1 db4c b683 fb05 c805 4f81  .z.....L......O.</code></pre>
<p>Git compresses these files with zlib before storing them, and we’ll need to handle this. Fortunately there’s a tool called <code>zlib-flate</code> (part of the <code>qpdf</code> package) that we can use.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">:!</span>zlib<span class="fu">-</span>flate <span class="fu">-</span>uncompress <span class="fu">&lt;</span> <span class="fu">.</span>git<span class="fu">/</span>objects<span class="fu">/</span>e4<span class="fu">/</span>0cd4130e2a82f9b03ada1ca378b7701b1a9110</a></code></pre></div>
<pre><code>commit 248tree ecd0e58d6832566540a30dfd4878db518d5451d0
parent ab3c5646b41de1b6d95782371289db585ba8aa85
author Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700
committer Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700

add tmux by @seebi!</code></pre>
<p>This is identical to the output of <code>git cat-file -p</code>, except for the <code>commit 248</code> at the beginning. That’s a header that Git uses to tell different types of objects apart, and <code>248</code> is the content length of this particular commit. There’s also a null byte after the content length that the shell is not displaying here, and this will become important when we write code to handle the header in a moment.</p>
<p>I’m done playing with the shell for now, and I want to write some code. The first thing I’d like to do is import some libraries and define helper functions for compresssion and decompression. Haskell’s <code>zlib</code> library works with lazy bytestrings but I use strict bytestrings in the rest of this code and I don’t want to keep converting back and forth, so I’ll define <code>compress</code> and <code>decompress</code> accordingly.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Codec.Compression.Zlib</span> <span class="kw">as</span> <span class="dt">Z</span> (compress, decompress)</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="kw">import</span>           <span class="dt">Data.ByteString.Lazy</span>        (fromStrict, toStrict)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>             (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span>        <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5"></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">compress,<span class="ot"> decompress ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">compress   <span class="fu">=</span> toStrict <span class="fu">.</span> Z.compress   <span class="fu">.</span> fromStrict</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">decompress <span class="fu">=</span> toStrict <span class="fu">.</span> Z.decompress <span class="fu">.</span> fromStrict</a></code></pre></div>
<p>Now to recreate the <code>zlib-flate</code> output from earlier, and demonstrate the presence of that null byte in the header:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">commit <span class="ot">&lt;-</span> B.readFile <span class="st">&quot;.git/objects/e4/0cd4130e2a82f9b03ada1ca378b7701b1a9110&quot;</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">print <span class="fu">$</span> decompress commit</a></code></pre></div>
<pre><code>&quot;commit 248\NULtree ecd0e58d6832566540a30dfd4878db518d5451d0\nparent ab3c5646b41de1b6d95782371289db585ba8aa85\nauthor Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700\ncommitter Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700\n\nadd tmux by @seebi!\n&quot;</code></pre>
<p>Next, I want to make sense of this content by parsing it. I’ll write parsers that take a sequence of bytes and produce values I can work with. I also want to define serialisers (or unparsers, as I like to think of them) that take those values and turn them back into the sequence of bytes we started with.</p>
<p>Haskell has a couple of great options for this, and I’ve decided to go with <code>attoparsec</code>. It does the right thing and accounts for a parsing failure by default instead of blowing up with a runtime error, but I’m pretty confident that my parsers won’t fail so I’ll define a helper function that gets rid of that behaviour.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Data.Attoparsec.ByteString</span> (<span class="dt">Parser</span>)</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Attoparsec.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">AC</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="ot">parsed ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">parsed parser <span class="fu">=</span> either error id <span class="fu">.</span> AC.parseOnly parser</a></code></pre></div>
<p>Let’s write our first parser! We’ll start with a simple one for the header. We want some sequence of characters, a space, a number, and a null byte, and parser combinators make implementing this straightforward.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="ot">parseHeader ::</span> <span class="dt">Parser</span> (<span class="dt">ByteString</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">parseHeader <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">    objectType <span class="ot">&lt;-</span> AC.takeTill AC.isSpace</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    AC.space</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    len <span class="ot">&lt;-</span> AC.decimal</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">    AC.char <span class="ch">&#39;\NUL&#39;</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    return (objectType, len)</a>
<a class="sourceLine" id="cb21-8" data-line-number="8"></a>
<a class="sourceLine" id="cb21-9" data-line-number="9">commit <span class="ot">&lt;-</span> decompress <span class="fu">&lt;$&gt;</span> B.readFile <span class="st">&quot;.git/objects/e4/0cd4130e2a82f9b03ada1ca378b7701b1a9110&quot;</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"></a>
<a class="sourceLine" id="cb21-11" data-line-number="11">parsed parseHeader commit</a></code></pre></div>
<pre><code>(&quot;commit&quot;,248)</code></pre>
<p>The next parser I want is one for references. The correct way to do this is to look for 40 characters that are in the range 0-9 or a-f, but I’m lazy and I’m going to just grab 40 characters instead. Rabbit hole: write a parser that only parses valid SHA1 hashes.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Ref</span> <span class="fu">=</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"></a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="ot">parseHexRef ::</span> <span class="dt">Parser</span> <span class="dt">Ref</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">parseHexRef <span class="fu">=</span> AC.take <span class="dv">40</span></a></code></pre></div>
<p>We now have all the smaller parsers we’ll need to plug together in order to parse a commit. We want to parse the <code>tree</code>, any number of <code>parent</code>s, an <code>author</code>, a <code>committer</code>, and a message. Why any number of parents? The initial commit of a repository won’t have any parents, and merge commits will have at least two, although there can be more (this is known as an <a href="https://www.destroyallsoftware.com/blog/2017/the-biggest-and-weirdest-commits-in-linux-kernel-git-history">octopus merge</a>).</p>
<p>The author and committer lines consist of a user’s name, their email, the unix timestamp, and the timezone. A better parser for this would validate each of those components, but to demonstrate I’m just going to grab the whole line. Rabbit hole: write the better person+time parser.</p>
<p>One thing I really like about parser combinators is that I can write a parser whose form imitates the content I’m trying to parse. This is purely a cute stylistic quirk, but I enjoy doing it anyway.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Commit</span> <span class="fu">=</span> <span class="dt">Commit</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">    {<span class="ot"> commitTree      ::</span> <span class="dt">Ref</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">    ,<span class="ot"> commitParents   ::</span> [<span class="dt">Ref</span>]</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    ,<span class="ot"> commitAuthor    ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    ,<span class="ot"> commitCommitter ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">    ,<span class="ot"> commitMessage   ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb24-8" data-line-number="8"></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">parseCommit <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10">    cTree      <span class="ot">&lt;-</span>           AC.string <span class="st">&quot;tree&quot;</span>      <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> parseHexRef                   <span class="fu">&lt;*</span> AC.endOfLine</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">    cParents   <span class="ot">&lt;-</span> AC.many&#39; (AC.string <span class="st">&quot;parent&quot;</span>    <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> parseHexRef                   <span class="fu">&lt;*</span> AC.endOfLine)</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">    cAuthor    <span class="ot">&lt;-</span>           AC.string <span class="st">&quot;author&quot;</span>    <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> AC.takeTill (AC.inClass <span class="st">&quot;\n&quot;</span>) <span class="fu">&lt;*</span> AC.endOfLine</a>
<a class="sourceLine" id="cb24-13" data-line-number="13">    cCommitter <span class="ot">&lt;-</span>           AC.string <span class="st">&quot;committer&quot;</span> <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> AC.takeTill (AC.inClass <span class="st">&quot;\n&quot;</span>) <span class="fu">&lt;*</span> AC.endOfLine</a>
<a class="sourceLine" id="cb24-14" data-line-number="14">    AC.endOfLine</a>
<a class="sourceLine" id="cb24-15" data-line-number="15">    cMessage   <span class="ot">&lt;-</span> AC.takeByteString</a>
<a class="sourceLine" id="cb24-16" data-line-number="16">    return <span class="fu">$</span> <span class="dt">Commit</span> cTree cParents cAuthor cCommitter cMessage</a>
<a class="sourceLine" id="cb24-17" data-line-number="17"></a>
<a class="sourceLine" id="cb24-18" data-line-number="18">parsed (parseHeader <span class="fu">*&gt;</span> parseCommit) commit</a></code></pre></div>
<pre><code>Commit {commitTree = &quot;ecd0e58d6832566540a30dfd4878db518d5451d0&quot;, commitParents = [&quot;ab3c5646b41de1b6d95782371289db585ba8aa85&quot;], commitAuthor = &quot;Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700&quot;, commitCommitter = &quot;Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700&quot;, commitMessage = &quot;add tmux by @seebi!\n&quot;}</code></pre>
<p>Now to write our first serialiser that takes values of the Commit type and turns them back into bytestrings. Again, with some formatting liberties I can make this look a lot like the content I want to output. I can quickly check that it <a href="http://teh.id.au/posts/2017/06/07/round-trip-property/">round-trips</a> to see that both my parser and serialiser work properly.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;), mappend, mconcat)</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Data.Byteable</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">Commit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    toBytes (<span class="dt">Commit</span> cTree cParents cAuthor cCommitter cMessage) <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb26-6" data-line-number="6">        [                        <span class="st">&quot;tree &quot;</span>      <span class="fu">&lt;&gt;</span> cTree      <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">        , mconcat (map (\cRef <span class="ot">-&gt;</span> <span class="st">&quot;parent &quot;</span>    <span class="fu">&lt;&gt;</span> cRef       <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span>) cParents)</a>
<a class="sourceLine" id="cb26-8" data-line-number="8">        ,                        <span class="st">&quot;author &quot;</span>    <span class="fu">&lt;&gt;</span> cAuthor    <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span></a>
<a class="sourceLine" id="cb26-9" data-line-number="9">        ,                        <span class="st">&quot;committer &quot;</span> <span class="fu">&lt;&gt;</span> cCommitter <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">        ,                                                      <span class="st">&quot;\n&quot;</span></a>
<a class="sourceLine" id="cb26-11" data-line-number="11">        ,                                        cMessage</a>
<a class="sourceLine" id="cb26-12" data-line-number="12">        ]</a>
<a class="sourceLine" id="cb26-13" data-line-number="13"></a>
<a class="sourceLine" id="cb26-14" data-line-number="14">parsedCommit <span class="fu">=</span> parsed (parseHeader <span class="fu">*&gt;</span> parseCommit) commit</a>
<a class="sourceLine" id="cb26-15" data-line-number="15">(parsed parseCommit <span class="fu">.</span> toBytes <span class="fu">$</span> parsedCommit) <span class="fu">==</span> parsedCommit</a></code></pre></div>
<pre><code>True</code></pre>
<p>Let’s backtrack and also define a serialiser for our headers.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.ByteString.UTF8</span> (fromString, toString)</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="ot">withHeader ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4">withHeader oType content <span class="fu">=</span> mconcat [oType, <span class="st">&quot; &quot;</span>, fromString <span class="fu">.</span> show <span class="fu">$</span> B.length content, <span class="st">&quot;\NUL&quot;</span>, content]</a>
<a class="sourceLine" id="cb28-5" data-line-number="5"></a>
<a class="sourceLine" id="cb28-6" data-line-number="6">withHeader <span class="st">&quot;commit&quot;</span> (toBytes parsedCommit)</a></code></pre></div>
<pre><code>commit 248tree ecd0e58d6832566540a30dfd4878db518d5451d0
parent ab3c5646b41de1b6d95782371289db585ba8aa85
author Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482098 -0700
committer Trevor Bramble &lt;inbox@trevorbramble.com&gt; 1372482214 -0700

add tmux by @seebi!</code></pre>
<p>Great, it looks like that does the right thing. We’ll test it more thoroughly later.</p>
<p>So far I’ve avoided the question of where the hashes come from. Git is a content-addressable store (CAS) and the content of our Git objects uniquely determines their hash. This is very much like a hash table, and that’s a useful way to think about Git: a hashtable on the filesystem.</p>
<p>More specifically, the SHA1 hash of a Git object before compression is used as the reference. Let me demonstrate.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Digest.Pure.SHA</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2"></a>
<a class="sourceLine" id="cb30-3" data-line-number="3"><span class="ot">hash ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Ref</span></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">hash <span class="fu">=</span> fromString <span class="fu">.</span> showDigest <span class="fu">.</span> sha1 <span class="fu">.</span> fromStrict</a>
<a class="sourceLine" id="cb30-5" data-line-number="5"></a>
<a class="sourceLine" id="cb30-6" data-line-number="6">hash (withHeader <span class="st">&quot;commit&quot;</span> (toBytes parsedCommit))</a></code></pre></div>
<pre><code>e40cd4130e2a82f9b03ada1ca378b7701b1a9110</code></pre>
<p>This is the same hash as the one we’ve been using to get at the commit so far, which is consistent with my explanation.</p>
<p>I think this is a good point to mention that Git commits form a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">directed acyclic graph</a>, and this property is ensured by the way hashes are computed: since a commit hash depends on the content of the <code>parent</code> fields, a commit with an ancestor referring back to it would somehow need that ancestor (and therefore all its successors) to know the final commit hash <em>before it has been determined</em>. However, since SHA1 has recently been <a href="https://shattered.io/">broken in practice</a>, it might be eventually possible to generate a Git commit cycle and I’m curious to see how the tool would behave in its presence.</p>
<p>Now that we’re done with commits, let’s look at trees. A tree is what Git calls a directory listing. I think the tree reference <code>ecd0e58d6832566540a30dfd4878db518d5451d0</code> in the above commit is a good one to start with.</p>
<p>A tree object consists of some number of tree entries, and each tree entry represents a directory/file, with a reference to another Git object that stores the actual content of the directory/file. I think of these as <a href="https://en.wikipedia.org/wiki/Trie">tries</a>, with file contents at the leaves.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="fu">:!</span>git cat<span class="fu">-</span>file <span class="fu">-</span>p ecd0e58d6832566540a30dfd4878db518d5451d0</a></code></pre></div>
<pre><code>100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391	.gitmodules
100644 blob ec00a76061539cf774614788270214499696f871	CHANGELOG.mkd
100644 blob f95aaf80007d225f00d3109987ee42ef2c2e0c0a	DEVELOPERS.mkd
100644 blob ee08d7e44f15108ef5359550399dad55955b56ca	LICENSE
100644 blob d18ee9450251ea1b9a02ebd4d6fce022df9eb5e4	README.md
040000 tree 1981c76881c6a14e14d067a44247acd1bf6bbc3a	adobe-swatches-solarized
040000 tree 825c732bdd3a62aeb543ca89026a26a2ee0fba26	apple-colorpalette-solarized
040000 tree 7bab2828df5de23262a821cc48fe0ccf8bd2a9ae	emacs-colors-solarized
040000 tree f5fe8c3e20b2577223f617683a52eac31c5c9f30	files
040000 tree 5b60111510dbb3d8560cf58a36a20a99fc175658	gedit
040000 tree 60c9df3d6e1994b76d72c061a02639af3d925655	gimp-palette-solarized
040000 tree 979cf43752e4d698c7b5b47cff665142a274c133	img
040000 tree 3ff6d431303b66cc50e45b6fabd72302f210aebc	intellij-colors-solarized
040000 tree 8f387a531ad08f146c86e4b6007b898064ad4d7f	iterm2-colors-solarized
040000 tree 1e37592e62c85909be4c5e5eb774f177766e8422	mutt-colors-solarized
040000 tree 8f321f917040d903f701a2b33aeee26aed2ee544	netbeans-colors-solarized
040000 tree 0d408465820822f6a2afccf43e9627375fedc278	osx-terminal.app-colors-solarized
040000 tree 63dfa6c40d214f8e0f76d39f7a2283e053940a19	putty-colors-solarized
040000 tree 453921a267d3eb855e40c7de73aee46088563f3e	qtcreator
040000 tree 5dd6832a324187f8f521bef928891fb87cf845f6	seestyle-colors-solarized
040000 tree 3c15973ed107e7b37d1c4885f82984658ecbdf6a	textmate-colors-solarized
040000 tree 4db152b36a47e31a872e778c02161f537888e44b	textwrangler-bbedit-colors-solarized
040000 tree 09b5f2f69e1596c6ff66fb187ea6bdc385845152	tmux
040000 tree 635ebbb919fcbbaf6fe958998553bf3f5fe09210	utils
040000 tree b87a2100b0a79424cd4b2a4e4ef03274b130a206	vim-colors-solarized
040000 tree 8dea7190b79c05404aa6a1f0d67c5c6671d66fe1	visualstudio-colors-solarized
040000 tree 0a531826e913a4b11823ee1be6e1b367f826006f	xchat
040000 tree 2870bdf394a6b6b3bd10c263ffe9396a0d3d3366	xfce4-terminal
040000 tree 5d1a212e2fd9cdc2b678e3be56cf776b2f16cfe2	xresources</code></pre>
<p>The number at the beginning of each entry represents the entry permissions, and is a subset of Unix file permissions. <code>100644</code> corresponds to a blob, which is the Git object corresponding to a file, and <code>040000</code> corresponds to a tree. Other numbers exist but are uncommon. The rest of the tree entry is the entry reference and the entry name.</p>
<p>As before, we should be able to decompress the file and get essentially the same output as before, right?</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">tree <span class="ot">&lt;-</span> decompress <span class="fu">&lt;$&gt;</span> B.readFile <span class="st">&quot;.git/objects/ec/d0e58d6832566540a30dfd4878db518d5451d0&quot;</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">print tree</a></code></pre></div>
<pre><code>&quot;tree 1282\NUL100644 .gitmodules\NUL\230\157\226\155\178\209\214CK\139)\174wZ\216\194\228\140S\145\&amp;100644 CHANGELOG.mkd\NUL\236\NUL\167`aS\156\247taG\136&#39;\STX\DC4I\150\150\248q100644 DEVELOPERS.mkd\NUL\249Z\175\128\NUL}\&quot;_\NUL\211\DLE\153\135\238B\239,.\f\n100644 LICENSE\NUL\238\b\215\228O\NAK\DLE\142\245\&amp;5\149P9\157\173U\149[V\202\&amp;100644 README.md\NUL\209\142\233E\STXQ\234\ESC\154\STX\235\212\214\252\224\&quot;\223\158\181\228\&amp;40000 adobe-swatches-solarized\NUL\EM\129\199h\129\198\161N\DC4\208g\164BG\172\209\191k\188:40000 apple-colorpalette-solarized\NUL\130\\s+\221:b\174\181C\202\137\STXj&amp;\162\238\SI\186&amp;40000 emacs-colors-solarized\NUL{\171((\223]\226\&amp;2b\168!\204H\254\f\207\139\210\169\174\&amp;40000 files\NUL\245\254\140&gt; \178Wr#\246\ETBh:R\234\195\FS\\\159\&amp;040000 gedit\NUL[`\DC1\NAK\DLE\219\179\216V\f\245\138\&amp;6\162\n\153\252\ETBVX40000 gimp-palette-solarized\NUL`\201\223=n\EM\148\183mr\192a\160&amp;9\175=\146VU40000 img\NUL\151\156\244\&amp;7R\228\214\152\199\181\180|\255fQB\162t\193\&amp;340000 intellij-colors-solarized\NUL?\246\212\&amp;10;f\204P\228[o\171\215#\STX\242\DLE\174\188\&amp;40000 iterm2-colors-solarized\NUL\143\&amp;8zS\SUB\208\143\DC4l\134\228\182\NUL{\137\128d\173M\DEL40000 mutt-colors-solarized\NUL\RS7Y.b\200Y\t\190L^^\183t\241wvn\132\&quot;40000 netbeans-colors-solarized\NUL\143\&amp;2\US\145p@\217\ETX\247\SOH\162\179:\238\226j\237.\229D40000 osx-terminal.app-colors-solarized\NUL\r@\132e\130\b\&quot;\246\162\175\204\244&gt;\150&#39;7_\237\194x40000 putty-colors-solarized\NULc\223\166\196\r!O\142\SIv\211\159z\&quot;\131\224S\148\n\EM40000 qtcreator\NULE9!\162g\211\235\133^@\199\222s\174\228`\136V?&gt;40000 seestyle-colors-solarized\NUL]\214\131*2A\135\248\245!\190\249(\137\US\184|\248E\246\&amp;40000 textmate-colors-solarized\NUL&lt;\NAK\151&gt;\209\a\231\179}\FSH\133\248)\132e\142\203\223j40000 textwrangler-bbedit-colors-solarized\NULM\177R\179jG\227\SUB\135.w\140\STX\SYN\USSx\136\228K40000 tmux\NUL\t\181\242\246\158\NAK\150\198\255f\251\CAN~\166\189\195\133\132QR40000 utils\NULc^\187\185\EM\252\187\175o\233X\153\133S\191?_\224\146\DLE40000 vim-colors-solarized\NUL\184z!\NUL\176\167\148$\205K*NN\240\&amp;2t\177\&amp;0\162\ACK40000 visualstudio-colors-solarized\NUL\141\234q\144\183\156\ENQ@J\166\161\240\214|\\fq\214o\225\&amp;40000 xchat\NUL\nS\CAN&amp;\233\DC3\164\177\CAN#\238\ESC\230\225\179g\248&amp;\NULo40000 xfce4-terminal\NUL(p\189\243\148\166\182\179\189\DLE\194c\255\233\&amp;9j\r=3f40000 xresources\NUL]\SUB!./\217\205\194\182x\227\190V\207wk/\SYN\207\226&quot;</code></pre>
<p>Although this looks very much like gibberish, it is the same content as above with one big difference: instead of the 40-byte hexadecimal representation of a SHA1 hash, the 20-byte representation is used. The <code>tree &lt;length&gt;</code> header is present, as is the entry permission. Each entry name is followed by a <code>\NUL</code> to facilitate parsing.</p>
<p>We are now able to define a parser for tree objects. Rabbit hole: the tree entries need to be sorted in a certain quirky order, and we would like to disallow duplicates. Use a different data structure and manual <code>Ord</code> definitions to ensure this.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.ByteString.Base16</span> (encode)</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"></a>
<a class="sourceLine" id="cb36-3" data-line-number="3"><span class="ot">parseBinRef ::</span> <span class="dt">Parser</span> <span class="dt">Ref</span></a>
<a class="sourceLine" id="cb36-4" data-line-number="4">parseBinRef <span class="fu">=</span> encode <span class="fu">&lt;$&gt;</span> AC.take <span class="dv">20</span></a>
<a class="sourceLine" id="cb36-5" data-line-number="5"></a>
<a class="sourceLine" id="cb36-6" data-line-number="6"><span class="kw">data</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Tree</span> {<span class="ot"> treeEntries ::</span> [<span class="dt">TreeEntry</span>] } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb36-7" data-line-number="7"></a>
<a class="sourceLine" id="cb36-8" data-line-number="8"><span class="kw">data</span> <span class="dt">TreeEntry</span> <span class="fu">=</span> <span class="dt">TreeEntry</span></a>
<a class="sourceLine" id="cb36-9" data-line-number="9">    {<span class="ot"> treeEntryPerms ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb36-10" data-line-number="10">    ,<span class="ot"> treeEntryName  ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb36-11" data-line-number="11">    ,<span class="ot"> treeEntryRef   ::</span> <span class="dt">Ref</span></a>
<a class="sourceLine" id="cb36-12" data-line-number="12">    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb36-13" data-line-number="13"></a>
<a class="sourceLine" id="cb36-14" data-line-number="14"><span class="ot">parseTreeEntry ::</span> <span class="dt">Parser</span> <span class="dt">TreeEntry</span></a>
<a class="sourceLine" id="cb36-15" data-line-number="15">parseTreeEntry <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb36-16" data-line-number="16">    perms <span class="ot">&lt;-</span> fromString <span class="fu">&lt;$&gt;</span> AC.many1&#39; AC.digit</a>
<a class="sourceLine" id="cb36-17" data-line-number="17">    AC.space</a>
<a class="sourceLine" id="cb36-18" data-line-number="18">    name  <span class="ot">&lt;-</span> AC.takeWhile (<span class="fu">/=</span><span class="ch">&#39;\NUL&#39;</span>)</a>
<a class="sourceLine" id="cb36-19" data-line-number="19">    AC.char <span class="ch">&#39;\NUL&#39;</span></a>
<a class="sourceLine" id="cb36-20" data-line-number="20">    ref   <span class="ot">&lt;-</span> parseBinRef</a>
<a class="sourceLine" id="cb36-21" data-line-number="21">    return <span class="fu">$</span> <span class="dt">TreeEntry</span> perms name ref</a>
<a class="sourceLine" id="cb36-22" data-line-number="22"></a>
<a class="sourceLine" id="cb36-23" data-line-number="23"><span class="ot">parseTree ::</span> <span class="dt">Parser</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb36-24" data-line-number="24">parseTree <span class="fu">=</span> <span class="dt">Tree</span> <span class="fu">&lt;$&gt;</span> AC.many&#39; parseTreeEntry</a>
<a class="sourceLine" id="cb36-25" data-line-number="25"></a>
<a class="sourceLine" id="cb36-26" data-line-number="26">parsedTree <span class="fu">=</span> parsed (parseHeader <span class="fu">*&gt;</span> parseTree) tree</a>
<a class="sourceLine" id="cb36-27" data-line-number="27">parsedTree</a></code></pre></div>
<pre><code>Tree {treeEntries = [TreeEntry {treeEntryPerms = &quot;100644&quot;, treeEntryName = &quot;.gitmodules&quot;, treeEntryRef = &quot;e69de29bb2d1d6434b8b29ae775ad8c2e48c5391&quot;},TreeEntry {treeEntryPerms = &quot;100644&quot;, treeEntryName = &quot;CHANGELOG.mkd&quot;, treeEntryRef = &quot;ec00a76061539cf774614788270214499696f871&quot;},TreeEntry {treeEntryPerms = &quot;100644&quot;, treeEntryName = &quot;DEVELOPERS.mkd&quot;, treeEntryRef = &quot;f95aaf80007d225f00d3109987ee42ef2c2e0c0a&quot;},TreeEntry {treeEntryPerms = &quot;100644&quot;, treeEntryName = &quot;LICENSE&quot;, treeEntryRef = &quot;ee08d7e44f15108ef5359550399dad55955b56ca&quot;},TreeEntry {treeEntryPerms = &quot;100644&quot;, treeEntryName = &quot;README.md&quot;, treeEntryRef = &quot;d18ee9450251ea1b9a02ebd4d6fce022df9eb5e4&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;adobe-swatches-solarized&quot;, treeEntryRef = &quot;1981c76881c6a14e14d067a44247acd1bf6bbc3a&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;apple-colorpalette-solarized&quot;, treeEntryRef = &quot;825c732bdd3a62aeb543ca89026a26a2ee0fba26&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;emacs-colors-solarized&quot;, treeEntryRef = &quot;7bab2828df5de23262a821cc48fe0ccf8bd2a9ae&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;files&quot;, treeEntryRef = &quot;f5fe8c3e20b2577223f617683a52eac31c5c9f30&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;gedit&quot;, treeEntryRef = &quot;5b60111510dbb3d8560cf58a36a20a99fc175658&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;gimp-palette-solarized&quot;, treeEntryRef = &quot;60c9df3d6e1994b76d72c061a02639af3d925655&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;img&quot;, treeEntryRef = &quot;979cf43752e4d698c7b5b47cff665142a274c133&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;intellij-colors-solarized&quot;, treeEntryRef = &quot;3ff6d431303b66cc50e45b6fabd72302f210aebc&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;iterm2-colors-solarized&quot;, treeEntryRef = &quot;8f387a531ad08f146c86e4b6007b898064ad4d7f&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;mutt-colors-solarized&quot;, treeEntryRef = &quot;1e37592e62c85909be4c5e5eb774f177766e8422&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;netbeans-colors-solarized&quot;, treeEntryRef = &quot;8f321f917040d903f701a2b33aeee26aed2ee544&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;osx-terminal.app-colors-solarized&quot;, treeEntryRef = &quot;0d408465820822f6a2afccf43e9627375fedc278&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;putty-colors-solarized&quot;, treeEntryRef = &quot;63dfa6c40d214f8e0f76d39f7a2283e053940a19&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;qtcreator&quot;, treeEntryRef = &quot;453921a267d3eb855e40c7de73aee46088563f3e&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;seestyle-colors-solarized&quot;, treeEntryRef = &quot;5dd6832a324187f8f521bef928891fb87cf845f6&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;textmate-colors-solarized&quot;, treeEntryRef = &quot;3c15973ed107e7b37d1c4885f82984658ecbdf6a&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;textwrangler-bbedit-colors-solarized&quot;, treeEntryRef = &quot;4db152b36a47e31a872e778c02161f537888e44b&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;tmux&quot;, treeEntryRef = &quot;09b5f2f69e1596c6ff66fb187ea6bdc385845152&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;utils&quot;, treeEntryRef = &quot;635ebbb919fcbbaf6fe958998553bf3f5fe09210&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;vim-colors-solarized&quot;, treeEntryRef = &quot;b87a2100b0a79424cd4b2a4e4ef03274b130a206&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;visualstudio-colors-solarized&quot;, treeEntryRef = &quot;8dea7190b79c05404aa6a1f0d67c5c6671d66fe1&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;xchat&quot;, treeEntryRef = &quot;0a531826e913a4b11823ee1be6e1b367f826006f&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;xfce4-terminal&quot;, treeEntryRef = &quot;2870bdf394a6b6b3bd10c263ffe9396a0d3d3366&quot;},TreeEntry {treeEntryPerms = &quot;40000&quot;, treeEntryName = &quot;xresources&quot;, treeEntryRef = &quot;5d1a212e2fd9cdc2b678e3be56cf776b2f16cfe2&quot;}]}</code></pre>
<p>It’s similarly straightforward to define a serialiser. All we have to do is serialise the tree entries and concatenate them.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.ByteString.Base16</span> (decode)</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"></a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">TreeEntry</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    toBytes (<span class="dt">TreeEntry</span> perms name ref) <span class="fu">=</span> mconcat [perms, <span class="st">&quot; &quot;</span>, name, <span class="st">&quot;\NUL&quot;</span>, fst <span class="fu">$</span> decode ref]</a>
<a class="sourceLine" id="cb38-5" data-line-number="5"></a>
<a class="sourceLine" id="cb38-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">Tree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-7" data-line-number="7">    toBytes (<span class="dt">Tree</span> entries) <span class="fu">=</span> mconcat (map toBytes entries)</a>
<a class="sourceLine" id="cb38-8" data-line-number="8"></a>
<a class="sourceLine" id="cb38-9" data-line-number="9">(parsed parseTree <span class="fu">.</span> toBytes <span class="fu">$</span> parsedTree) <span class="fu">==</span> parsedTree</a></code></pre></div>
<pre><code>True</code></pre>
<p>Next we move to blobs. I’m using the reference associated with <code>CHANGELOG.mkd</code> because <code>.gitmodules</code> is empty, and limiting the output to the first ten lines for now because we’ll see the whole thing later anyway.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="fu">:!</span>git cat<span class="fu">-</span>file <span class="fu">-</span>p ec00a76061539cf774614788270214499696f871 <span class="fu">|</span> head <span class="fu">-</span>n10</a></code></pre></div>
<pre><code>Solarized Changelog
===================

## Current release 1.0.0beta2

1.0.0beta2
----------

### Summary</code></pre>
<p>A blob is some bytes with a header.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">BC</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2">blob <span class="ot">&lt;-</span> decompress <span class="fu">&lt;$&gt;</span> B.readFile <span class="st">&quot;.git/objects/ec/00a76061539cf774614788270214499696f871&quot;</span></a>
<a class="sourceLine" id="cb42-3" data-line-number="3">print <span class="fu">$</span> BC.unlines <span class="fu">.</span> take <span class="dv">10</span> <span class="fu">.</span> BC.lines <span class="fu">$</span> blob</a></code></pre></div>
<pre><code>&quot;blob 5549\NULSolarized Changelog\n===================\n\n## Current release 1.0.0beta2\n\n1.0.0beta2\n----------\n\n### Summary\n\n&quot;</code></pre>
<p>Parsing blobs is easy!</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Blob</span> <span class="fu">=</span> <span class="dt">Blob</span> {<span class="ot"> blobContent ::</span> <span class="dt">ByteString</span> } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb44-2" data-line-number="2"></a>
<a class="sourceLine" id="cb44-3" data-line-number="3"><span class="ot">parseBlob ::</span> <span class="dt">Parser</span> <span class="dt">Blob</span></a>
<a class="sourceLine" id="cb44-4" data-line-number="4">parseBlob <span class="fu">=</span> <span class="dt">Blob</span> <span class="fu">&lt;$&gt;</span> AC.takeByteString</a>
<a class="sourceLine" id="cb44-5" data-line-number="5"></a>
<a class="sourceLine" id="cb44-6" data-line-number="6">parsedBlob <span class="fu">=</span> parsed (parseHeader <span class="fu">*&gt;</span> parseBlob) blob</a>
<a class="sourceLine" id="cb44-7" data-line-number="7">parsedBlob</a></code></pre></div>
<pre><code>Blob {blobContent = &quot;Solarized Changelog\n===================\n\n## Current release 1.0.0beta2\n\n1.0.0beta2\n----------\n\n### Summary\n\nSwitch to the alternative red hue (final and only hue change), included a whole\nheap of new ports and updates to the existing Vim colorscheme. The list of all \ncurrently included ports, highlighted items are new, updates noted:\n\n#### Editors &amp; IDEs\n\n*   \\[UPDATED\\] **Vim**\n*   \\[NEW\\] ***Emacs***\n*   \\[NEW\\] ***IntelliJ IDEA***\n*   \\[NEW\\] ***NetBeans***\n*   \\[NEW\\] ***SeeStyle theme for Coda &amp; SubEthaEdit***\n*   \\[NEW\\] ***TextMate***\n*   \\[NEW\\] ***Visual Studio***\n\n#### Terminal Emulators\n\n* \\[UPDATED\\] **iTerm2 colorschemes**\n* \\[UPDATED\\] **OS X Terminal.app colors**\n* \\[UPDATED\\] **Xresources colors**\n\n#### Other Applications\n\n* \\[UPDATED\\] **Mutt mail client colorschemes**\n\n#### Palettes\n\n* \\[UPDATED\\] **Adobe Photoshop Swatches**\n* \\[UPDATED\\] **Apple Color Picker Palette**\n* \\[UPDATED\\] **Gimp Palette**\n\n\n### Critical Changes\n\nThese changes may require you to change your configuration.\n\n*   **GLOBAL : IMPROVEMENT : New red accent color value**\n    Modified red from L\\*a\\*b lightness value 45 to 50 to bring it in\n    line with the other accent colors and address bleed into dark background on \n    some displays, as well as reducing shift of red against base03 when viewed \n    with glasses (chromatic aberration). All instances of the colorscheme and \n    palettes updated to new red and avalailable for use/import without further \n    modification. Forks and ports should pull new changes and/or update ported \n    red value accordingly.  The new red:\n\n            red #dc322f\n\n*   **VIM : CHANGE : Default mode now 16 color**\n    Default terminal mode is now ***16 colors***. Most of the users of terminal \n    mode seem comfortabel and capable changing terminal colors. This is the \n    preferred method of implementing Solarized in Terminal mode. If you wish to \n    instead use the degraded 256 color palette, you may do so with the \n    following line in your .vimrc:\n\n            let g:solarized_termcolors=256\n\n    You no longer need to specify \&quot;let g:solarized_termcolors=16\&quot; as it is now \n    the default; leaving it in your .vimrc won&#39;t hurt anything, however.\n\n*   **VIM : IMPROVEMENT : New Toggle Background Plugin**\n    Added new Toggle Background plugin. Will load automatically and show up as \n    a menu item in the `Window` menu in gui vim. Automatically maps to\n    `&lt;F5&gt;` if available (won&#39;t clobber that mapping if you&#39;re using it).\n    Also available as a command `:ToggleBG`.  To manually map to\n    something other than `&lt;F5&gt;`:\n\n    To set your own mapping in your .vimrc file, simply add the following line \n    to support normal, insert and visual mode usage, changing the\n    \&quot;`&lt;F5&gt;`\&quot; value to the key or key combination you wish to use:\n\n        call togglebg#map(\&quot;&lt;F5&gt;\&quot;)\n\n    Note that you&#39;ll want to use a single function key or equivalent if you want \n    the plugin to work in all modes (normal, insert, visual).\n\n*   **VIM : IMPROVEMENT : Special &amp; Non-text items now more visible**\n    Special characters such as trailing whitespace, tabs, newlines, when \n    displayed using \&quot;:set list\&quot; can be set to one of three levels depending on \n    your needs.\n\n            let g:solarized_visibility =  \&quot;normal\&quot;|   \&quot;high\&quot; or \&quot;low\&quot;\n\n    I&#39;ll be honest: I still prefer low visibility. I like them barely there.  \n    They show up in lines that are highlighted as by the cursor line, which \n    works for me. If you are with me on this, put the following in your .vimrc:\n\n            let g:solarized_visibility =  \&quot;low\&quot;\n\n### Non Critical Changes\n\nThese changes should not impact your usage of the Solarized.\n\n*   **PALETTES : IMPROVEMENT : Colorspace tagged and untagged versions**\n    Changed default OS X color picker palatte swatches to tagged colors (sRGB) \n    and included alternate palette with untagged color swatches for advanced \n    users (v1.0.0beta1 had untagged as default).\n\n*   **VIM : BUGFIX : Better display in Terminal.app, other emulators**\n    Terminal.app and other common terminal emulators that report 8 color mode \n    had display issues due to order of synt highlighting definitions and color \n    values specified. These have been conformed and reordered in such a way \n    that there is a more graceful degrading of the Solarized color palette on \n    8 color terminals. Infact, the experience should be almost identical to gui \n    other than lack of bold typeface.\n\n*   **VIM : BUGFIX : Better distinction between status bar and split windows**\n    Status bar was previously too similar to the cursor line and window splits.  \n    This has now been changed significantly to improve the clarity of what is \n    status, cursor line and window separator.\n\n*   **VIM : STREAMLINED : Removed simultaneous gui/cterm definitions**\n*   Refactored solarized.vim to eliminate simultaneous definition of gui and \n    cterm values.\n\n*   **VIM : BUGFIX : Removed italicized front in terminal mode**\n    Removed default italicized font in terminal mode in the Solarized Vim\n    colorscheme (many terminal emulators display Vim italics as reversed type).  \n    Italics still used in GUI mode by default and can still be turned off in \n    both modes by setting a variable: `let g:solarized_italic=0`.\n\n1.0.0beta1\n----------\n\nFirst public release. Included:\n\n* Adobe Photoshop Swatches\n* Apple Color Picker Palette\n* Gimp Palette\n* iTerm2 colorschemes\n* Mutt mail client colorschemes\n* OS X Terminal.app colors\n* Vim Colorscheme\n* Xresources colors\n\n\n\n***\n\nMODIFIED: 2011 Apr 16\n&quot;}</code></pre>
<p>As is serialising them.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">Blob</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2">    toBytes (<span class="dt">Blob</span> content) <span class="fu">=</span> content</a>
<a class="sourceLine" id="cb46-3" data-line-number="3"></a>
<a class="sourceLine" id="cb46-4" data-line-number="4">(parsed parseBlob <span class="fu">.</span> toBytes <span class="fu">$</span> parsedBlob) <span class="fu">==</span> parsedBlob</a></code></pre></div>
<pre><code>True</code></pre>
<p>Finally we move to Git tags, which are a way to associate a name with a reference. Git has a handy <code>show-ref --tags</code> command we can use to list them:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="fu">:!</span>git show<span class="fu">-</span>ref <span class="co">--tags</span></a></code></pre></div>
<pre><code>31ff7f5064824d2231648119feb6dfda1a3c89f5 refs/tags/v1.0.0beta1
a3037b428f29f0c032aeeeedb4758501bc32444d refs/tags/v1.0beta</code></pre>
<p>There are two types of tags: lightweight tags and annotated tags. Lightweight tags are just files very much like <code>refs/heads/master</code> containing a ref, and annotated tags have a message associated with them like a commit. Only annotated tags are Git objects.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="fu">:!</span>git cat<span class="fu">-</span>file <span class="fu">-</span>p 31ff7f5064824d2231648119feb6dfda1a3c89f5</a></code></pre></div>
<pre><code>object 90581c7bfbcd279768580eec595d0ab3c094cc02
type commit
tag v1.0.0beta1
tagger Ethan Schoonover &lt;es@ethanschoonover.com&gt; 1300994142 -0700

Initial public beta release 1.0.0beta1</code></pre>
<p>Although tags are mostly used with commits, it’s possible to tag any Git object. You can even tag another tag, although I can’t see why you might want to.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1">tag <span class="ot">&lt;-</span> decompress <span class="fu">&lt;$&gt;</span> B.readFile <span class="st">&quot;.git/objects/31/ff7f5064824d2231648119feb6dfda1a3c89f5&quot;</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2">print tag</a></code></pre></div>
<pre><code>&quot;tag 182\NULobject 90581c7bfbcd279768580eec595d0ab3c094cc02\ntype commit\ntag v1.0.0beta1\ntagger Ethan Schoonover &lt;es@ethanschoonover.com&gt; 1300994142 -0700\n\nInitial public beta release 1.0.0beta1\n&quot;</code></pre>
<p>Our parser for these is very similar to our commit parser. I’ve taken a quick break from my ‘write the worst parser possible’ strategy to make sure that our tags can only tag objects of type ‘commit’, ‘tree’, ‘blob’, or ‘tag’.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tag</span> <span class="fu">=</span> <span class="dt">Tag</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2">    {<span class="ot"> tagObject     ::</span> <span class="dt">Ref</span></a>
<a class="sourceLine" id="cb54-3" data-line-number="3">    ,<span class="ot"> tagType       ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb54-4" data-line-number="4">    ,<span class="ot"> tagTag        ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb54-5" data-line-number="5">    ,<span class="ot"> tagTagger     ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb54-6" data-line-number="6">    ,<span class="ot"> tagAnnotation ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb54-7" data-line-number="7">    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb54-8" data-line-number="8"></a>
<a class="sourceLine" id="cb54-9" data-line-number="9"><span class="ot">parseTag ::</span> <span class="dt">Parser</span> <span class="dt">Tag</span></a>
<a class="sourceLine" id="cb54-10" data-line-number="10">parseTag <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb54-11" data-line-number="11">    tObject     <span class="ot">&lt;-</span> AC.string <span class="st">&quot;object&quot;</span> <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> parseHexRef                                                 <span class="fu">&lt;*</span> AC.endOfLine</a>
<a class="sourceLine" id="cb54-12" data-line-number="12">    tType       <span class="ot">&lt;-</span> AC.string <span class="st">&quot;type&quot;</span>   <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> AC.choice (map AC.string [<span class="st">&quot;commit&quot;</span>, <span class="st">&quot;tree&quot;</span>, <span class="st">&quot;blob&quot;</span>, <span class="st">&quot;tag&quot;</span>]) <span class="fu">&lt;*</span> AC.endOfLine</a>
<a class="sourceLine" id="cb54-13" data-line-number="13">    tTag        <span class="ot">&lt;-</span> AC.string <span class="st">&quot;tag&quot;</span>    <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> AC.takeTill (AC.inClass <span class="st">&quot;\n&quot;</span>)                               <span class="fu">&lt;*</span> AC.endOfLine</a>
<a class="sourceLine" id="cb54-14" data-line-number="14">    tTagger     <span class="ot">&lt;-</span> AC.string <span class="st">&quot;tagger&quot;</span> <span class="fu">*&gt;</span> AC.space <span class="fu">*&gt;</span> AC.takeTill (AC.inClass <span class="st">&quot;\n&quot;</span>)                               <span class="fu">&lt;*</span> AC.endOfLine</a>
<a class="sourceLine" id="cb54-15" data-line-number="15">    AC.endOfLine</a>
<a class="sourceLine" id="cb54-16" data-line-number="16">    tAnnotation <span class="ot">&lt;-</span> AC.takeByteString</a>
<a class="sourceLine" id="cb54-17" data-line-number="17">    return <span class="fu">$</span> <span class="dt">Tag</span> tObject tType tTag tTagger tAnnotation</a>
<a class="sourceLine" id="cb54-18" data-line-number="18"></a>
<a class="sourceLine" id="cb54-19" data-line-number="19">parsedTag <span class="fu">=</span> parsed (parseHeader <span class="fu">*&gt;</span> parseTag) tag</a>
<a class="sourceLine" id="cb54-20" data-line-number="20">parsedTag</a></code></pre></div>
<pre><code>Tag {tagObject = &quot;90581c7bfbcd279768580eec595d0ab3c094cc02&quot;, tagType = &quot;commit&quot;, tagTag = &quot;v1.0.0beta1&quot;, tagTagger = &quot;Ethan Schoonover &lt;es@ethanschoonover.com&gt; 1300994142 -0700&quot;, tagAnnotation = &quot;Initial public beta release 1.0.0beta1\n&quot;}</code></pre>
<p>Our last serialiser follows.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">Tag</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb56-2" data-line-number="2">    toBytes (<span class="dt">Tag</span> tObject tType tTag tTagger tAnnotation) <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb56-3" data-line-number="3">        [ <span class="st">&quot;object &quot;</span> <span class="fu">&lt;&gt;</span> tObject     <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span></a>
<a class="sourceLine" id="cb56-4" data-line-number="4">        , <span class="st">&quot;type &quot;</span>   <span class="fu">&lt;&gt;</span> tType       <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span></a>
<a class="sourceLine" id="cb56-5" data-line-number="5">        , <span class="st">&quot;tag &quot;</span>    <span class="fu">&lt;&gt;</span> tTag        <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span></a>
<a class="sourceLine" id="cb56-6" data-line-number="6">        , <span class="st">&quot;tagger &quot;</span> <span class="fu">&lt;&gt;</span> tTagger     <span class="fu">&lt;&gt;</span> <span class="st">&quot;\n&quot;</span></a>
<a class="sourceLine" id="cb56-7" data-line-number="7">        ,                             <span class="st">&quot;\n&quot;</span></a>
<a class="sourceLine" id="cb56-8" data-line-number="8">        ,              tAnnotation</a>
<a class="sourceLine" id="cb56-9" data-line-number="9">        ]</a>
<a class="sourceLine" id="cb56-10" data-line-number="10"></a>
<a class="sourceLine" id="cb56-11" data-line-number="11">(parsed parseTag <span class="fu">.</span> toBytes <span class="fu">$</span> parsedTag) <span class="fu">==</span> parsedTag</a></code></pre></div>
<pre><code>True</code></pre>
<p>Okay, now to bring it all together. We can define an umbrella <code>GitObject</code> type and the associated parser, serialiser, and hasher for it.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="kw">data</span> <span class="dt">GitObject</span></a>
<a class="sourceLine" id="cb58-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">GitCommit</span> <span class="dt">Commit</span></a>
<a class="sourceLine" id="cb58-3" data-line-number="3">    <span class="fu">|</span> <span class="dt">GitTree</span>   <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb58-4" data-line-number="4">    <span class="fu">|</span> <span class="dt">GitBlob</span>   <span class="dt">Blob</span></a>
<a class="sourceLine" id="cb58-5" data-line-number="5">    <span class="fu">|</span> <span class="dt">GitTag</span>    <span class="dt">Tag</span></a>
<a class="sourceLine" id="cb58-6" data-line-number="6">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb58-7" data-line-number="7"></a>
<a class="sourceLine" id="cb58-8" data-line-number="8"><span class="ot">parseGitObject ::</span> <span class="dt">Parser</span> <span class="dt">GitObject</span></a>
<a class="sourceLine" id="cb58-9" data-line-number="9">parseGitObject <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb58-10" data-line-number="10">    headerLen <span class="ot">&lt;-</span> parseHeader</a>
<a class="sourceLine" id="cb58-11" data-line-number="11">    <span class="kw">case</span> (fst headerLen) <span class="kw">of</span></a>
<a class="sourceLine" id="cb58-12" data-line-number="12">        <span class="st">&quot;commit&quot;</span> <span class="ot">-&gt;</span> <span class="dt">GitCommit</span> <span class="fu">&lt;$&gt;</span> parseCommit</a>
<a class="sourceLine" id="cb58-13" data-line-number="13">        <span class="st">&quot;tree&quot;</span>   <span class="ot">-&gt;</span> <span class="dt">GitTree</span>   <span class="fu">&lt;$&gt;</span> parseTree</a>
<a class="sourceLine" id="cb58-14" data-line-number="14">        <span class="st">&quot;blob&quot;</span>   <span class="ot">-&gt;</span> <span class="dt">GitBlob</span>   <span class="fu">&lt;$&gt;</span> parseBlob</a>
<a class="sourceLine" id="cb58-15" data-line-number="15">        <span class="st">&quot;tag&quot;</span>    <span class="ot">-&gt;</span> <span class="dt">GitTag</span>    <span class="fu">&lt;$&gt;</span> parseTag</a>
<a class="sourceLine" id="cb58-16" data-line-number="16">        _        <span class="ot">-&gt;</span> error <span class="st">&quot;not a git object&quot;</span></a>
<a class="sourceLine" id="cb58-17" data-line-number="17"></a>
<a class="sourceLine" id="cb58-18" data-line-number="18"><span class="kw">instance</span> <span class="dt">Byteable</span> <span class="dt">GitObject</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-19" data-line-number="19">    toBytes obj <span class="fu">=</span> <span class="kw">case</span> obj <span class="kw">of</span></a>
<a class="sourceLine" id="cb58-20" data-line-number="20">        <span class="dt">GitCommit</span> c <span class="ot">-&gt;</span> withHeader <span class="st">&quot;commit&quot;</span> (toBytes c)</a>
<a class="sourceLine" id="cb58-21" data-line-number="21">        <span class="dt">GitTree</span>   t <span class="ot">-&gt;</span> withHeader <span class="st">&quot;tree&quot;</span>   (toBytes t)</a>
<a class="sourceLine" id="cb58-22" data-line-number="22">        <span class="dt">GitBlob</span>   b <span class="ot">-&gt;</span> withHeader <span class="st">&quot;blob&quot;</span>   (toBytes b)</a>
<a class="sourceLine" id="cb58-23" data-line-number="23">        <span class="dt">GitTag</span>    t <span class="ot">-&gt;</span> withHeader <span class="st">&quot;tag&quot;</span>    (toBytes t)</a>
<a class="sourceLine" id="cb58-24" data-line-number="24"></a>
<a class="sourceLine" id="cb58-25" data-line-number="25"><span class="ot">hashObject ::</span> <span class="dt">GitObject</span> <span class="ot">-&gt;</span> <span class="dt">Ref</span></a>
<a class="sourceLine" id="cb58-26" data-line-number="26">hashObject <span class="fu">=</span> hash <span class="fu">.</span> toBytes</a></code></pre></div>
<p>Let’s do a quick test to check that our definitions work.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1">hashObject <span class="fu">.</span> parsed parseGitObject <span class="fu">.</span> decompress <span class="fu">&lt;$&gt;</span> B.readFile <span class="st">&quot;.git/objects/31/ff7f5064824d2231648119feb6dfda1a3c89f5&quot;</span></a></code></pre></div>
<pre><code>31ff7f5064824d2231648119feb6dfda1a3c89f5</code></pre>
<p>Excellent, although we are lacking a helper to turn a reference into a Git object filepath. Let’s define that.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.FilePath</span> ((&lt;/&gt;))</a>
<a class="sourceLine" id="cb61-2" data-line-number="2"></a>
<a class="sourceLine" id="cb61-3" data-line-number="3"><span class="ot">refPath ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Ref</span> <span class="ot">-&gt;</span> FilePath</a>
<a class="sourceLine" id="cb61-4" data-line-number="4">refPath gitDir ref <span class="fu">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb61-5" data-line-number="5">   (dir,file) <span class="fu">=</span> splitAt <span class="dv">2</span> (toString ref)</a>
<a class="sourceLine" id="cb61-6" data-line-number="6">   <span class="kw">in</span> gitDir <span class="fu">&lt;/&gt;</span> <span class="st">&quot;objects&quot;</span> <span class="fu">&lt;/&gt;</span> dir <span class="fu">&lt;/&gt;</span> file</a>
<a class="sourceLine" id="cb61-7" data-line-number="7"></a>
<a class="sourceLine" id="cb61-8" data-line-number="8">refPath <span class="st">&quot;.git&quot;</span> <span class="st">&quot;31ff7f5064824d2231648119feb6dfda1a3c89f5&quot;</span></a></code></pre></div>
<pre><code>&quot;.git/objects/31/ff7f5064824d2231648119feb6dfda1a3c89f5&quot;</code></pre>
<p>Now we can define a <code>readObject</code> action that takes a reference and returns a parsed Git object.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb63-1" data-line-number="1"><span class="ot">readObject ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Ref</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">GitObject</span></a>
<a class="sourceLine" id="cb63-2" data-line-number="2">readObject gitDir ref <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb63-3" data-line-number="3">    <span class="kw">let</span> path <span class="fu">=</span> refPath gitDir ref</a>
<a class="sourceLine" id="cb63-4" data-line-number="4">    content <span class="ot">&lt;-</span> decompress <span class="fu">&lt;$&gt;</span> B.readFile path</a>
<a class="sourceLine" id="cb63-5" data-line-number="5">    return <span class="fu">$</span> parsed parseGitObject content</a>
<a class="sourceLine" id="cb63-6" data-line-number="6"></a>
<a class="sourceLine" id="cb63-7" data-line-number="7">readObject <span class="st">&quot;.git&quot;</span> <span class="st">&quot;31ff7f5064824d2231648119feb6dfda1a3c89f5&quot;</span></a></code></pre></div>
<pre><code>GitTag (Tag {tagObject = &quot;90581c7bfbcd279768580eec595d0ab3c094cc02&quot;, tagType = &quot;commit&quot;, tagTag = &quot;v1.0.0beta1&quot;, tagTagger = &quot;Ethan Schoonover &lt;es@ethanschoonover.com&gt; 1300994142 -0700&quot;, tagAnnotation = &quot;Initial public beta release 1.0.0beta1\n&quot;})</code></pre>
<p>Next we define a <code>writeObject</code> action that takes a Git object and stores it under the right path if it doesn’t already exist. The “doesn’t already exist” bit is the magic of Git: we can safely assume that an object with the same hash is the same object. Every time a tree or blob changes, only the changed objects are written to the disk, and this is how Git manages to be space-efficient.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb65-1" data-line-number="1"><span class="kw">import</span> <span class="dt">System.Directory</span> (doesPathExist, createDirectoryIfMissing)</a>
<a class="sourceLine" id="cb65-2" data-line-number="2"><span class="kw">import</span> <span class="dt">System.FilePath</span>  (takeDirectory)</a>
<a class="sourceLine" id="cb65-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Control.Monad</span>    (when, unless)</a>
<a class="sourceLine" id="cb65-4" data-line-number="4"></a>
<a class="sourceLine" id="cb65-5" data-line-number="5"><span class="ot">writeObject ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">GitObject</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Ref</span></a>
<a class="sourceLine" id="cb65-6" data-line-number="6">writeObject gitDir object <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb65-7" data-line-number="7">    <span class="kw">let</span> ref  <span class="fu">=</span>  hashObject object</a>
<a class="sourceLine" id="cb65-8" data-line-number="8">    <span class="kw">let</span> path <span class="fu">=</span>  refPath gitDir ref</a>
<a class="sourceLine" id="cb65-9" data-line-number="9">    exists   <span class="ot">&lt;-</span> doesPathExist path</a>
<a class="sourceLine" id="cb65-10" data-line-number="10">    unless exists <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb65-11" data-line-number="11">        <span class="kw">let</span> dir <span class="fu">=</span> takeDirectory path</a>
<a class="sourceLine" id="cb65-12" data-line-number="12">        createDirectoryIfMissing <span class="dt">True</span> dir</a>
<a class="sourceLine" id="cb65-13" data-line-number="13">        B.writeFile path <span class="fu">.</span> compress <span class="fu">$</span> toBytes object</a>
<a class="sourceLine" id="cb65-14" data-line-number="14">    return ref</a></code></pre></div>
<p>Okay, time for the grand finale! We’re going to read and then write every object in this Git repository. If we’ve implemented everything correctly, the number of references before and after will be unchanged, and they will be the same references.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb66-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Traversable</span> (for)</a>
<a class="sourceLine" id="cb66-2" data-line-number="2"><span class="kw">import</span> <span class="dt">System.Directory</span> (listDirectory)</a>
<a class="sourceLine" id="cb66-3" data-line-number="3"></a>
<a class="sourceLine" id="cb66-4" data-line-number="4">allRefs <span class="ot">&lt;-</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb66-5" data-line-number="5">    prefixes <span class="ot">&lt;-</span> filter (\d <span class="ot">-&gt;</span> length d <span class="fu">==</span> <span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> listDirectory <span class="st">&quot;.git/objects/&quot;</span></a>
<a class="sourceLine" id="cb66-6" data-line-number="6">    concat <span class="fu">&lt;$&gt;</span> for prefixes (\p <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb66-7" data-line-number="7">        map (fromString <span class="fu">.</span> (p<span class="fu">++</span>)) <span class="fu">&lt;$&gt;</span> listDirectory (<span class="st">&quot;.git/objects&quot;</span> <span class="fu">&lt;/&gt;</span> p))</a>
<a class="sourceLine" id="cb66-8" data-line-number="8"></a>
<a class="sourceLine" id="cb66-9" data-line-number="9">print <span class="fu">$</span> length allRefs</a>
<a class="sourceLine" id="cb66-10" data-line-number="10"></a>
<a class="sourceLine" id="cb66-11" data-line-number="11">test <span class="ot">&lt;-</span> for allRefs <span class="fu">$</span> \ref <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb66-12" data-line-number="12">    obj  <span class="ot">&lt;-</span> readObject  <span class="st">&quot;.git&quot;</span> ref</a>
<a class="sourceLine" id="cb66-13" data-line-number="13">    ref&#39; <span class="ot">&lt;-</span> writeObject <span class="st">&quot;.git&quot;</span> obj</a>
<a class="sourceLine" id="cb66-14" data-line-number="14">    return <span class="fu">$</span> ref <span class="fu">==</span> ref&#39;</a>
<a class="sourceLine" id="cb66-15" data-line-number="15"></a>
<a class="sourceLine" id="cb66-16" data-line-number="16">and test</a>
<a class="sourceLine" id="cb66-17" data-line-number="17"></a>
<a class="sourceLine" id="cb66-18" data-line-number="18">allRefs&#39; <span class="ot">&lt;-</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb66-19" data-line-number="19">    prefixes <span class="ot">&lt;-</span> filter (\d <span class="ot">-&gt;</span> length d <span class="fu">==</span> <span class="dv">2</span>) <span class="fu">&lt;$&gt;</span> listDirectory <span class="st">&quot;.git/objects/&quot;</span></a>
<a class="sourceLine" id="cb66-20" data-line-number="20">    concat <span class="fu">&lt;$&gt;</span> for prefixes (\p <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb66-21" data-line-number="21">        map (fromString <span class="fu">.</span> (p<span class="fu">++</span>)) <span class="fu">&lt;$&gt;</span> listDirectory (<span class="st">&quot;.git/objects&quot;</span> <span class="fu">&lt;/&gt;</span> p))</a>
<a class="sourceLine" id="cb66-22" data-line-number="22"></a>
<a class="sourceLine" id="cb66-23" data-line-number="23">print <span class="fu">$</span> length allRefs&#39;</a>
<a class="sourceLine" id="cb66-24" data-line-number="24"></a>
<a class="sourceLine" id="cb66-25" data-line-number="25">allRefs <span class="fu">==</span> allRefs&#39;</a></code></pre></div>
<pre><code>2186



True



2186



True</code></pre>
<p>And that’s essentially all there is to Git! I’ve skipped over most of the additional quirks, features, and optimisations but I hope I’ve established that even with the relatively small amount of code above you can implement a working and usable Git API.</p>
<p>You’ll notice that one thing I haven’t mentioned at all is diffing or merging. That’s because Git doesn’t store diffs! They are computed on the fly when you ask for them. The packfile format does do diffing as a space optimisation, but I think it’s important to point out that you can have a perfectly cromulent implementation without them because that is what surprised me the most when I learned this for the first time.</p>
<p>A good mental model of Git empowered me to use it better. I’d heard that binary files and Git don’t go well together, but I only understood why recently: Git stores every version of every file, and binary files don’t compress very well (unlike text files), so they take up huge amounts of space. I’d also read about <a href="https://github.com/CocoaPods/CocoaPods/issues/4989#issuecomment-193772935">CocoaPods causing issues for GitHub</a>, and now I know that this is because the tree objects representing the <code>Specs</code> directory were very large and constantly getting updated, leading to a lot of stress on GitHub’s servers.</p>
<p>What else can you do with this power? You can…</p>
<ul>
<li><a href="https://github.com/vaibhavsagar/git-internals-workshop">Craft your own repositories</a></li>
<li>Run analytics on your commit graph when <code>git log</code> won’t cut it!</li>
<li><a href="https://github.com/vaibhavsagar/suppandi">Write a web API for your repository!</a></li>
<li><a href="https://github.com/mirage/irmin">Use Git as the backend of your application and get diffing/merging for free!</a></li>
</ul>
<p>The possibilities are endless!</p>
<p>If you’d like to learn more, you’re in luck! writing on this topic is plentiful and of extremely high quality. I started with the Git Book’s <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">chapter on Git Internals</a> and referred frequently to Vincent Hanquez’s <a href="https://github.com/vincenthz/hs-git/">hs-git</a> and Stefan Saasen’s <a href="http://stefan.saasen.me/articles/git-clone-in-haskell-from-the-bottom-up/">overwhelmingly thorough article</a> that implements enough of Git to do a <code>git clone</code> (!). Other resources include Mary Rose Cook’s excellent <a href="https://maryrosecook.com/blog/post/git-from-the-inside-out">Git from the inside out</a> and <a href="http://gitlet.maryrosecook.com/docs/gitlet.html">Gitlet</a> as well as John Wiegley’s <a href="https://jwiegley.github.io/git-from-the-bottom-up/">Git from the Bottom Up</a>. If nothing else, I hope the sheer proliferation of Git innards writing is enough to convince you that this is a useful and rewarding approach to learning about it.</p>
<p>Thanks to <a href="https://anniecherkaev.com/">Annie Cherkaev</a>, <a href="https://fineshambles.com/">Iain McCoy</a>, <a href="https://jaseemabid.github.io/">Jaseem Abid</a>, <a href="https://jship.github.io/">Jason Shipman</a>, <a href="http://teh.id.au/">Tim Humphries</a>, and <a href="https://viljetic.de/">Tomislav Viljetic</a> for comments, clarification, and suggestions.</p>
]]></summary>
</entry>

</feed>
