<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Vaibhav Sagar's blog</title>
    <link href="https://vaibhavsagar.com/atom.xml" rel="self" />
    <link href="https://vaibhavsagar.com" />
    <id>https://vaibhavsagar.com/atom.xml</id>
    <author>
        <name>Vaibhav Sagar</name>
        <email>vaibhavsagar@gmail.com</email>
    </author>
    <updated>2019-08-22T00:00:00Z</updated>
    <entry>
    <title>Industrial-strength Deployments in Three Commands</title>
    <link href="https://vaibhavsagar.com/blog/2019/08/22/industrial-strength-deployments/index.html" />
    <id>https://vaibhavsagar.com/blog/2019/08/22/industrial-strength-deployments/index.html</id>
    <published>2019-08-22T00:00:00Z</published>
    <updated>2019-08-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 22 August 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/nix/index.html">nix</a>, <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p>If your deployment target is running NixOS, a full-system deployment is only three commands:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1">$ <span class="ex">nix-copy-closure</span> --to --use-substitutes <span class="op">&lt;</span>target<span class="op">&gt;</span> <span class="op">&lt;</span>path<span class="op">&gt;</span>                                <span class="co">#1</span></a>
<a class="sourceLine" id="cb1-2" title="2">$ <span class="fu">ssh</span> <span class="op">&lt;</span>target<span class="op">&gt;</span> -- <span class="st">&quot;sudo nix-env --profile /nix/var/nix/profiles/system --set &lt;path&gt;&quot;</span>     <span class="co">#2</span></a>
<a class="sourceLine" id="cb1-3" title="3">$ <span class="fu">ssh</span> <span class="op">&lt;</span>target<span class="op">&gt;</span> -- <span class="st">&quot;sudo /nix/var/nix/profiles/system/bin/switch-to-configuration switch&quot;</span> <span class="co">#3</span></a></code></pre></div>
<p>Here’s what each command does:</p>
<ol type="1">
<li>Copies the transitive closure of the new system configuration to the target, using binary caches (<code>--use-substitutes</code>) where possible.</li>
<li>Sets the current system profile to the new system configuration. This isn’t strictly necessary, but allows us to roll back to this configuration later.</li>
<li>Switches to the new system configuration.</li>
</ol>
<p>This workflow has been described before <a href="https://typeclasses.com/nixos-on-aws">in Typeclasses</a> and <a href="http://www.haskellforall.com/2018/08/nixos-in-production.html">by Gabriel Gonzalez</a>, but I thought one more post demonstrating how to use these commands wouldn’t hurt. Since the AWS use case has been covered so thoroughly by Typeclasses, I’m going to use the <a href="https://www.packet.com/">packet.net</a> cloud instead.</p>
<h4 id="provisioning">Provisioning</h4>
<p>I logged on to the Packet console and launched a <code>t1.small.x86</code> instance running NixOS 19.03 (the latest as of this writing). It was assigned the IP address <code>147.75.38.113</code>. Since I added my SSH keys when I first created my Packet account, I was able to SSH into this instance at <code>root@147.75.38.113</code> without any further configuration.</p>
<h4 id="copying-the-existing-configuration">Copying the existing configuration</h4>
<p>The next step is to copy the existing configuration, especially instance-specific hardware configuration:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1">$ <span class="fu">scp</span> -r root@147.75.38.113:/etc/nixos/* .</a></code></pre></div>
<p>There’s probably a better way to do this, but for a quick one-off demonstration this is fine. <a href="https://github.com/vaibhavsagar/nixos-config/commit/e49e9a980f2d547684bcab3a34a34dba4521b991">Here’s the commit adding those files</a>.</p>
<p>We’ll only be making changes to <code>configuration.nix</code>, which for me looks like this (after all commented-out lines have been removed):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">{</span> <span class="ex">config</span>, pkgs, ... <span class="kw">}</span>:</a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">{</span></a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="ex">imports</span> =</a>
<a class="sourceLine" id="cb3-5" title="5">    [</a>
<a class="sourceLine" id="cb3-6" title="6">      <span class="ex">./packet.nix</span></a>
<a class="sourceLine" id="cb3-7" title="7">    ];</a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9">  <span class="ex">boot.loader.grub.enable</span> = true<span class="kw">;</span></a>
<a class="sourceLine" id="cb3-10" title="10">  <span class="ex">boot.loader.grub.version</span> = 2<span class="kw">;</span></a>
<a class="sourceLine" id="cb3-11" title="11"></a>
<a class="sourceLine" id="cb3-12" title="12">  <span class="ex">system.stateVersion</span> = <span class="st">&quot;19.03&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14"><span class="kw">}</span></a></code></pre></div>
<h4 id="building-a-system-closure">Building a system closure</h4>
<p>The Nix expression to build a whole system is pretty straightforward (as described in the Typeclasses article):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="ex">nixos</span> = import <span class="op">&lt;</span>nixpkgs/nixos<span class="op">&gt;</span> {</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="ex">configuration</span> = import ./configuration.nix<span class="kw">;</span></a>
<a class="sourceLine" id="cb4-4" title="4">  };</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">in</span></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="ex">nixos.system</span></a></code></pre></div>
<p>but this doesn’t provide any way of pinning <code>nixpkgs</code>. Another way (<a href="http://www.haskellforall.com/2018/08/nixos-in-production.html#pinning-nixpkgs">as described by Gabriel Gonzalez</a>), is to explicitly depend on a particular revision of <code>nixpkgs</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="ex">nixpkgs</span> = builtins.fetchTarball {</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="ex">url</span> = <span class="st">&quot;https://github.com/NixOS/nixpkgs/archive/b74b1cdb2fecc31ff7a127c5bc89771f887c93bb.tar.gz&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="ex">sha256</span> = <span class="st">&quot;0ncr4g29220amqm4riaa1xf4jz55v2nmh9fi16f1gzhww1gplk8h&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-5" title="5">  };</a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">in</span></a>
<a class="sourceLine" id="cb5-8" title="8">  <span class="ex">import</span> <span class="st">&quot;</span><span class="va">${nixpkgs}</span><span class="st">/nixos&quot;</span> {</a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="ex">configuration</span> = {</a>
<a class="sourceLine" id="cb5-10" title="10">      <span class="ex">imports</span> = [</a>
<a class="sourceLine" id="cb5-11" title="11">        <span class="ex">/etc/nixos/configuration.nix</span></a>
<a class="sourceLine" id="cb5-12" title="12">      ];</a>
<a class="sourceLine" id="cb5-13" title="13">    };</a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="ex">system</span> = <span class="st">&quot;x86_64-linux&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb5-16" title="16">  }</a></code></pre></div>
<p>but the downside there is that there’s no automated way to update the revision of <code>nixpkgs</code>. I have <a href="https://vaibhavsagar.com/blog/2018/05/27/quick-easy-nixpkgs-pinning/">my own approach to pinning <code>nixpkgs</code></a>, where I have a <code>versions.json</code> that stores version information:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb6-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="dt">&quot;nixpkgs&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="dt">&quot;owner&quot;</span><span class="fu">:</span> <span class="st">&quot;NixOS&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="dt">&quot;repo&quot;</span><span class="fu">:</span> <span class="st">&quot;nixpkgs-channels&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="dt">&quot;branch&quot;</span><span class="fu">:</span> <span class="st">&quot;nixos-19.03&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="dt">&quot;rev&quot;</span><span class="fu">:</span> <span class="st">&quot;77295b0bd26555c39a1ba9c1da72dbdb651fd280&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="dt">&quot;sha256&quot;</span><span class="fu">:</span> <span class="st">&quot;18v866h12xk6l1s37nk1vns869pvzphmnnlhrnm2b1zklg2hd1nq&quot;</span></a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="fu">}</span></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="fu">}</span></a></code></pre></div>
<p>and a script that uses <code>jq</code> to update this file. My (slightly more complex) expression then looks like this:</p>
<p><em>default.nix</em></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="ex">fetcher</span> = { owner, repo, rev, sha256, ... }: <span class="ex">builtins.fetchTarball</span> {</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="ex">inherit</span> sha256<span class="kw">;</span></a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="ex">url</span> = <span class="st">&quot;https://github.com/</span><span class="va">${owner}</span><span class="st">/</span><span class="va">${repo}</span><span class="st">/tarball/</span><span class="va">${rev}</span><span class="st">&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-5" title="5">  };</a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="ex">nixpkgs</span> = fetcher (builtins.fromJSON (builtins.readFile ./versions.json))<span class="ex">.nixpkgs</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb7-7" title="7">  <span class="ex">nixos</span> = import <span class="st">&quot;</span><span class="va">${nixpkgs}</span><span class="st">/nixos&quot;</span> {</a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="ex">configuration</span> = import ./configuration.nix<span class="kw">;</span></a>
<a class="sourceLine" id="cb7-9" title="9">  };</a>
<a class="sourceLine" id="cb7-10" title="10"><span class="kw">in</span></a>
<a class="sourceLine" id="cb7-11" title="11">  <span class="ex">nixos.system</span></a></code></pre></div>
<p>and this allows me to both be explicit about <code>nixpkgs</code> as well as easily update it when necessary. <a href="https://github.com/vaibhavsagar/nixos-config/commit/5126d9dba971d6480aeec43c4263c5a7f7b1f1b5">Here’s the commit that adds those files</a>.</p>
<h4 id="deploying-the-system-closure">Deploying the system closure</h4>
<p>With all of our prerequisites taken care of, deploying the system closure is straightforward:</p>
<p><em>deploy.sh</em></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="co">#!/usr/bin/env bash</span></a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">set</span> <span class="ex">-euxo</span> pipefail</a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="va">TARGET=</span><span class="st">&quot;root@147.75.38.113&quot;</span></a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="va">PROFILE_PATH=</span><span class="st">&quot;</span><span class="va">$(</span><span class="ex">nix-build</span> --no-out-link default.nix<span class="va">)</span><span class="st">&quot;</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="ex">nix-copy-closure</span> --to --use-substitutes <span class="va">$TARGET</span> <span class="va">$PROFILE_PATH</span></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="fu">ssh</span> <span class="va">$TARGET</span> -- <span class="st">&quot;nix-env --profile /nix/var/nix/profiles/system --set </span><span class="va">$PROFILE_PATH</span><span class="st"> &amp;&amp; /nix/var/nix/profiles/system/bin/switch-to-configuration switch&quot;</span></a></code></pre></div>
<p>This takes care of both building the new system closure and deploying it.</p>
<p><a href="https://github.com/vaibhavsagar/nixos-config/commit/be6aaa026c8ebf1efd7c44743a8770b921111a2e">Here’s the commit that adds <code>deploy.sh</code></a>.</p>
<h4 id="adding-a-service">Adding a service</h4>
<p>Let’s deploy the final version of the small Haskell web service from my <a href="https://vaibhavsagar.com/blog/2019/07/04/functional-devops/">Functional DevOps</a> post. The application consists of two files:</p>
<p><em>Main.hs</em></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"> <span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">import</span> <span class="dt">Web.Scotty</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</a>
<a class="sourceLine" id="cb9-5" title="5"></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="kw">import</span> <span class="dt">Data.Monoid</span> (mconcat)</a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8">main <span class="ot">=</span> getArgs <span class="op">&gt;&gt;=</span> \(port<span class="op">:</span>_) <span class="ot">-&gt;</span> scotty (<span class="fu">read</span> port) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-9" title="9">    get <span class="st">&quot;/:word&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-10" title="10">        beam <span class="ot">&lt;-</span> param <span class="st">&quot;word&quot;</span></a>
<a class="sourceLine" id="cb9-11" title="11">        html <span class="op">$</span> <span class="fu">mconcat</span> [<span class="st">&quot;&lt;h1&gt;Scotty, &quot;</span>, beam, <span class="st">&quot; me up!&lt;/h1&gt;&quot;</span>]</a></code></pre></div>
<p><em>blank-me-up.cabal</em></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb10-1" title="1">name:                blank-me-up</a>
<a class="sourceLine" id="cb10-2" title="2">version:             0.1.0.0</a>
<a class="sourceLine" id="cb10-3" title="3">license:             BSD3</a>
<a class="sourceLine" id="cb10-4" title="4">build-type:          Simple</a>
<a class="sourceLine" id="cb10-5" title="5">cabal-version:       &gt;=1.10</a>
<a class="sourceLine" id="cb10-6" title="6"></a>
<a class="sourceLine" id="cb10-7" title="7">executable blank-me-up</a>
<a class="sourceLine" id="cb10-8" title="8">  main-is:             Main.hs</a>
<a class="sourceLine" id="cb10-9" title="9">  build-depends:       base &gt;=4.9 &amp;&amp; &lt;5</a>
<a class="sourceLine" id="cb10-10" title="10">                     , scotty</a>
<a class="sourceLine" id="cb10-11" title="11">  default-language:    Haskell2010</a></code></pre></div>
<p>and the Nix service is one file:</p>
<p><em>service.nix</em></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">{</span> <span class="ex">config</span>, lib, pkgs, ... <span class="kw">}</span>:</a>
<a class="sourceLine" id="cb11-2" title="2"></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="bu">let</span></a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="ex">blank-me-up</span> = pkgs.haskellPackages.callCabal2nix <span class="st">&quot;blank-me-up&quot;</span> ../app {};</a>
<a class="sourceLine" id="cb11-5" title="5">  <span class="ex">cfg</span> = config.services.blank-me-up<span class="kw">;</span></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="kw">in</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb11-7" title="7">  <span class="ex">options.services.blank-me-up.enable</span> = lib.mkEnableOption <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb11-8" title="8">  <span class="ex">options.services.blank-me-up.port</span> = lib.mkOption {</a>
<a class="sourceLine" id="cb11-9" title="9">    <span class="ex">default</span> = 3000<span class="kw">;</span></a>
<a class="sourceLine" id="cb11-10" title="10">    <span class="bu">type</span> = lib.types.int<span class="kw">;</span></a>
<a class="sourceLine" id="cb11-11" title="11">  <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb11-12" title="12"></a>
<a class="sourceLine" id="cb11-13" title="13">  <span class="ex">config</span> = lib.mkIf cfg.enable {</a>
<a class="sourceLine" id="cb11-14" title="14">    <span class="ex">networking.firewall.allowedTCPPorts</span> = [ cfg.port ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb11-15" title="15"></a>
<a class="sourceLine" id="cb11-16" title="16">    <span class="ex">systemd.services.blank-me-up</span> = {</a>
<a class="sourceLine" id="cb11-17" title="17">      <span class="ex">description</span> = <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb11-18" title="18">      <span class="ex">after</span> = [ <span class="st">&quot;network.target&quot;</span> ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb11-19" title="19">      <span class="ex">wantedBy</span> = [ <span class="st">&quot;multi-user.target&quot;</span> ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb11-20" title="20">      <span class="ex">serviceConfig</span> = {</a>
<a class="sourceLine" id="cb11-21" title="21">        <span class="ex">ExecStart</span> = <span class="st">&quot;</span><span class="va">${blank-</span>me-up<span class="va">}</span><span class="st">/bin/blank-me-up </span><span class="va">${toString</span><span class="er"> cfg.port</span><span class="va">}</span><span class="st">&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb11-22" title="22">        <span class="ex">Restart</span> = <span class="st">&quot;always&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb11-23" title="23">        <span class="ex">KillMode</span> = <span class="st">&quot;process&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb11-24" title="24">      };</a>
<a class="sourceLine" id="cb11-25" title="25">    };</a>
<a class="sourceLine" id="cb11-26" title="26">  };</a>
<a class="sourceLine" id="cb11-27" title="27">}</a></code></pre></div>
<p>For more information about what’s happening in <code>service.nix</code>, see <a href="https://vaibhavsagar.com/blog/2019/07/04/functional-devops/#service-configuration">the relevant section of my Functional DevOps post</a>.</p>
<p><a href="https://github.com/vaibhavsagar/nixos-config/commit/466e0e1867e47346ed8cc706b812a8cb21c76c19">Here’s the commit that adds these files</a>.</p>
<p>Enabling the service is as easy as adding two lines to <code>configuration.nix</code>:</p>
<p><em>configuration.nix</em></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">{</span> <span class="ex">config</span>, pkgs, ... <span class="kw">}</span>:</a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="kw">{</span></a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="ex">imports</span> =</a>
<a class="sourceLine" id="cb12-5" title="5">    [</a>
<a class="sourceLine" id="cb12-6" title="6">      <span class="ex">./packet.nix</span></a>
<a class="sourceLine" id="cb12-7" title="7">      <span class="ex">./deploy/nix/service.nix</span>        <span class="co">#1</span></a>
<a class="sourceLine" id="cb12-8" title="8">    ];</a>
<a class="sourceLine" id="cb12-9" title="9"></a>
<a class="sourceLine" id="cb12-10" title="10">  <span class="ex">boot.loader.grub.enable</span> = true<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-11" title="11">  <span class="ex">boot.loader.grub.version</span> = 2<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-12" title="12"></a>
<a class="sourceLine" id="cb12-13" title="13">  <span class="ex">services.blank-me-up.enable</span> = true<span class="kw">;</span> <span class="co">#2</span></a>
<a class="sourceLine" id="cb12-14" title="14"></a>
<a class="sourceLine" id="cb12-15" title="15">  <span class="ex">system.stateVersion</span> = <span class="st">&quot;19.03&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-16" title="16"></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="kw">}</span></a></code></pre></div>
<p><a href="https://github.com/vaibhavsagar/nixos-config/commit/07b163f3c0fe728078bb357841e57c7020bdd4d3">Here’s the commit that makes that change</a>.</p>
<h4 id="deploying-the-service">Deploying the service</h4>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" title="1">$ <span class="ex">./deploy.sh</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ex">+</span> TARGET=root@147.75.38.113</a>
<a class="sourceLine" id="cb13-3" title="3"><span class="ex">++</span> nix-build --no-out-link default.nix</a>
<a class="sourceLine" id="cb13-4" title="4"><span class="ex">+</span> PROFILE_PATH=/nix/store/<span class="op">&lt;</span>hash<span class="op">&gt;</span>-nixos-system-nixos-19.03pre-git</a>
<a class="sourceLine" id="cb13-5" title="5"><span class="ex">+</span> nix-copy-closure --to --use-substitutes root@147.75.38.113 /nix/store/<span class="op">&lt;</span>hash<span class="op">&gt;</span>-nixos-system-nixos-19.03pre-git</a>
<a class="sourceLine" id="cb13-6" title="6"><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="ex">+</span> ssh root@147.75.38.113 -- <span class="st">&#39;nix-env --profile /nix/var/nix/profiles/system --set /nix/store/&lt;hash&gt;-nixos-system-nixos-19.03pre-git &amp;&amp; /nix/var/nix/profiles/system/bin/switch-to-configuration switch&#39;</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="ex">updating</span> GRUB 2 menu...</a>
<a class="sourceLine" id="cb13-9" title="9"><span class="ex">activating</span> the configuration...</a>
<a class="sourceLine" id="cb13-10" title="10"><span class="ex">setting</span> up /etc...</a>
<a class="sourceLine" id="cb13-11" title="11"><span class="ex">reloading</span> user units for root...</a>
<a class="sourceLine" id="cb13-12" title="12"><span class="ex">setting</span> up tmpfiles</a>
<a class="sourceLine" id="cb13-13" title="13"></a>
<a class="sourceLine" id="cb13-14" title="14">$ <span class="ex">curl</span> http://147.75.38.113:3000/beam</a>
<a class="sourceLine" id="cb13-15" title="15"><span class="op">&lt;</span><span class="ex">h1</span><span class="op">&gt;</span>Scotty, beam me up!<span class="op">&lt;</span>/h1<span class="op">&gt;</span></a></code></pre></div>
<h4 id="but-this-is-just-a-janky-bash-script">But this is just a janky bash script!!???</h4>
<p>It’s definitely the case that <code>deploy.sh</code> is short and unsophisticated, but the three commands it invokes are what’s really important here. Once you begin looking for them, you will find them everywhere, since they’re the best way of deploying to NixOS! They’re used in <a href="https://github.com/NixOS/nixops/blob/c8d3a3ff5fb20e8e4d494de972ebb2a1a1ec1e08/nixops/backends/__init__.py#L339-L367">NixOps</a>, <a href="https://github.com/awakesecurity/nix-deploy/blob/68217cea7ba6746c9a262ddccb11178909841988/src/Main.hs#L159-L229">nix-deploy</a>, and <a href="https://github.com/obsidiansystems/obelisk/blob/1f9f466fc38a37a72afb316cee4f3317af204220/lib/command/src/Obelisk/Command/Deploy.hs#L136-L158">obelisk</a>, and a quick GitHub search for <a href="https://github.com/search?q=switch-to-configuration&amp;type=Code">“switch-to-configuration”</a> turns up many more examples. At a previous job, our deployment platform used these three commands as well, and we routinely deployed to hundreds of servers without any deployment-related issues, so I’m comfortable saying that this is an industrial-grade deployment solution.</p>
<h4 id="what-about-provisioning">What about provisioning?</h4>
<p>These tools don’t care how you provision your servers, as long as you end up with NixOS targets you can SSH into. For quick demonstrations and small deployments, manual provisioning is fine, but for anything beyond that, I’d recommend using a tool like <a href="https://www.terraform.io/">Terraform</a>. You can even specify your Terraform configuration with Nix using something like <a href="https://github.com/mrVanDalo/terranix">terranix</a>, and this is in fact what we did at the previous job I mentioned earlier, since Nix makes a great templating language and comes with excellent support for producing JSON which can then be fed into Terraform. It’s also possible to output YAML from Nix, which means it’s easy to interoperate with most infrastructure tooling.</p>
<h4 id="should-i-use-this-instead-of-my-current-deployment-solution">Should I use this instead of my current deployment solution?</h4>
<p>My aim with this post is not to convince you to drop whatever you’re currently using in favour of a hand-rolled bash script and NixOS, especially if your current solution works well for you. I do, however, want to encourage you to think about how the process I’ve outlined here compares. In which ways is it better or worse?</p>
<p>Since this is the workflow I’ve had the most experience with, it was a rude shock to start working with container-based deployments where even tiny changes require a full (slow) rebuild, and the actual deployment lifecycle is more complex and error-prone. I think it’s important to point out that things don’t have to be this way.</p>
<p>In my <a href="https://vaibhavsagar.com/blog/2019/07/04/functional-devops/">Functional DevOps</a> post, I outlined some characteristics of an ideal DevOps workflow, and I think the process I’ve outlined here meets them all:</p>
<ul>
<li><strong>Automatic</strong>: The process is completely scriptable.</li>
<li><strong>Repeatable</strong>: I can leverage NixOS to get the same results every time.</li>
<li><strong>Idempotent</strong>: Deploying the same thing a second time is a no-op.</li>
<li><strong>Reversible</strong>: Rolling back is very easy.</li>
<li><strong>Atomic</strong>: A deploy either fails or succeeds, there’s no weird in-between.</li>
</ul>
<p>I think this is pretty great for three commands. I hope this blog post can help move us towards better systems by making this corner of NixOS more approachable!</p>
]]></summary>
</entry>
<entry>
    <title>Easy IHaskell Docker Images with Nix</title>
    <link href="https://vaibhavsagar.com/blog/2019/08/11/ihaskell-nix-docker/index.html" />
    <id>https://vaibhavsagar.com/blog/2019/08/11/ihaskell-nix-docker/index.html</id>
    <published>2019-08-11T00:00:00Z</published>
    <updated>2019-08-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 11 August 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/nix/index.html">nix</a>
    
</div>

<p>Today I learned how to turn an IHaskell Nix expression into a Docker image. Here is an example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="co"># default.nix</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="bu">let</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="ex">pkgs</span> = {</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="ex">ihaskell</span> = builtins.fetchTarball {</a>
<a class="sourceLine" id="cb1-5" title="5">      <span class="ex">url</span> = <span class="st">&quot;https://github.com/gibiansky/IHaskell/tarball/93bfa3a7a434c1dfe6873c2105c43856c282e183&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-6" title="6">      <span class="ex">sha256</span> = <span class="st">&quot;1cvqqmpvz7s3d7zclmkm5igx36clrbdiafs47i9rik3rdzw0gr3d&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-7" title="7">    };</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="ex">nixpkgs</span> = builtins.fetchTarball {</a>
<a class="sourceLine" id="cb1-9" title="9">      <span class="ex">url</span> = <span class="st">&quot;https://github.com/NixOS/nixpkgs-channels/tarball/9ca57dc9171ca4547abf076a8987ed73c46f2e15&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-10" title="10">      <span class="ex">sha256</span> = <span class="st">&quot;18d01cw6s6k9fnac3vq0k6inybqalkz4ak88pw67q4wqzq9rc07l&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-11" title="11">    };</a>
<a class="sourceLine" id="cb1-12" title="12">  };</a>
<a class="sourceLine" id="cb1-13" title="13">  <span class="ex">nixpkgs</span> = import pkgs.nixpkgs {};</a>
<a class="sourceLine" id="cb1-14" title="14">  <span class="ex">NB_USER</span> = <span class="st">&quot;jovyan&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-15" title="15">  <span class="ex">NB_UID</span> = <span class="st">&quot;1000&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-16" title="16">  <span class="ex">dockerEtc</span> = nixpkgs.runCommand <span class="st">&quot;docker-etc&quot;</span> {} <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-17" title="17">    <span class="fu">mkdir</span> -p <span class="va">$out</span>/etc/pam.d</a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19">    <span class="bu">echo</span> <span class="st">&quot;root:x:0:0::/root:/bin/sh&quot;</span> <span class="op">&gt;</span> <span class="va">$out</span>/etc/passwd</a>
<a class="sourceLine" id="cb1-20" title="20">    <span class="bu">echo</span> <span class="st">&quot;jovyan:x:1000:1000::/home/jovyan:&quot;</span> <span class="op">&gt;&gt;</span> <span class="va">$out</span>/etc/passwd</a>
<a class="sourceLine" id="cb1-21" title="21">    <span class="bu">echo</span> <span class="st">&quot;root:!x:::::::&quot;</span> <span class="op">&gt;</span> <span class="va">$out</span>/etc/shadow</a>
<a class="sourceLine" id="cb1-22" title="22">    <span class="bu">echo</span> <span class="st">&quot;jovyan:!:::::::&quot;</span> <span class="op">&gt;&gt;</span> <span class="va">$out</span>/etc/shadow</a>
<a class="sourceLine" id="cb1-23" title="23"></a>
<a class="sourceLine" id="cb1-24" title="24">    <span class="bu">echo</span> <span class="st">&quot;root:x:0:&quot;</span> <span class="op">&gt;</span> <span class="va">$out</span>/etc/group</a>
<a class="sourceLine" id="cb1-25" title="25">    <span class="bu">echo</span> <span class="st">&quot;jovyan:x:1000:&quot;</span> <span class="op">&gt;&gt;</span> <span class="va">$out</span>/etc/group</a>
<a class="sourceLine" id="cb1-26" title="26">    <span class="bu">echo</span> <span class="st">&quot;root:x::&quot;</span> <span class="op">&gt;</span> <span class="va">$out</span>/etc/gshadow</a>
<a class="sourceLine" id="cb1-27" title="27">    <span class="bu">echo</span> <span class="st">&quot;jovyan:!::&quot;</span> <span class="op">&gt;&gt;</span> <span class="va">$out</span>/etc/gshadow</a>
<a class="sourceLine" id="cb1-28" title="28">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb1-29" title="29">  <span class="ex">ihaskell</span> = import <span class="st">&quot;</span><span class="va">${pkgs</span><span class="er">.ihaskell</span><span class="va">}</span><span class="st">/release.nix&quot;</span> {</a>
<a class="sourceLine" id="cb1-30" title="30">    <span class="ex">inherit</span> nixpkgs<span class="kw">;</span></a>
<a class="sourceLine" id="cb1-31" title="31">    <span class="ex">compiler</span> = <span class="st">&quot;ghc864&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-32" title="32">    <span class="ex">packages</span> = self: with self<span class="kw">;</span> [];</a>
<a class="sourceLine" id="cb1-33" title="33">  };</a>
<a class="sourceLine" id="cb1-34" title="34"><span class="kw">in</span> <span class="ex">nixpkgs.dockerTools.buildLayeredImage</span> {</a>
<a class="sourceLine" id="cb1-35" title="35">    <span class="ex">name</span> = <span class="st">&quot;ihaskell-nix&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-36" title="36">    <span class="ex">tag</span> = <span class="st">&quot;latest&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-37" title="37">    <span class="ex">contents</span> =  [</a>
<a class="sourceLine" id="cb1-38" title="38">      <span class="ex">dockerEtc</span></a>
<a class="sourceLine" id="cb1-39" title="39">      <span class="ex">ihaskell</span></a>
<a class="sourceLine" id="cb1-40" title="40">      <span class="ex">nixpkgs.bashInteractive</span></a>
<a class="sourceLine" id="cb1-41" title="41">    ];</a>
<a class="sourceLine" id="cb1-42" title="42">    <span class="ex">config</span> = {</a>
<a class="sourceLine" id="cb1-43" title="43">      <span class="ex">Cmd</span> = [<span class="st">&quot;ihaskell-notebook&quot;</span> <span class="st">&quot;--ip&quot;</span> <span class="st">&quot;0.0.0.0&quot;</span>]<span class="kw">;</span></a>
<a class="sourceLine" id="cb1-44" title="44">      <span class="ex">User</span> = NB_USER<span class="kw">;</span></a>
<a class="sourceLine" id="cb1-45" title="45">      <span class="ex">WorkingDir</span> = <span class="st">&quot;/home/</span><span class="va">${NB_USER}</span><span class="st">&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb1-46" title="46">    };</a>
<a class="sourceLine" id="cb1-47" title="47">    <span class="ex">extraCommands</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb1-48" title="48">      <span class="fu">mkdir</span> -m 1777 ./tmp</a>
<a class="sourceLine" id="cb1-49" title="49">      <span class="fu">mkdir</span> -m 777 -p ./home/<span class="va">${NB_USER}</span></a>
<a class="sourceLine" id="cb1-50" title="50">    <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb1-51" title="51">    <span class="ex">maxLayers</span> = 100<span class="kw">;</span></a>
<a class="sourceLine" id="cb1-52" title="52">};</a></code></pre></div>
<p>This is how to use it:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1">$ <span class="ex">docker</span> load <span class="op">&lt;</span> <span class="va">$(</span><span class="ex">nix-build</span> default.nix<span class="va">)</span></a>
<a class="sourceLine" id="cb2-2" title="2">$ <span class="ex">docker</span> run -p8888:8888 -it ihaskell-nix:latest</a></code></pre></div>
<p>This uses IHaskell’s <a href="https://github.com/gibiansky/IHaskell/blob/93bfa3a7a434c1dfe6873c2105c43856c282e183/release.nix">built-in <code>release.nix</code></a> to do most of the heavy lifting for IHaskell itself, and does a couple of other things:</p>
<ol type="1">
<li>Creates the <code>/tmp</code> directory</li>
<li>Sets up a <code>jovyan</code> user, because Jupyter complains when run as <code>root</code></li>
<li>Includes <code>bash</code>, which is not strictly necessary but is useful for poking around in the image and for using <code>:!</code> from within a notebook</li>
</ol>
<p>Building the image and loading it into Docker are both very slow compared to using Nix directly (even though I’m using the Nix support for layered images), so I wouldn’t recommend using this approach for local development. I’m primarily interested in doing this to:</p>
<ol type="1">
<li>Share IHaskell notebooks with people who are less comfortable with Nix</li>
<li>Deploy to platforms such as Amazon’s Elastic Container Service and Google’s App Engine, which offer excellent support for Docker and no support for Nix</li>
</ol>
<p>Unfortunately this isn’t quite ready to deploy yet, especially because Jupyter uses token-based authentication by default and the console output will not necessarily be available after deployment. It’s possible to set a password instead, so I expect that copying the output of <code>jupyter notebook --generate-config</code> and changing the relevant settings will be enough. I hope to post instructions when I get around to trying this myself.</p>
<p>In the meantime, I hope this is useful as a way of making IHaskell even more widely available, and as a demonstration of using <code>dockerTools</code> to bridge the gap between Nix and Docker!</p>
<p><em>Thanks to <a href="https://grahamc.com">Graham Christensen</a> for improving the Nix expression to use <code>buildLayeredImage</code>.</em></p>
]]></summary>
</entry>
<entry>
    <title>Functional DevOps in a Dysfunctional World</title>
    <link href="https://vaibhavsagar.com/blog/2019/07/04/functional-devops/index.html" />
    <id>https://vaibhavsagar.com/blog/2019/07/04/functional-devops/index.html</id>
    <published>2019-07-04T00:00:00Z</published>
    <updated>2019-07-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on  4 July 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/nix/index.html">nix</a>, <a href="/blog/tags/devops/index.html">devops</a>
    
</div>

<p><em>This is a pseudo-transcript of <a href="https://www.youtube.com/watch?v=RsSNEkBGmj0">a presentation I gave at the linux.conf.au 2018 Real World Functional Programming Miniconf</a>.</em></p>
<p>What is DevOps about? For me it’s about my relationship to the phrase</p>
<blockquote>
<p>It works on my machine.</p>
</blockquote>
<p>I’ve been guilty of saying this in the past, and quite frankly, it isn’t good enough. After the development team has written their last line of code, some amount of work still needs to happen in order for the software to deliver value.</p>
<p>A few jobs ago I was at a small web development shop, and my deployment workflow was as follows:</p>
<ol type="1">
<li>Log on to the development server and take careful notes on how it had diverged from the production server.</li>
<li>Carefully set aside some time to ‘do the deploy’.</li>
<li>Log on to the production server and do a <code>git pull</code> to get the latest code changes.</li>
<li>Perform database migrations according to the notes you made earlier.</li>
<li>Manually make any other required changes.</li>
</ol>
<p>Despite my best efforts, I would inevitably run into issues whenever I did this, resulting in site outages and frustrated clients. This was far from ideal, but I wasn’t able to articulate why at the time.</p>
<p>I posit that a better deployment process has the following properties:</p>
<ul>
<li><p><strong>Automatic</strong>: instead of a manual multi-step process, it has a single step, which can be performed automatically.</p></li>
<li><p><strong>Repeatable</strong>: instead of only being able to deploy to one lovingly hand-maintained server, it can deploy reliably multiple times to multiple servers.</p></li>
<li><p><strong>Idempotent</strong>: if the target is already in the desired state, no extra work needs to be done.</p></li>
<li><p><strong>Reversible</strong>: if it turns out I made a mistake, I can go back to the previous state.</p></li>
<li><p><strong>Atomic</strong>: an external observer can only see the new state or the old state, not any intermediate state.</p></li>
</ul>
<p>I hope to demonstrate how the Nix suite of tools (Nix, NixOS, and NixOps) fulfill these properties and provide a better DevOps experience.</p>
<p>To make things easier, I’m not assuming that you already run NixOS. Any Linux distro should do, as long as you’ve <a href="https://nixos.org/nix/download.html">installed Nix</a>. macOS users will be able to follow along until I get to the NixOps section.</p>
<h2 id="shipping-it">Shipping it</h2>
<h3 id="packaging">Packaging</h3>
<p>Suppose we have been given a small Haskell app to get up and running:</p>
<p><em>Main.hs</em></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="dt">Web.Scotty</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="dt">Data.Monoid</span> (mconcat)</a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7">main <span class="ot">=</span> scotty <span class="dv">3000</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-8" title="8">    get <span class="st">&quot;/:word&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-9" title="9">        beam <span class="ot">&lt;-</span> param <span class="st">&quot;word&quot;</span></a>
<a class="sourceLine" id="cb1-10" title="10">        html <span class="op">$</span> <span class="fu">mconcat</span> [<span class="st">&quot;&lt;h1&gt;Scotty, &quot;</span>, beam, <span class="st">&quot; me up!&lt;/h1&gt;&quot;</span>]</a></code></pre></div>
<p><em>blank-me-up.cabal</em></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">name<span class="op">:</span>                blank<span class="op">-</span>me<span class="op">-</span>up</a>
<a class="sourceLine" id="cb2-2" title="2">version<span class="op">:</span>             <span class="fl">0.1</span><span class="op">.</span><span class="fl">0.0</span></a>
<a class="sourceLine" id="cb2-3" title="3">license<span class="op">:</span>             <span class="dt">BSD3</span></a>
<a class="sourceLine" id="cb2-4" title="4">build<span class="op">-</span><span class="kw">type</span><span class="op">:</span>          <span class="dt">Simple</span></a>
<a class="sourceLine" id="cb2-5" title="5">cabal<span class="op">-</span>version<span class="op">:</span>       <span class="op">&gt;=</span><span class="fl">1.10</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">executable blank<span class="op">-</span>me<span class="op">-</span>up</a>
<a class="sourceLine" id="cb2-8" title="8">  main<span class="op">-</span>is<span class="op">:</span>             Main.hs</a>
<a class="sourceLine" id="cb2-9" title="9">  build<span class="op">-</span>depends<span class="op">:</span>       base <span class="op">&gt;=</span><span class="fl">4.9</span> <span class="op">&amp;&amp;</span> <span class="op">&lt;</span><span class="dv">5</span></a>
<a class="sourceLine" id="cb2-10" title="10">                     , scotty</a>
<a class="sourceLine" id="cb2-11" title="11">  default<span class="op">-</span>language<span class="op">:</span>    <span class="dt">Haskell2010</span></a></code></pre></div>
<p>(This example is taken straight from <a href="https://github.com/scotty-web/scotty/blob/306fee7121dc41a55bd4e9b785f8366198de7e3c/README.md#scotty-">Scotty’s README</a>.)</p>
<p>Our first step is to build this app and quickly check that it works. We’ll need Nix and <code>cabal2nix</code>, which turns <code>.cabal</code> files into configuration for the Nix package manager. Assuming we’ve installed <code>cabal2nix</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1">$ <span class="ex">nix-env</span> -i cabal2nix</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="op">&lt;</span><span class="ex">a</span> lot of output<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="ex">created</span> <span class="op">&lt;</span>number<span class="op">&gt;</span> symlinks in user environment</a></code></pre></div>
<p>How do we know it worked? Try <code>nix-env -q</code> (short for <code>--query</code>):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1">$ <span class="ex">nix-env</span> -q</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="ex">cabal2nix</span></a></code></pre></div>
<p>Okay, assuming the app is in the <code>app</code> subdirectory, let’s create a directory called <code>nix</code> to store our <code>.nix</code> files and begin:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1">$ <span class="bu">cd</span> nix</a>
<a class="sourceLine" id="cb5-2" title="2">$ <span class="ex">cabal2nix</span> ../app/ --shell <span class="op">&gt;</span> default.nix</a></code></pre></div>
<p><code>default.nix</code> might look something like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">{</span> <span class="ex">nixpkgs</span> ? import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {<span class="kw">}</span>, <span class="ex">compiler</span> ? <span class="st">&quot;default&quot;</span> }:</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="bu">let</span></a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="ex">inherit</span> (nixpkgs) <span class="ex">pkgs</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7">  <span class="ex">f</span> = { mkDerivation, base, scotty, stdenv }:</a>
<a class="sourceLine" id="cb6-8" title="8">      <span class="ex">mkDerivation</span> {</a>
<a class="sourceLine" id="cb6-9" title="9">        <span class="ex">pname</span> = <span class="st">&quot;blank-me-up&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-10" title="10">        <span class="ex">version</span> = <span class="st">&quot;0.1.0.0&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-11" title="11">        <span class="ex">src</span> = ../app<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-12" title="12">        <span class="ex">isLibrary</span> = false<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-13" title="13">        <span class="ex">isExecutable</span> = true<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-14" title="14">        <span class="ex">executableHaskellDepends</span> = [ base scotty ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-15" title="15">        <span class="ex">license</span> = stdenv.lib.licenses.bsd3<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-16" title="16">      };</a>
<a class="sourceLine" id="cb6-17" title="17"></a>
<a class="sourceLine" id="cb6-18" title="18">  <span class="ex">haskellPackages</span> = if compiler == <span class="st">&quot;default&quot;</span></a>
<a class="sourceLine" id="cb6-19" title="19">                       <span class="kw">then</span> <span class="ex">pkgs.haskellPackages</span></a>
<a class="sourceLine" id="cb6-20" title="20">                       <span class="kw">else</span> <span class="ex">pkgs.haskell.packages.</span><span class="va">${compiler}</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-21" title="21"></a>
<a class="sourceLine" id="cb6-22" title="22">  <span class="ex">drv</span> = haskellPackages.callPackage f {};</a>
<a class="sourceLine" id="cb6-23" title="23"></a>
<a class="sourceLine" id="cb6-24" title="24"><span class="kw">in</span></a>
<a class="sourceLine" id="cb6-25" title="25"></a>
<a class="sourceLine" id="cb6-26" title="26">  <span class="kw">if</span> <span class="ex">pkgs.lib.inNixShell</span> then drv.env else drv</a></code></pre></div>
<p>Now we can build our project by running <code>nix-build</code>, which tries to build <code>default.nix</code> in the current directory if no arguments are provided:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1">$ <span class="ex">nix-build</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="op">&lt;</span><span class="ex">lots</span> of output<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ex">/nix/store</span>/<span class="op">&lt;</span><span class="bu">hash</span><span class="op">&gt;</span>-blank-me-up-0.1.0.0</a></code></pre></div>
<p>There should also be a new <code>result</code> symlink in the current directory, which points to the path above:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1">$ <span class="fu">readlink</span> result</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ex">/nix/store</span>/<span class="op">&lt;</span><span class="bu">hash</span><span class="op">&gt;</span>-blank-me-up-0.1.0.0</a></code></pre></div>
<p>Notice that we’ve built a Haskell executable without having to directly deal with any Haskell-specific tooling (unless you count <code>cabal2nix</code>). Nix works best if you allow it full control over builds, as we do here.</p>
<p>What happens if we run <code>nix-build</code> again without changing anything?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1">$ <span class="ex">nix-build</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ex">/nix/store</span>/<span class="op">&lt;</span><span class="bu">hash</span><span class="op">&gt;</span>-blank-me-up-0.1.0.0</a></code></pre></div>
<p>It should be nearly instantaneous and not require rebuilding anything. Nix tries to think of build outputs as a pure function of its inputs, and since our inputs are unchanged, it is able to give us back the same path that it did before. This is what I mean when I say Nix is declarative.</p>
<p>What if we break our app:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode diff"><code class="sourceCode diff"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">--- a/functional-devops/app/Main.hs</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="dt">+++ b/functional-devops/app/Main.hs</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="dt">@@ -4,6 +4,8 @@ import Web.Scotty</span></a>
<a class="sourceLine" id="cb10-4" title="4"></a>
<a class="sourceLine" id="cb10-5" title="5"> import Data.Monoid (mconcat)</a>
<a class="sourceLine" id="cb10-6" title="6"></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="va">+broken</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="va">+</span></a>
<a class="sourceLine" id="cb10-9" title="9"> main = scotty 3000 $ do</a>
<a class="sourceLine" id="cb10-10" title="10">     get &quot;/:word&quot; $ do</a>
<a class="sourceLine" id="cb10-11" title="11">         beam &lt;- param &quot;word&quot;</a></code></pre></div>
<p>and try to build again?</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1">$ <span class="ex">nix-build</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="ex">Building</span> executable <span class="st">&#39;blank-me-up&#39;</span> for blank-me-up-0.1.0.0..</a>
<a class="sourceLine" id="cb11-4" title="4">[<span class="ex">1</span> of 1] Compiling Main             ( Main.hs, dist/build/blank-me-up/blank-me-up-tmp/Main.o )</a>
<a class="sourceLine" id="cb11-5" title="5"></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="ex">Main.hs</span>:7:1: error:</a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="ex">Parse</span> error: module header, import declaration</a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="ex">or</span> top-level declaration expected.</a>
<a class="sourceLine" id="cb11-9" title="9">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb11-10" title="10"><span class="ex">7</span> <span class="kw">|</span> <span class="ex">broken</span></a>
<a class="sourceLine" id="cb11-11" title="11">  <span class="kw">|</span> ^^^^^^</a>
<a class="sourceLine" id="cb11-12" title="12"><span class="ex">builder</span> for <span class="st">&#39;/nix/store/&lt;hash&gt;-blank-me-up-0.1.0.0.drv&#39;</span> failed with exit code 1</a>
<a class="sourceLine" id="cb11-13" title="13"><span class="ex">error</span>: build of <span class="st">&#39;/nix/store/&lt;hash&gt;-blank-me-up-0.1.0.0.drv&#39;</span> failed</a>
<a class="sourceLine" id="cb11-14" title="14"><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></a></code></pre></div>
<p>It fails, as one would hope, but more importantly the previous symlink at <code>result</code> is still available! This is because <code>nix-build</code> completes the build before atomically updating the symlink at <code>result</code> to point to the new artifact. This way, we can move from one known working state to another, without exposing our users to any intermediate brokenness.</p>
<h3 id="service-configuration">Service Configuration</h3>
<p>Okay, now that we’re able to successfully build the app, let’s configure a service file so that <code>systemd</code> can manage our app. I don’t know of any tools that automatically generate this so I always find myself copying and pasting from an existing service file. Here’s one I prepared earlier.</p>
<p><em>nix/service.nix</em></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">{</span> <span class="ex">config</span>, lib, pkgs, ... <span class="kw">}</span>:                                               <span class="co">#1</span></a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="bu">let</span>                                                                       <span class="co">#2</span></a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="ex">blank-me-up</span> = pkgs.callPackage ./default.nix {};                        <span class="co">#3</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="kw">in</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb12-6" title="6">  <span class="ex">options.services.blank-me-up.enable</span> = lib.mkEnableOption <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span> <span class="co">#4</span></a>
<a class="sourceLine" id="cb12-7" title="7"></a>
<a class="sourceLine" id="cb12-8" title="8">  <span class="ex">config</span> = lib.mkIf config.services.blank-me-up.enable {                  <span class="co">#5</span></a>
<a class="sourceLine" id="cb12-9" title="9">    <span class="ex">networking.firewall.allowedTCPPorts</span> = [ 3000 ]<span class="kw">;</span>                       <span class="co">#6</span></a>
<a class="sourceLine" id="cb12-10" title="10"></a>
<a class="sourceLine" id="cb12-11" title="11">    <span class="ex">systemd.services.blank-me-up</span> = {                                      <span class="co">#7</span></a>
<a class="sourceLine" id="cb12-12" title="12">      <span class="ex">description</span> = <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-13" title="13">      <span class="ex">after</span> = [ <span class="st">&quot;network.target&quot;</span> ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-14" title="14">      <span class="ex">wantedBy</span> = [ <span class="st">&quot;multi-user.target&quot;</span> ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-15" title="15">      <span class="ex">serviceConfig</span> = {</a>
<a class="sourceLine" id="cb12-16" title="16">        <span class="ex">ExecStart</span> = <span class="st">&quot;</span><span class="va">${blank-</span>me-up<span class="va">}</span><span class="st">/bin/blank-me-up&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-17" title="17">        <span class="ex">Restart</span> = <span class="st">&quot;always&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-18" title="18">        <span class="ex">KillMode</span> = <span class="st">&quot;process&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-19" title="19">      <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb12-20" title="20">    };</a>
<a class="sourceLine" id="cb12-21" title="21">  };</a>
<a class="sourceLine" id="cb12-22" title="22">}</a></code></pre></div>
<p>This isn’t intended to be a Nix language tutorial, but there are a few interesting things that I want to point out. For a more comprehensive overview of the language, see <a href="https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55">here</a> or <a href="https://nixos.org/nix/manual/#ch-expression-language">here</a>.</p>
<ol type="1">
<li>These are the arguments to this expression that the caller will pass. Another way to think of this is as a form of dependency injection.</li>
<li><code>let</code> expressions work similarly to Haskell.</li>
<li>This is the equivalent of our <code>nix-build</code> from before.</li>
<li>We define a single option that enables our service.</li>
<li>The <code>config</code> attribute contains service configuration.</li>
<li>We expose port 3000.</li>
<li>If you squint this looks a lot like a regular unit file. More on this below.</li>
</ol>
<p>It would be useful to look at the systemd service file that gets generated from this configuraation. To do this, we’ll need one more file:</p>
<p><em>ops/webserver.nix</em></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">{</span> <span class="ex">...</span> <span class="kw">}</span>: <span class="kw">{</span></a>
<a class="sourceLine" id="cb13-2" title="2">  <span class="ex">imports</span> = [ ../nix/service.nix ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="ex">services.blank-me-up.enable</span> = true<span class="kw">;</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="kw">}</span></a></code></pre></div>
<p>This is a function that imports the above configuration and enables the <code>blank-me-up</code> service. With this in place, we can do</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" title="1">$ <span class="ex">nix-instantiate</span> --eval -E <span class="st">&#39;(import &lt;nixpkgs/nixos/lib/eval-config.nix&gt; { modules = [./ops/webserver.nix]; }).config.systemd.units.&quot;blank-me-up.service&quot;.text&#39;</span></a></code></pre></div>
<p>We’re using <code>nix-instantiate</code> to evaluate (<code>--eval</code>) an expression (<code>-E</code>) that uses <code>eval-config.nix</code> from the library to import the file we created and output the text of the final unit file. The output of this is pretty messy, but we can use <code>jq</code> to clean it up:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" title="1">$ <span class="ex">nix-instantiate</span> --eval -E <span class="st">&#39;(import &lt;nixpkgs/nixos/lib/eval-config.nix&gt; { modules = [./ops/webserver.nix]; }).config.systemd.units.&quot;blank-me-up.service&quot;.text&#39;</span> <span class="kw">|</span> <span class="ex">jq</span> -r</a></code></pre></div>
<p>Here’s what that looks like on my machine:</p>
<details>
<p><summary style="cursor: pointer;">Generated <code>systemd</code> service</summary></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb16-1" title="1">[Unit]</a>
<a class="sourceLine" id="cb16-2" title="2">After=network.target</a>
<a class="sourceLine" id="cb16-3" title="3">Description=Blank Me Up</a>
<a class="sourceLine" id="cb16-4" title="4"></a>
<a class="sourceLine" id="cb16-5" title="5">[Service]</a>
<a class="sourceLine" id="cb16-6" title="6">Environment=&quot;LOCALE_ARCHIVE=/nix/store/&lt;hash&gt;-glibc-locales-2.27/lib/locale/locale-archive&quot;</a>
<a class="sourceLine" id="cb16-7" title="7">Environment=&quot;PATH=/nix/store/&lt;hash&gt;-coreutils-8.30/bin:/nix/store/&lt;hash&gt;-findutils-4.6.0/bin:/nix/store/&lt;hash&gt;-gnugrep-3.3/bin:/nix/store/&lt;hash&gt;-gnused-4.7/bin:/nix/store/&lt;hash&gt;-systemd-239.20190219/bin:/nix/store/&lt;hash&gt;-coreutils-8.30/sbin:/nix/store/&lt;hash&gt;-findutils-4.6.0/sbin:/nix/store/&lt;hash&gt;-gnugrep-3.3/sbin:/nix/store/&lt;hash&gt;-gnused-4.7/sbin:/nix/store/&lt;hash&gt;-systemd-239.20190219/sbin&quot;</a>
<a class="sourceLine" id="cb16-8" title="8">Environment=&quot;TZDIR=/nix/store/&lt;hash&gt;-tzdata-2019a/share/zoneinfo&quot;</a>
<a class="sourceLine" id="cb16-9" title="9"></a>
<a class="sourceLine" id="cb16-10" title="10"></a>
<a class="sourceLine" id="cb16-11" title="11"></a>
<a class="sourceLine" id="cb16-12" title="12">ExecStart=/nix/store/&lt;hash&gt;-blank-me-up-0.1.0.0/bin/blank-me-up</a>
<a class="sourceLine" id="cb16-13" title="13">KillMode=process</a>
<a class="sourceLine" id="cb16-14" title="14">Restart=always</a></code></pre></div>
</details>
<p>Hopefully at this point you’re convinced that Nix can take some quasi-JSON and turn it into a binary and a <code>systemd</code> service file. Let’s deploy this!</p>
<h3 id="deploying">Deploying</h3>
<p>First, we install NixOps:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb17-1" title="1">$ <span class="ex">nix-env</span> -i nixops</a></code></pre></div>
<p>We also have to set up VirtualBox, which I’ll be using as my deploy target. If you’re using NixOS this is as simple as adding the following line to <code>configuration.nix</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb18-1" title="1"><span class="ex">virtualisation.virtualbox.host.enable</span> = true<span class="kw">;</span></a></code></pre></div>
<p>and running <code>sudo nixos-rebuild switch</code>. If you’re using another Linux distro, install VirtualBox and set up a host-only network called <code>vboxnet0</code>.</p>
<p>We’ll be using the <a href="https://nixos.org/nixops/manual/#idm140737318606176">instructions from the manual</a> as our starting point. Create two files:</p>
<p><em>ops/trivial.nix</em></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">{</span></a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="ex">network.description</span> = <span class="st">&quot;Web server&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="ex">network.enableRollback</span> = true<span class="kw">;</span></a>
<a class="sourceLine" id="cb19-4" title="4"></a>
<a class="sourceLine" id="cb19-5" title="5">  <span class="ex">webserver</span> = import ./webserver.nix<span class="kw">;</span></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="kw">}</span></a></code></pre></div>
<p><em>ops/trivial-vbox.nix</em></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">{</span></a>
<a class="sourceLine" id="cb20-2" title="2">  <span class="ex">webserver</span> =</a>
<a class="sourceLine" id="cb20-3" title="3">    <span class="kw">{</span> <span class="ex">config</span>, pkgs, ... <span class="kw">}</span>:</a>
<a class="sourceLine" id="cb20-4" title="4">    <span class="kw">{</span> <span class="ex">deployment.targetEnv</span> = <span class="st">&quot;virtualbox&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb20-5" title="5">      <span class="ex">deployment.virtualbox.headless</span> = true<span class="kw">;</span> <span class="co"># don&#39;t show a display</span></a>
<a class="sourceLine" id="cb20-6" title="6">      <span class="ex">deployment.virtualbox.memorySize</span> = 1024<span class="kw">;</span> <span class="co"># megabytes</span></a>
<a class="sourceLine" id="cb20-7" title="7">      <span class="ex">deployment.virtualbox.vcpu</span> = 2<span class="kw">;</span> <span class="co"># number of cpus</span></a>
<a class="sourceLine" id="cb20-8" title="8">    <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb20-9" title="9"><span class="kw">}</span></a></code></pre></div>
<p>We should now be able to create a new deployment:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb21-1" title="1">$ <span class="bu">cd</span> ops</a>
<a class="sourceLine" id="cb21-2" title="2">$ <span class="ex">nixops</span> create trivial.nix trivial-vbox.nix -d trivial</a></code></pre></div>
<p>and deploy it:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb22-1" title="1">$ <span class="ex">nixops</span> deploy -d trivial</a></code></pre></div>
<p>and assuming that everything goes well, we should see a lot of terminal output and at least one mention of <code>ssh://root@&lt;ip&gt;</code>, which is the IP of our target.</p>
<p>We should then be able to go to <code>http://&lt;ip&gt;:3000</code> and see our web app in action!</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb23-1" title="1">$ <span class="ex">curl</span> http://<span class="op">&lt;</span>ip<span class="op">&gt;</span>:3000/help</a>
<a class="sourceLine" id="cb23-2" title="2"><span class="op">&lt;</span><span class="ex">h1</span><span class="op">&gt;</span>Scotty, help me up!<span class="op">&lt;</span>/h1<span class="op">&gt;</span></a></code></pre></div>
<p>NixOps also allows us to SSH in for troubleshooting purposes or to view logs:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb24-1" title="1">$ <span class="ex">nixops</span> ssh -d trivial webserver</a>
<a class="sourceLine" id="cb24-2" title="2"><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb24-3" title="3">[<span class="ex">root@webserver</span>:~]# systemctl status blank-me-up</a></code></pre></div>
<h2 id="responding-to-change">Responding to change</h2>
<p>This is fantastic, but deployments are rarely fire-and-forget. What happens when our requirements change? In fact, there’s a serious issue with our application, which is that it hardcodes the port that it listens on. If we wanted it to listen on a different port, or to run more than one instance of it on the same machine, we’d need to do something differently.</p>
<p>The correct solution would be to talk to the developers and have them implement support, but in the meantime, how should we proceed?</p>
<h3 id="patching">Patching</h3>
<p>Nix gives us full control over each part of the build and deployment process, and we can patch the software as a stopgap measure. Although this scenario is somewhat contrived, I have in fact had to take matters into my own hands like this in the past when the development team hasn’t been able to prioritise fixing a production issue.</p>
<p>Our new expression looks like this:</p>
<p><em>nix/patched.nix</em></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb25-1" title="1"><span class="ex">args@</span>{ nixpkgs ? import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {}, <span class="ex">compiler</span> ? <span class="st">&quot;default&quot;</span> }:</a>
<a class="sourceLine" id="cb25-2" title="2"></a>
<a class="sourceLine" id="cb25-3" title="3"><span class="kw">(</span><span class="ex">import</span> ./default.nix args<span class="kw">)</span><span class="ex">.overrideAttrs</span> (old: {</a>
<a class="sourceLine" id="cb25-4" title="4">  <span class="ex">postPatch</span> = let</a>
<a class="sourceLine" id="cb25-5" title="5">    <span class="ex">oldImport</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb25-6" title="6">      <span class="ex">import</span> Web.Scotty</a>
<a class="sourceLine" id="cb25-7" title="7">    <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb25-8" title="8">    <span class="ex">newImport</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb25-9" title="9">      <span class="ex">import</span> Web.Scotty</a>
<a class="sourceLine" id="cb25-10" title="10">      <span class="ex">import</span> System.Environment (getArgs)</a>
<a class="sourceLine" id="cb25-11" title="11">    <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb25-12" title="12">    <span class="ex">oldMain</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb25-13" title="13">      <span class="ex">main</span> = scotty 3000 $ do</a>
<a class="sourceLine" id="cb25-14" title="14">    <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb25-15" title="15">    <span class="ex">newMain</span> = <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb25-16" title="16">      <span class="ex">main</span> = getArgs <span class="op">&gt;&gt;</span>= <span class="dt">\(</span>port:_) <span class="ex">-</span><span class="op">&gt;</span> scotty (read port) $ <span class="kw">do</span></a>
<a class="sourceLine" id="cb25-17" title="17">    <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb25-18" title="18">  <span class="kw">in</span> <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb25-19" title="19">    <span class="ex">substituteInPlace</span> Main.hs --replace <span class="st">&#39;${oldImport}&#39;</span> <span class="st">&#39;${newImport}&#39;</span></a>
<a class="sourceLine" id="cb25-20" title="20">    <span class="ex">substituteInPlace</span> Main.hs --replace <span class="st">&#39;${oldMain}&#39;</span>   <span class="st">&#39;${newMain}&#39;</span></a>
<a class="sourceLine" id="cb25-21" title="21">    <span class="fu">cat</span> Main.hs</a>
<a class="sourceLine" id="cb25-22" title="22">  <span class="st">&#39;&#39;</span>;</a>
<a class="sourceLine" id="cb25-23" title="23">})</a></code></pre></div>
<p>I’ve added that <code>cat Main.hs</code> at the end to</p>
<ul>
<li>confirm that the file was correctly patched</li>
<li>emphasise that arbitrary shell commands can be executed</li>
</ul>
<p>We can create a new service definition to use this expression:</p>
<p><em>nix/service-patched.nix</em></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">{</span> <span class="ex">config</span>, lib, pkgs, ... <span class="kw">}</span>:</a>
<a class="sourceLine" id="cb26-2" title="2"></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="bu">let</span></a>
<a class="sourceLine" id="cb26-4" title="4">  <span class="ex">blank-me-up</span> = pkgs.callPackage ./patched.nix { nixpkgs = pkgs<span class="kw">;</span> };</a>
<a class="sourceLine" id="cb26-5" title="5">  <span class="ex">cfg</span> = config.services.blank-me-up<span class="kw">;</span></a>
<a class="sourceLine" id="cb26-6" title="6"><span class="kw">in</span> <span class="kw">{</span></a>
<a class="sourceLine" id="cb26-7" title="7">  <span class="ex">options.services.blank-me-up.enable</span> = lib.mkEnableOption <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb26-8" title="8">  <span class="ex">options.services.blank-me-up.port</span> = lib.mkOption {</a>
<a class="sourceLine" id="cb26-9" title="9">    <span class="ex">default</span> = 3000<span class="kw">;</span></a>
<a class="sourceLine" id="cb26-10" title="10">    <span class="bu">type</span> = lib.types.int<span class="kw">;</span></a>
<a class="sourceLine" id="cb26-11" title="11">  <span class="kw">}</span>;</a>
<a class="sourceLine" id="cb26-12" title="12"></a>
<a class="sourceLine" id="cb26-13" title="13">  <span class="ex">config</span> = lib.mkIf cfg.enable {</a>
<a class="sourceLine" id="cb26-14" title="14">    <span class="ex">networking.firewall.allowedTCPPorts</span> = [ cfg.port ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb26-15" title="15"></a>
<a class="sourceLine" id="cb26-16" title="16">    <span class="ex">systemd.services.blank-me-up</span> = {</a>
<a class="sourceLine" id="cb26-17" title="17">      <span class="ex">description</span> = <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb26-18" title="18">      <span class="ex">after</span> = [ <span class="st">&quot;network.target&quot;</span> ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb26-19" title="19">      <span class="ex">wantedBy</span> = [ <span class="st">&quot;multi-user.target&quot;</span> ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb26-20" title="20">      <span class="ex">serviceConfig</span> = {</a>
<a class="sourceLine" id="cb26-21" title="21">        <span class="ex">ExecStart</span> = <span class="st">&quot;</span><span class="va">${blank-</span>me-up<span class="va">}</span><span class="st">/bin/blank-me-up </span><span class="va">${toString</span><span class="er"> cfg.port</span><span class="va">}</span><span class="st">&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb26-22" title="22">        <span class="ex">Restart</span> = <span class="st">&quot;always&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb26-23" title="23">        <span class="ex">KillMode</span> = <span class="st">&quot;process&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb26-24" title="24">      };</a>
<a class="sourceLine" id="cb26-25" title="25">    };</a>
<a class="sourceLine" id="cb26-26" title="26">  };</a>
<a class="sourceLine" id="cb26-27" title="27">}</a></code></pre></div>
<p>We make sure to pass the configured port in on startup and open the firewall appropriately.</p>
<h3 id="deploying-again">Deploying (Again)</h3>
<p>We update <code>webserver.nix</code> to use the patched service and specify a different port:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">{</span> <span class="ex">...</span> <span class="kw">}</span>: <span class="kw">{</span></a>
<a class="sourceLine" id="cb27-2" title="2">  <span class="ex">imports</span> = [ ../nix/service-patched.nix ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb27-3" title="3">  <span class="ex">services.blank-me-up.enable</span> = true<span class="kw">;</span></a>
<a class="sourceLine" id="cb27-4" title="4">  <span class="ex">services.blank-me-up.port</span> = 3001<span class="kw">;</span></a>
<a class="sourceLine" id="cb27-5" title="5"><span class="kw">}</span></a></code></pre></div>
<p>And we can deploy again!</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb28-1" title="1">$ <span class="ex">nixops</span> deploy -d trivial</a></code></pre></div>
<p>The service should now be running on <code>http://&lt;ip&gt;:3001</code> instead of <code>http://&lt;ip&gt;:3000</code>.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb29-1" title="1">$ <span class="ex">curl</span> http://<span class="op">&lt;</span>ip<span class="op">&gt;</span>:3001/pull</a>
<a class="sourceLine" id="cb29-2" title="2"><span class="op">&lt;</span><span class="ex">h1</span><span class="op">&gt;</span>Scotty, pull me up!<span class="op">&lt;</span>/h1<span class="op">&gt;</span></a></code></pre></div>
<p>If we made a mistake, rolling back is easy:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb30-1" title="1">$ <span class="ex">nixops</span> list-generations -d trivial</a>
<a class="sourceLine" id="cb30-2" title="2">   <span class="ex">1</span>   <span class="op">&lt;</span>timestamp<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb30-3" title="3">   <span class="ex">2</span>   <span class="op">&lt;</span>timestamp<span class="op">&gt;</span>   (current)</a>
<a class="sourceLine" id="cb30-4" title="4"></a>
<a class="sourceLine" id="cb30-5" title="5">$ <span class="ex">nixops</span> rollback -d trivial 1</a>
<a class="sourceLine" id="cb30-6" title="6"><span class="ex">switching</span> from generation 2 to 1</a>
<a class="sourceLine" id="cb30-7" title="7"><span class="ex">webserver</span><span class="op">&gt;</span> copying closure...</a>
<a class="sourceLine" id="cb30-8" title="8"><span class="ex">trivial</span><span class="op">&gt;</span> closures copied successfully</a>
<a class="sourceLine" id="cb30-9" title="9"><span class="op">&lt;</span><span class="fu">more</span> output<span class="op">&gt;</span></a></code></pre></div>
<p>and in fact nothing needs to be copied to the target, because the previous deployment is still there.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As demonstrated, the Nix ecosystem allows us to impose order on the usually messy and ad-hoc practice of packaging and deploying software at scale. I’m satisfied that this is the way forward and hope that you will consider using these tools to tackle problems of your own!</p>
]]></summary>
</entry>
<entry>
    <title>Hacking on GHC Has Never Been Easier!</title>
    <link href="https://vaibhavsagar.com/blog/2019/06/22/easy-ghc-hacking/index.html" />
    <id>https://vaibhavsagar.com/blog/2019/06/22/easy-ghc-hacking/index.html</id>
    <published>2019-06-22T00:00:00Z</published>
    <updated>2019-06-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 22 June 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/nix/index.html">nix</a>, <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p>At ZuriHac 2019 <a href="https://github.com/mpickering">Matthew Pickering</a> talked about <a href="https://www.youtube.com/watch?v=Q2ZDovqIxCw">tools for working on GHC</a>. There’s <a href="https://mpickering.github.io/posts/2019-06-11-ghc-tools.html">an associated blog post</a> which is also well worth reading.</p>
<p>I wanted to focus on a small part of his presentation, which is about loading <a href="https://gitlab.haskell.org/ghc/ghc/wikis/building/in-ghci">GHC into GHCi</a> and using <a href="https://github.com/ndmitchell/ghcid"><code>ghcid</code></a> to automatically reload GHC on changes. This has been possible for almost a year now, <a href="https://mgsloan.com/posts/ghcinception/">as described in this blog post by Michael Sloan</a>. It has since been improved to be even easier to use!</p>
<p>Putting this together with <a href="https://github.com/alpmestan/ghc.nix">Alp Mestanogullari’s <code>ghc.nix</code></a>, it’s now possible to provision a GHC development environment from scratch with just a few commands, assuming that you have <code>nix-shell</code>, <code>cabal-install</code>, and <code>ghcid</code> installed. Here they are:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1">$ <span class="fu">git</span> clone --recursive https://gitlab.haskell.org/ghc/ghc/</a>
<a class="sourceLine" id="cb1-2" title="2">$ <span class="bu">cd</span> ghc</a>
<a class="sourceLine" id="cb1-3" title="3">$ <span class="fu">git</span> clone https://github.com/alpmestan/ghc.nix</a>
<a class="sourceLine" id="cb1-4" title="4">$ <span class="ex">cabal</span> update</a>
<a class="sourceLine" id="cb1-5" title="5">$ <span class="ex">nix-shell</span> ghc.nix/ --run <span class="st">&#39;./boot &amp;&amp; ./configure &amp;&amp; ghcid&#39;</span></a></code></pre></div>
<p>This will take a while the first time, but <code>ghcid</code> will cache generated artifacts under <code>./hadrian_ghci</code> so even quitting and reloading will be significantly faster.</p>
<p>Congratulations, you are now a GHC developer!</p>
]]></summary>
</entry>
<entry>
    <title>Refactoring Haskell: A Case Study</title>
    <link href="https://vaibhavsagar.com/blog/2019/02/12/refactoring-haskell/index.html" />
    <id>https://vaibhavsagar.com/blog/2019/02/12/refactoring-haskell/index.html</id>
    <published>2019-02-12T00:00:00Z</published>
    <updated>2019-02-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 12 February 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>
    
</div>

<p>Many people claim that <a href="https://twitter.com/search?q=haskell%20refactoring">refactoring Haskell is a joy</a>. I’ve certainly found this to be the case, but what does that mean in practice? I thought it might be useful to demonstrate by refactoring some of my own code.</p>
<p>The code we’re looking at today is an implementation of <a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Tarjan’s Strongly Connected Components algorithm</a> used to determine whether a given <a href="https://en.wikipedia.org/wiki/2-satisfiability">2-SAT problem</a> is satisfiable or not, and was written to complete <a href="https://online.stanford.edu/course/algorithms-design-and-analysis-part-1">an online course</a> that is now offered in a different form. I’ve <a href="http://vaibhavsagar.com/blog/2017/06/10/dag-toolkit/">written about Tarjan’s algorithm previously</a> and it can be used to determine the satisfiability of a 2-SAT problem by checking if any SCC contains both a variable and its negation. If it does, we have a contradiction and the problem is unsatisfiable, otherwise the problem is satisfiable.</p>
<p>This code isn’t particularly elegant or easy to follow, and it’s lousy with mutable state. Despite these drawbacks, it is still relatively straightforward to refactor.</p>
<p>If you’d like to follow along, I have the code (and some test data) available <a href="https://gist.github.com/vaibhavsagar/2418c9dd79da431065ad0d80e690b12f">at this gist</a> with each revision representing a refactoring step.</p>
<p>The initial version of the code is as follows:</p>
<details>
<p><summary style="cursor: pointer">Initial 2SAT.hs</summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span>      <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">M</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span>        <span class="kw">as</span> <span class="dt">S</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span>      <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>         <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_, when)</a>
<a class="sourceLine" id="cb1-14" title="14"><span class="kw">import</span> <span class="dt">Data.Maybe</span> (isJust, isNothing, fromJust)</a>
<a class="sourceLine" id="cb1-15" title="15"></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb1-17" title="17">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-18" title="18">    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-19" title="19">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb1-20" title="20">    stackSet <span class="ot">&lt;-</span> newSTRef S.empty</a>
<a class="sourceLine" id="cb1-21" title="21">    indices  <span class="ot">&lt;-</span> newSTRef M.empty</a>
<a class="sourceLine" id="cb1-22" title="22">    lowlinks <span class="ot">&lt;-</span> newSTRef M.empty</a>
<a class="sourceLine" id="cb1-23" title="23">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb1-24" title="24"></a>
<a class="sourceLine" id="cb1-25" title="25">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-26" title="26">        vIndex <span class="ot">&lt;-</span> M.lookup v <span class="op">&lt;$&gt;</span> readSTRef indices</a>
<a class="sourceLine" id="cb1-27" title="27">        when (isNothing vIndex) <span class="op">$</span></a>
<a class="sourceLine" id="cb1-28" title="28">            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb1-29" title="29"></a>
<a class="sourceLine" id="cb1-30" title="30">    readSTRef output</a>
<a class="sourceLine" id="cb1-31" title="31"></a>
<a class="sourceLine" id="cb1-32" title="32">strongConnect</a>
<a class="sourceLine" id="cb1-33" title="33"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-34" title="34">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-35" title="35">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb1-36" title="36">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-37" title="37">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb1-38" title="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-39" title="39">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-40" title="40">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-41" title="41">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb1-42" title="42">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb1-43" title="43">strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-44" title="44">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb1-45" title="45">    insert v i indices</a>
<a class="sourceLine" id="cb1-46" title="46">    insert v i lowlinks</a>
<a class="sourceLine" id="cb1-47" title="47">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-48" title="48">    push stack stackSet v</a>
<a class="sourceLine" id="cb1-49" title="49"></a>
<a class="sourceLine" id="cb1-50" title="50">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">lookup</span> w indices <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb1-51" title="51">        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-52" title="52">            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb1-53" title="53">            vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</a>
<a class="sourceLine" id="cb1-54" title="54">            wLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> w lowlinks</a>
<a class="sourceLine" id="cb1-55" title="55">            insert v (<span class="fu">min</span> vLowLink wLowLink) lowlinks</a>
<a class="sourceLine" id="cb1-56" title="56">        <span class="dt">Just</span> wIndex <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-57" title="57">            wOnStack <span class="ot">&lt;-</span> S.member w <span class="op">&lt;$&gt;</span> readSTRef stackSet</a>
<a class="sourceLine" id="cb1-58" title="58">            when wOnStack <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-59" title="59">                vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</a>
<a class="sourceLine" id="cb1-60" title="60">                insert v (<span class="fu">min</span> vLowLink wIndex) lowlinks</a>
<a class="sourceLine" id="cb1-61" title="61"></a>
<a class="sourceLine" id="cb1-62" title="62">    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</a>
<a class="sourceLine" id="cb1-63" title="63">    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v indices</a>
<a class="sourceLine" id="cb1-64" title="64">    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-65" title="65">        scc <span class="ot">&lt;-</span> addSCC n v S.empty stack stackSet</a>
<a class="sourceLine" id="cb1-66" title="66">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb1-67" title="67">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-68" title="68">        <span class="fu">lookup</span> value hashMap     <span class="ot">=</span> M.lookup value <span class="op">&lt;$&gt;</span> readSTRef hashMap</a>
<a class="sourceLine" id="cb1-69" title="69">        insert key value hashMap <span class="ot">=</span> modifySTRef&#39; hashMap (M.insert key value)</a>
<a class="sourceLine" id="cb1-70" title="70"></a>
<a class="sourceLine" id="cb1-71" title="71"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> (<span class="dt">S.Set</span> <span class="dt">Int</span>))</a>
<a class="sourceLine" id="cb1-72" title="72">addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`S.member`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb1-73" title="73">    <span class="kw">let</span> scc&#39; <span class="ot">=</span> S.insert w scc</a>
<a class="sourceLine" id="cb1-74" title="74">    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</a>
<a class="sourceLine" id="cb1-75" title="75"></a>
<a class="sourceLine" id="cb1-76" title="76"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb1-77" title="77">push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-78" title="78">    modifySTRef&#39; stack    (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb1-79" title="79">    modifySTRef&#39; stackSet (S.insert e)</a>
<a class="sourceLine" id="cb1-80" title="80"></a>
<a class="sourceLine" id="cb1-81" title="81"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-82" title="82">pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-83" title="83">    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb1-84" title="84">    modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb1-85" title="85">    modifySTRef&#39; stackSet (S.delete e)</a>
<a class="sourceLine" id="cb1-86" title="86">    <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb1-87" title="87"></a>
<a class="sourceLine" id="cb1-88" title="88">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb1-89" title="89">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb1-90" title="90">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb1-91" title="91">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb1-92" title="92"></a>
<a class="sourceLine" id="cb1-93" title="93"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-94" title="94">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-95" title="95">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb1-96" title="96">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb1-97" title="97">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb1-98" title="98">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb1-99" title="99">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>I’ve included 2SAT-specific functionality for completeness, but I’ll only be changing the <code>tarjan</code> function and the functions it depends on (<code>strongConnect</code>, <code>addSCC</code>, <code>push</code>, and <code>pop</code>).</p>
<p>The first change is using more suitable data structures. Tarjan’s algorithm is only linear in the size of the graph when operations, such as checking if <code>w</code> is on the stack and looking up indices, happen in constant time (<span class="math inline"><em>O</em>(1)</span>). I’m currently using <code>Data.Map</code> and <code>Data.Set</code> which are both implemented with trees and are <span class="math inline"><em>O</em>(log <em>n</em>)</span> in these operations. A better choice would be <a href="http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html"><code>Data.Vector.Mutable</code></a> from the <code>vector</code> package, which does have constant-time operations.</p>
<p>This refactoring mostly consists of initialising vectors with a known length and replacing calls to <code>lookup</code> and <code>insert</code> with calls to <code>read</code> and <code>write</code>.</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>vector</code></summary></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_, when)</a>
<a class="sourceLine" id="cb2-12" title="12"><span class="kw">import</span> <span class="dt">Data.Maybe</span>          (isJust, isNothing, fromJust)</a>
<a class="sourceLine" id="cb2-13" title="13"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb2-14" title="14"></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb2-16" title="16">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-17" title="17">    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-18" title="18">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb2-19" title="19">    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-20" title="20">    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-21" title="21">    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-22" title="22">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb2-23" title="23"></a>
<a class="sourceLine" id="cb2-24" title="24">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-25" title="25">        vIndex <span class="ot">&lt;-</span> <span class="fu">read</span> indices v</a>
<a class="sourceLine" id="cb2-26" title="26">        when (isNothing vIndex) <span class="op">$</span></a>
<a class="sourceLine" id="cb2-27" title="27">            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb2-28" title="28"></a>
<a class="sourceLine" id="cb2-29" title="29">    readSTRef output</a>
<a class="sourceLine" id="cb2-30" title="30">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-31" title="31">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-32" title="32"></a>
<a class="sourceLine" id="cb2-33" title="33">strongConnect</a>
<a class="sourceLine" id="cb2-34" title="34"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-35" title="35">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-36" title="36">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb2-37" title="37">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-38" title="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb2-39" title="39">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-40" title="40">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb2-41" title="41">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb2-42" title="42">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb2-43" title="43">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb2-44" title="44">strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-45" title="45">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb2-46" title="46">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb2-47" title="47">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb2-48" title="48">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb2-49" title="49">    push stack stackSet v</a>
<a class="sourceLine" id="cb2-50" title="50"></a>
<a class="sourceLine" id="cb2-51" title="51">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb2-52" title="52">        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-53" title="53">            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb2-54" title="54">            vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</a>
<a class="sourceLine" id="cb2-55" title="55">            wLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks w</a>
<a class="sourceLine" id="cb2-56" title="56">            write lowlinks v (<span class="dt">Just</span> (<span class="fu">min</span> vLowLink wLowLink))</a>
<a class="sourceLine" id="cb2-57" title="57">        <span class="dt">Just</span> wIndex <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-58" title="58">            wOnStack <span class="ot">&lt;-</span> <span class="fu">read</span> stackSet w</a>
<a class="sourceLine" id="cb2-59" title="59">            when wOnStack <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-60" title="60">                vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</a>
<a class="sourceLine" id="cb2-61" title="61">                write lowlinks v (<span class="dt">Just</span> (<span class="fu">min</span> vLowLink wIndex))</a>
<a class="sourceLine" id="cb2-62" title="62"></a>
<a class="sourceLine" id="cb2-63" title="63">    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</a>
<a class="sourceLine" id="cb2-64" title="64">    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices  v</a>
<a class="sourceLine" id="cb2-65" title="65">    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-66" title="66">        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</a>
<a class="sourceLine" id="cb2-67" title="67">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb2-68" title="68"></a>
<a class="sourceLine" id="cb2-69" title="69"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb2-70" title="70">addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb2-71" title="71">    <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb2-72" title="72">    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</a>
<a class="sourceLine" id="cb2-73" title="73"></a>
<a class="sourceLine" id="cb2-74" title="74"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb2-75" title="75">push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-76" title="76">    modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb2-77" title="77">    write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb2-78" title="78"></a>
<a class="sourceLine" id="cb2-79" title="79"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-80" title="80">pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-81" title="81">    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb2-82" title="82">    modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb2-83" title="83">    write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-84" title="84">    <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb2-85" title="85"></a>
<a class="sourceLine" id="cb2-86" title="86">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb2-87" title="87">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb2-88" title="88">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb2-89" title="89">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb2-90" title="90"></a>
<a class="sourceLine" id="cb2-91" title="91"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-92" title="92">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-93" title="93">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb2-94" title="94">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb2-95" title="95">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb2-96" title="96">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb2-97" title="97">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>I didn’t notice a significant difference in speed on my inputs, but it’s good to know that the algorithm has been implemented with the correct asymptotics now!</p>
<p><em>Sidenote: A <code>Vector</code> of <code>Bool</code>s can be much more compactly represented as a sequence of 0s and 1s, which are just machine words. For implementations of this in Haskell, see the <a href="https://hackage.haskell.org/package/bv">bv</a> or <a href="https://hackage.haskell.org/package/bv-little">bv-little</a> packages. Using these could be another possible refactoring.</em></p>
<p>Looking at the code again, I notice some repetition of the form</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">x <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorX i</a>
<a class="sourceLine" id="cb3-2" title="2">y <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorY j</a>
<a class="sourceLine" id="cb3-3" title="3">write vectorZ k (<span class="dt">Just</span> (operation x y))</a></code></pre></div>
<p>and with the judicious use of <code>(=&lt;&lt;)</code> and <code>(&lt;*&gt;)</code> this can instead be</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">write vectorZ k <span class="op">=&lt;&lt;</span> (operation <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorX i <span class="op">&lt;*&gt;</span> <span class="fu">lookup</span> vectorY j)</a></code></pre></div>
<p>There are a couple of other places we could use <code>(&lt;*&gt;)</code>:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>(&lt;*&gt;)</code></summary></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_, when)</a>
<a class="sourceLine" id="cb5-12" title="12"><span class="kw">import</span> <span class="dt">Data.Maybe</span>          (isJust, isNothing, fromJust)</a>
<a class="sourceLine" id="cb5-13" title="13"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb5-16" title="16">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-18" title="18">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb5-19" title="19">    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb5-20" title="20">    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb5-21" title="21">    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb5-22" title="22">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb5-23" title="23"></a>
<a class="sourceLine" id="cb5-24" title="24">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-25" title="25">        vIndex <span class="ot">&lt;-</span> <span class="fu">read</span> indices v</a>
<a class="sourceLine" id="cb5-26" title="26">        when (isNothing vIndex) <span class="op">$</span></a>
<a class="sourceLine" id="cb5-27" title="27">            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb5-28" title="28"></a>
<a class="sourceLine" id="cb5-29" title="29">    readSTRef output</a>
<a class="sourceLine" id="cb5-30" title="30">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-31" title="31">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-32" title="32"></a>
<a class="sourceLine" id="cb5-33" title="33">strongConnect</a>
<a class="sourceLine" id="cb5-34" title="34"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-35" title="35">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-36" title="36">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb5-37" title="37">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-38" title="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb5-39" title="39">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-40" title="40">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb5-41" title="41">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb5-42" title="42">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb5-43" title="43">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb5-44" title="44">strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-45" title="45">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb5-46" title="46">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb5-47" title="47">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb5-48" title="48">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-49" title="49">    push stack stackSet v</a>
<a class="sourceLine" id="cb5-50" title="50"></a>
<a class="sourceLine" id="cb5-51" title="51">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb5-52" title="52">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-53" title="53">            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb5-54" title="54">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</a>
<a class="sourceLine" id="cb5-55" title="55">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-56" title="56">            wOnStack <span class="ot">&lt;-</span> <span class="fu">read</span> stackSet w</a>
<a class="sourceLine" id="cb5-57" title="57">            when wOnStack <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-58" title="58">                write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices w)</a>
<a class="sourceLine" id="cb5-59" title="59"></a>
<a class="sourceLine" id="cb5-60" title="60">    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</a>
<a class="sourceLine" id="cb5-61" title="61">    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices  v</a>
<a class="sourceLine" id="cb5-62" title="62">    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-63" title="63">        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</a>
<a class="sourceLine" id="cb5-64" title="64">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb5-65" title="65"></a>
<a class="sourceLine" id="cb5-66" title="66"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb5-67" title="67">addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb5-68" title="68">    <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb5-69" title="69">    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</a>
<a class="sourceLine" id="cb5-70" title="70"></a>
<a class="sourceLine" id="cb5-71" title="71"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb5-72" title="72">push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-73" title="73">    modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb5-74" title="74">    write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb5-75" title="75"></a>
<a class="sourceLine" id="cb5-76" title="76"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-77" title="77">pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-78" title="78">    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb5-79" title="79">    modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb5-80" title="80">    write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb5-81" title="81">    <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb5-82" title="82"></a>
<a class="sourceLine" id="cb5-83" title="83">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb5-84" title="84">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb5-85" title="85">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb5-86" title="86">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb5-87" title="87"></a>
<a class="sourceLine" id="cb5-88" title="88"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-89" title="89">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-90" title="90">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb5-91" title="91">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb5-92" title="92">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb5-93" title="93">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb5-94" title="94">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>This is much nicer with the applicative combinators.</p>
<p>I would like to clean up that <code>when</code> as well, and for that I’d need a function like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a></code></pre></div>
<p>which is <a href="hackage.haskell.org/package/extra/docs/Control-Monad-Extra.html#v:whenM">available in Neil Mitchell’s <code>extra</code> package</a>.</p>
<p>I don’t think it’s worth pulling in that dependency though, so I’ll just copy that definition:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>whenM</code></summary></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb7-12" title="12"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb7-15" title="15">whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb7-16" title="16"></a>
<a class="sourceLine" id="cb7-17" title="17"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb7-18" title="18">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-19" title="19">    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-20" title="20">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb7-21" title="21">    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb7-22" title="22">    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-23" title="23">    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-24" title="24">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb7-25" title="25"></a>
<a class="sourceLine" id="cb7-26" title="26">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-27" title="27">        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span></a>
<a class="sourceLine" id="cb7-28" title="28">            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb7-29" title="29"></a>
<a class="sourceLine" id="cb7-30" title="30">    readSTRef output</a>
<a class="sourceLine" id="cb7-31" title="31">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-32" title="32">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-33" title="33"></a>
<a class="sourceLine" id="cb7-34" title="34">strongConnect</a>
<a class="sourceLine" id="cb7-35" title="35"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-36" title="36">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-37" title="37">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb7-38" title="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-39" title="39">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb7-40" title="40">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-41" title="41">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-42" title="42">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-43" title="43">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb7-44" title="44">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb7-45" title="45">strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-46" title="46">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb7-47" title="47">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb7-48" title="48">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb7-49" title="49">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb7-50" title="50">    push stack stackSet v</a>
<a class="sourceLine" id="cb7-51" title="51"></a>
<a class="sourceLine" id="cb7-52" title="52">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb7-53" title="53">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-54" title="54">            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb7-55" title="55">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</a>
<a class="sourceLine" id="cb7-56" title="56">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></a>
<a class="sourceLine" id="cb7-57" title="57">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</a>
<a class="sourceLine" id="cb7-58" title="58"></a>
<a class="sourceLine" id="cb7-59" title="59">    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-60" title="60">        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</a>
<a class="sourceLine" id="cb7-61" title="61">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb7-62" title="62"></a>
<a class="sourceLine" id="cb7-63" title="63"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb7-64" title="64">addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb7-65" title="65">    <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb7-66" title="66">    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</a>
<a class="sourceLine" id="cb7-67" title="67"></a>
<a class="sourceLine" id="cb7-68" title="68"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb7-69" title="69">push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-70" title="70">    modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb7-71" title="71">    write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb7-72" title="72"></a>
<a class="sourceLine" id="cb7-73" title="73"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-74" title="74">pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-75" title="75">    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb7-76" title="76">    modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb7-77" title="77">    write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb7-78" title="78">    <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb7-79" title="79"></a>
<a class="sourceLine" id="cb7-80" title="80">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb7-81" title="81">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb7-82" title="82">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb7-83" title="83">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb7-84" title="84"></a>
<a class="sourceLine" id="cb7-85" title="85"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-86" title="86">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-87" title="87">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb7-88" title="88">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb7-89" title="89">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb7-90" title="90">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb7-91" title="91">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>Now I don’t actually even need <code>when</code> anymore!</p>
<p>Since most of the auxiliary functions aren’t used outside <code>strongConnect</code>, it might make sense to put them under a <code>where</code> clause. This would also make the parameters passed to <code>strongConnect</code> available to these functions. This is one place that the <code>ScopedTypeVariables</code> language extension is necessary, otherwise GHC can’t tell that the <code>s</code> in the type signature of <code>strongConnect</code> is the same <code>s</code> as the one in each type signature under the <code>where</code> clause.</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>where</code></summary></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb8-7" title="7"></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb8-9" title="9"></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb8-13" title="13"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb8-14" title="14"></a>
<a class="sourceLine" id="cb8-15" title="15"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb8-16" title="16">whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb8-17" title="17"></a>
<a class="sourceLine" id="cb8-18" title="18"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb8-19" title="19">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-20" title="20">    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-21" title="21">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb8-22" title="22">    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb8-23" title="23">    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb8-24" title="24">    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb8-25" title="25">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb8-26" title="26"></a>
<a class="sourceLine" id="cb8-27" title="27">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-28" title="28">        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span></a>
<a class="sourceLine" id="cb8-29" title="29">            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb8-30" title="30"></a>
<a class="sourceLine" id="cb8-31" title="31">    readSTRef output</a>
<a class="sourceLine" id="cb8-32" title="32">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-33" title="33">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-34" title="34"></a>
<a class="sourceLine" id="cb8-35" title="35">strongConnect</a>
<a class="sourceLine" id="cb8-36" title="36"><span class="ot">    ::</span> <span class="kw">forall</span> s</a>
<a class="sourceLine" id="cb8-37" title="37">    <span class="op">.</span>  <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-38" title="38">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-39" title="39">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb8-40" title="40">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-41" title="41">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb8-42" title="42">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb8-43" title="43">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb8-44" title="44">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb8-45" title="45">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb8-46" title="46">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb8-47" title="47">strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-48" title="48">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb8-49" title="49">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb8-50" title="50">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb8-51" title="51">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-52" title="52">    push v</a>
<a class="sourceLine" id="cb8-53" title="53"></a>
<a class="sourceLine" id="cb8-54" title="54">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb8-55" title="55">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-56" title="56">            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb8-57" title="57">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</a>
<a class="sourceLine" id="cb8-58" title="58">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></a>
<a class="sourceLine" id="cb8-59" title="59">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</a>
<a class="sourceLine" id="cb8-60" title="60"></a>
<a class="sourceLine" id="cb8-61" title="61">    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-62" title="62">        scc <span class="ot">&lt;-</span> addSCC n v []</a>
<a class="sourceLine" id="cb8-63" title="63">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb8-64" title="64">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-65" title="65"><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb8-66" title="66">        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb8-67" title="67">            <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb8-68" title="68">            <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39;</a>
<a class="sourceLine" id="cb8-69" title="69"><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb8-70" title="70">        push e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-71" title="71">            modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb8-72" title="72">            write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb8-73" title="73"><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-74" title="74">        pop <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-75" title="75">            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb8-76" title="76">            modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb8-77" title="77">            write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb8-78" title="78">            <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb8-79" title="79"></a>
<a class="sourceLine" id="cb8-80" title="80">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb8-81" title="81">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb8-82" title="82">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb8-83" title="83">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb8-84" title="84"></a>
<a class="sourceLine" id="cb8-85" title="85"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb8-86" title="86">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-87" title="87">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb8-88" title="88">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb8-89" title="89">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb8-90" title="90">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb8-91" title="91">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>I think the logic is clearer now that the auxiliary functions take fewer arguments.</p>
<p>Instead of a large number of implictly related variables, it might be nice to define a single product type containing our entire environment and pass just one value around. With <code>NamedFieldPuns</code> only minimal code changes are required:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>NamedFieldPuns</code></summary></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb9-10" title="10"></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb9-12" title="12"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb9-13" title="13"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb9-14" title="14"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb9-15" title="15"></a>
<a class="sourceLine" id="cb9-16" title="16"><span class="kw">data</span> <span class="dt">TarjanEnv</span> s <span class="ot">=</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb9-17" title="17">    {<span class="ot"> index    ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-18" title="18">    ,<span class="ot"> stack    ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb9-19" title="19">    ,<span class="ot"> stackSet ::</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb9-20" title="20">    ,<span class="ot"> indices  ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb9-21" title="21">    ,<span class="ot"> lowlinks ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb9-22" title="22">    ,<span class="ot"> output   ::</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb9-23" title="23">    }</a>
<a class="sourceLine" id="cb9-24" title="24"></a>
<a class="sourceLine" id="cb9-25" title="25"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb9-26" title="26">whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb9-27" title="27"></a>
<a class="sourceLine" id="cb9-28" title="28"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb9-29" title="29">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-30" title="30">    tarjanEnv <span class="ot">&lt;-</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb9-31" title="31">        <span class="op">&lt;$&gt;</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb9-32" title="32">        <span class="op">&lt;*&gt;</span> newSTRef []</a>
<a class="sourceLine" id="cb9-33" title="33">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb9-34" title="34">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-35" title="35">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-36" title="36">        <span class="op">&lt;*&gt;</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb9-37" title="37"></a>
<a class="sourceLine" id="cb9-38" title="38">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-39" title="39">        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> (indices tarjanEnv) v) <span class="op">$</span></a>
<a class="sourceLine" id="cb9-40" title="40">            strongConnect n v graph tarjanEnv</a>
<a class="sourceLine" id="cb9-41" title="41"></a>
<a class="sourceLine" id="cb9-42" title="42">    readSTRef (output tarjanEnv)</a>
<a class="sourceLine" id="cb9-43" title="43">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-44" title="44">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-45" title="45"></a>
<a class="sourceLine" id="cb9-46" title="46"><span class="ot">strongConnect ::</span> <span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">TarjanEnv</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb9-47" title="47">strongConnect n v graph tarjanEnv<span class="op">@</span><span class="dt">TarjanEnv</span>{ <span class="fu">index</span>, stack, stackSet, indices, lowlinks, output } <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-48" title="48">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb9-49" title="49">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb9-50" title="50">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb9-51" title="51">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb9-52" title="52">    push v</a>
<a class="sourceLine" id="cb9-53" title="53"></a>
<a class="sourceLine" id="cb9-54" title="54">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb9-55" title="55">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-56" title="56">            strongConnect n w graph tarjanEnv</a>
<a class="sourceLine" id="cb9-57" title="57">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</a>
<a class="sourceLine" id="cb9-58" title="58">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></a>
<a class="sourceLine" id="cb9-59" title="59">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</a>
<a class="sourceLine" id="cb9-60" title="60"></a>
<a class="sourceLine" id="cb9-61" title="61">    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-62" title="62">        scc <span class="ot">&lt;-</span> addSCC n v []</a>
<a class="sourceLine" id="cb9-63" title="63">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb9-64" title="64">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-65" title="65"><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb9-66" title="66">        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb9-67" title="67">            <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb9-68" title="68">            <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39;</a>
<a class="sourceLine" id="cb9-69" title="69"><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb9-70" title="70">        push e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-71" title="71">            modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb9-72" title="72">            write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb9-73" title="73"><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-74" title="74">        pop <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-75" title="75">            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb9-76" title="76">            modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb9-77" title="77">            write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb9-78" title="78">            <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb9-79" title="79"></a>
<a class="sourceLine" id="cb9-80" title="80">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb9-81" title="81">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb9-82" title="82">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb9-83" title="83">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb9-84" title="84"></a>
<a class="sourceLine" id="cb9-85" title="85"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb9-86" title="86">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-87" title="87">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb9-88" title="88">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb9-89" title="89">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb9-90" title="90">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb9-91" title="91">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>Let’s pause here. Although more refactoring is certainly possible, my last two steps did not reduce the line count and may have in fact made the code harder to understand.</p>
<p>How have we benefited from this refactoring? Aside from the code being shorter and better structured, it’s now easier to make meaningful improvements. For example, this implementation is more inefficient than it needs to be, because it doesn’t short-circuit when it finds that the current problem is unsatisfiable. Instead it works through the rest of the problem, only to throw all that work away. A sophisticated solution to this problem might involve the use of the <a href="https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-Except.html"><code>ExceptT</code></a> monad transformer to throw an exception and exit early, but there is a simpler approach: we can store an extra boolean variable denoting whether or not the current problem is possibly satisfiable, and only continue working if it is. I’ll call this variable <code>possible</code>, update it in <code>addSCC</code>, and check for it before each call to <code>strongConnect</code> in <code>tarjan</code>. It takes more effort to reformat the code than to make this change:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs with short-circuiting</summary></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb10-4" title="4"></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb10-10" title="10"></a>
<a class="sourceLine" id="cb10-11" title="11"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb10-12" title="12"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb10-13" title="13"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb10-14" title="14"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb10-15" title="15"></a>
<a class="sourceLine" id="cb10-16" title="16"><span class="kw">data</span> <span class="dt">TarjanEnv</span> s <span class="ot">=</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb10-17" title="17">    {<span class="ot"> index    ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-18" title="18">    ,<span class="ot"> stack    ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb10-19" title="19">    ,<span class="ot"> stackSet ::</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-20" title="20">    ,<span class="ot"> indices  ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb10-21" title="21">    ,<span class="ot"> lowlinks ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb10-22" title="22">    ,<span class="ot"> output   ::</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb10-23" title="23">    ,<span class="ot"> possible ::</span> <span class="dt">STRef</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-24" title="24">    }</a>
<a class="sourceLine" id="cb10-25" title="25"></a>
<a class="sourceLine" id="cb10-26" title="26"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb10-27" title="27">whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</a>
<a class="sourceLine" id="cb10-28" title="28"></a>
<a class="sourceLine" id="cb10-29" title="29"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb10-30" title="30">tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-31" title="31">    tarjanEnv <span class="ot">&lt;-</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb10-32" title="32">        <span class="op">&lt;$&gt;</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb10-33" title="33">        <span class="op">&lt;*&gt;</span> newSTRef []</a>
<a class="sourceLine" id="cb10-34" title="34">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">False</span></a>
<a class="sourceLine" id="cb10-35" title="35">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-36" title="36">        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-37" title="37">        <span class="op">&lt;*&gt;</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb10-38" title="38">        <span class="op">&lt;*&gt;</span> newSTRef <span class="dt">True</span></a>
<a class="sourceLine" id="cb10-39" title="39"></a>
<a class="sourceLine" id="cb10-40" title="40">    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-41" title="41">        whenM ((<span class="op">&amp;&amp;</span>)</a>
<a class="sourceLine" id="cb10-42" title="42">            <span class="op">&lt;$&gt;</span> ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> (indices tarjanEnv) v)</a>
<a class="sourceLine" id="cb10-43" title="43">            <span class="op">&lt;*&gt;</span> readSTRef (possible tarjanEnv)) <span class="op">$</span></a>
<a class="sourceLine" id="cb10-44" title="44">                strongConnect n v graph tarjanEnv</a>
<a class="sourceLine" id="cb10-45" title="45"></a>
<a class="sourceLine" id="cb10-46" title="46">    readSTRef (output tarjanEnv)</a>
<a class="sourceLine" id="cb10-47" title="47">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-48" title="48">        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb10-49" title="49"></a>
<a class="sourceLine" id="cb10-50" title="50"><span class="ot">strongConnect ::</span> <span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">TarjanEnv</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb10-51" title="51">strongConnect n v graph tarjanEnv<span class="op">@</span><span class="dt">TarjanEnv</span>{ <span class="fu">index</span>, stack, stackSet, indices, lowlinks, output, possible } <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-52" title="52">    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></a>
<a class="sourceLine" id="cb10-53" title="53">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb10-54" title="54">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb10-55" title="55">    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-56" title="56">    push v</a>
<a class="sourceLine" id="cb10-57" title="57"></a>
<a class="sourceLine" id="cb10-58" title="58">    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb10-59" title="59">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-60" title="60">            strongConnect n w graph tarjanEnv</a>
<a class="sourceLine" id="cb10-61" title="61">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</a>
<a class="sourceLine" id="cb10-62" title="62">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></a>
<a class="sourceLine" id="cb10-63" title="63">            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</a>
<a class="sourceLine" id="cb10-64" title="64"></a>
<a class="sourceLine" id="cb10-65" title="65">    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-66" title="66">        scc <span class="ot">&lt;-</span> addSCC n v []</a>
<a class="sourceLine" id="cb10-67" title="67">        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb10-68" title="68">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-69" title="69"><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb10-70" title="70">        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc)</a>
<a class="sourceLine" id="cb10-71" title="71">            <span class="kw">then</span> writeSTRef possible <span class="dt">False</span> <span class="op">&gt;&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-72" title="72">            <span class="kw">else</span></a>
<a class="sourceLine" id="cb10-73" title="73">                <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</a>
<a class="sourceLine" id="cb10-74" title="74">                <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39;</a>
<a class="sourceLine" id="cb10-75" title="75"><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb10-76" title="76">        push e <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-77" title="77">            modifySTRef&#39; stack (e<span class="op">:</span>)</a>
<a class="sourceLine" id="cb10-78" title="78">            write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb10-79" title="79"><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-80" title="80">        pop <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-81" title="81">            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb10-82" title="82">            modifySTRef&#39; stack <span class="fu">tail</span></a>
<a class="sourceLine" id="cb10-83" title="83">            write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb10-84" title="84">            <span class="fu">return</span> e</a>
<a class="sourceLine" id="cb10-85" title="85"></a>
<a class="sourceLine" id="cb10-86" title="86">denormalise     <span class="ot">=</span> <span class="fu">subtract</span></a>
<a class="sourceLine" id="cb10-87" title="87">normalise       <span class="ot">=</span> (<span class="op">+</span>)</a>
<a class="sourceLine" id="cb10-88" title="88">other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</a>
<a class="sourceLine" id="cb10-89" title="89">clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb10-90" title="90"></a>
<a class="sourceLine" id="cb10-91" title="91"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-92" title="92">checkSat name <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-93" title="93">    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</a>
<a class="sourceLine" id="cb10-94" title="94">    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</a>
<a class="sourceLine" id="cb10-95" title="95">        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</a>
<a class="sourceLine" id="cb10-96" title="96">        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</a>
<a class="sourceLine" id="cb10-97" title="97">    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>This change does seem to make a significant difference, and it’s good to know we’re not doing useless work.</p>
<p>I think this is a good place to stop, and I hope I’ve been able to demonstrate some of Haskell’s strengths when it comes to refactoring. In my experience, it’s not usually necessary to deeply understand Haskell code in order to attempt a refactoring, especially if it’s backed by well-chosen types and a good test suite. I also find that I’m able to be more daring when writing new code, because bad up-front design is less costly and even the jankiest working code can be gently massaged into something presentable.</p>
<p><em>Thanks to <a href="https://joelburget.com/">Joel Burget</a>, <a href="http://www.matfournier.com/">Mat Fournier</a>, <a href="https://eskimor.gonimo.com/">Robert Klotzner</a>, <a href="https://github.com/L8D">Tenor</a>, <a href="http://www.tomharding.me/">Tom Harding</a>, and <a href="http://www.tylerweir.com/">Tyler Weir</a> for suggestions and feedback.</em></p>
]]></summary>
</entry>
<entry>
    <title>Moving Towards Dialogue</title>
    <link href="https://vaibhavsagar.com/blog/2018/11/03/moving-towards-dialogue/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/11/03/moving-towards-dialogue/index.html</id>
    <published>2018-11-03T00:00:00Z</published>
    <updated>2018-11-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on  3 November 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/idris/index.html">idris</a>
    
</div>

<p><em>This blog post is essentially a transcript of <a href="https://www.youtube.com/watch?v=0oo8wIi2qBE">a 10-minute talk I gave at !!Con</a>, the slides for which are available <a href="https://vaibhavsagar.com/presentations/typed-holes/">here</a>.</em></p>
<p>Let’s talk about typed holes. What’s a typed hole? A definition I like is <em>“a placeholder for an expression with a known type and an unknown value”</em>.</p>
<p>Why are typed holes useful? Because they allow the language to help us write programs! To demonstrate, let’s look at some code in Python, a language that lacks this feature.</p>
<p>Suppose I want to write a function that takes another function and a list and applies the function to each element of that list. A first stab might look like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): <span class="cf">return</span> []</a></code></pre></div>
<p>This is obviously wrong: this function ignores its arguments and gives us an empty list each time. This is no good, but what’s worse is that Python will accept this definition without complaint. It doesn’t seem to know (or care).</p>
<p>Let’s try again. I hear the way to do things with lists in Python is to use a list comprehension, so I make sure to use one of those this time:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): [f(e) <span class="cf">for</span> e <span class="kw">in</span> ls]</a>
<a class="sourceLine" id="cb2-2" title="2">...</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="op">&gt;&gt;&gt;</span> plusOne <span class="op">=</span> <span class="kw">lambda</span> i: i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(<span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]))</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="va">None</span></a></code></pre></div>
<p>But this definition is still wrong, because I forgot to put a <code>return</code> statement in! Again, Python will happily accept this.</p>
<p>I’m getting a bit frustrated at this point, so I look at how <code>map</code> is actually implemented. It uses a generator comprehension instead of a list comprehension, which makes it more general somehow, so I make sure to use that, and I remember to put a <code>return</code> statement in this time:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): <span class="cf">return</span> (f(e) <span class="cf">for</span> e <span class="kw">in</span> ls)</a>
<a class="sourceLine" id="cb3-2" title="2">...</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(<span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]))</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="op">&lt;</span>generator <span class="bu">object</span> <span class="bu">map</span>.<span class="op">&lt;</span><span class="bu">locals</span><span class="op">&gt;</span>.<span class="op">&lt;</span>genexpr<span class="op">&gt;</span> at <span class="bn">0x7ffb92103ca8</span><span class="op">&gt;</span></a></code></pre></div>
<p>And now instead of giving me something useful, this function gives me an address in memory, which seems especially pointless.</p>
<p>I give up. This example seems contrived, but over the course of my relationship with Python, which is more than a decade long now, I’ve seen the same dynamic play out embarrassingly many times. How do I write programs that work? Surely this is a simple question with a straightforward answer.</p>
<p>Indeed, the most common response I get when I ask this question is to write tests. That sounds reasonable, so let’s do that:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls):</a>
<a class="sourceLine" id="cb4-2" title="2">...     <span class="bu">print</span>(<span class="st">&quot;Where are your tests now?&quot;</span>)</a>
<a class="sourceLine" id="cb4-3" title="3">...     <span class="cf">return</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb4-4" title="4">...</a>
<a class="sourceLine" id="cb4-5" title="5"><span class="op">&gt;&gt;&gt;</span> <span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb4-6" title="6">Where are your tests now?</a>
<a class="sourceLine" id="cb4-7" title="7"><span class="va">True</span></a></code></pre></div>
<p>Okay, my test passes, so everything must be good, right?</p>
<p>I contend that tests are necessary, but not sufficient. They are problematic for at least two reasons:</p>
<ol type="1">
<li>They are only as good as the specification they imply for how a program should behave. If that specification is incomplete or wrong, no amount of tests will guarantee software that works.</li>
<li>The language doesn’t understand tests, by which I mean that it’s extremely difficult to automatically go from a failing test to the part of the code where the error lives. The programmer has to do the legwork of tracking down the bug based on essentially one bit of information in many cases.</li>
</ol>
<p>Fortunately, tests aren’t the only specification of how a program should behave. Types can also serve as specifications, and they have the advantage that they are extremely well integrated into the language in a way tests usually are not.</p>
<p>What does this mean in practice? Let’s look at Haskell. Haskell is statically typed, which means it expects to know the types of all the expressions in your program at compile time. This is nothing special though, lots of other languages also claim to be statically typed. What is special about Haskell though is that it has type inference, which means that you don’t have to annotate expressions with their types most of the time because the compiler can figure it out. If you put these two features together, you get typed holes!</p>
<p>Let’s try to write that same program in Haskell with typed holes. To start, let’s create a file called <code>Main.hs</code> with the following contents:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="fu">map</span> f ls <span class="ot">=</span> _</a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-7" title="7">plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-10" title="10">main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>To automate the cycle of loading this file into GHCi every time we make a change, we’re going to use <a href="https://github.com/ndmitchell/ghcid"><code>ghcid</code></a>, which does essentially that and not much else. This is the result of running <code>ghcid Main.hs</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb6-1" title="1">Main.hs:4:12: error:</a>
<a class="sourceLine" id="cb6-2" title="2">    • Found hole: _ :: [b]</a>
<a class="sourceLine" id="cb6-3" title="3">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb6-4" title="4">               the type signature for:</a>
<a class="sourceLine" id="cb6-5" title="5">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb6-6" title="6">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb6-7" title="7">    • In the expression: _</a>
<a class="sourceLine" id="cb6-8" title="8">      In an equation for ‘map’: map f ls = _</a>
<a class="sourceLine" id="cb6-9" title="9">    • Relevant bindings include</a>
<a class="sourceLine" id="cb6-10" title="10">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb6-11" title="11">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb6-12" title="12">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb6-13" title="13">  |</a>
<a class="sourceLine" id="cb6-14" title="14">4 | map f ls = _</a>
<a class="sourceLine" id="cb6-15" title="15">  |            ^</a></code></pre></div>
<p>I’d suggest ignoring the middle and instead focusing on the top, which tells us the type of the hole, and the bottom, which tells us which bindings are in scope that we can use to fill in the hole.</p>
<p>In this case we aren’t learning anything new, and we already know that the hole is of type <code>[b]</code>, but it’s useful to know that our view of the world agrees with GHC’s. Of the bindings available to us, <code>ls</code> looks like the most promising, and we can split it into one of two cases: an empty list, or some element and the rest of the list. We can put a typed hole on the right hand side of each case alternative:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb7-4" title="4"><span class="fu">map</span> f ls <span class="ot">=</span> <span class="kw">case</span> ls <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-5" title="5">    [] <span class="ot">-&gt;</span> _1</a>
<a class="sourceLine" id="cb7-6" title="6">    x<span class="op">:</span>xs <span class="ot">-&gt;</span> _2</a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-9" title="9">plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-12" title="12">main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>And our <code>ghcid</code> output changes:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb8-1" title="1">Main.hs:5:11-12: error:</a>
<a class="sourceLine" id="cb8-2" title="2">    • Found hole: _1 :: [b]</a>
<a class="sourceLine" id="cb8-3" title="3">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb8-4" title="4">               the type signature for:</a>
<a class="sourceLine" id="cb8-5" title="5">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb8-6" title="6">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb8-7" title="7">      Or perhaps ‘_1’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb8-8" title="8">    • In the expression: _1</a>
<a class="sourceLine" id="cb8-9" title="9">      In a case alternative: [] -&gt; _1</a>
<a class="sourceLine" id="cb8-10" title="10">      In the expression:</a>
<a class="sourceLine" id="cb8-11" title="11">        case ls of</a>
<a class="sourceLine" id="cb8-12" title="12">          [] -&gt; _1</a>
<a class="sourceLine" id="cb8-13" title="13">          x : xs -&gt; _2</a>
<a class="sourceLine" id="cb8-14" title="14">    • Relevant bindings include</a>
<a class="sourceLine" id="cb8-15" title="15">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb8-16" title="16">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb8-17" title="17">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb8-18" title="18">  |</a>
<a class="sourceLine" id="cb8-19" title="19">5 |     [] -&gt; _1</a>
<a class="sourceLine" id="cb8-20" title="20">  |           ^^</a>
<a class="sourceLine" id="cb8-21" title="21">Main.hs:6:13-14: error:</a>
<a class="sourceLine" id="cb8-22" title="22">    • Found hole: _2 :: [b]</a>
<a class="sourceLine" id="cb8-23" title="23">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb8-24" title="24">               the type signature for:</a>
<a class="sourceLine" id="cb8-25" title="25">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb8-26" title="26">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb8-27" title="27">      Or perhaps ‘_2’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb8-28" title="28">    • In the expression: _2</a>
<a class="sourceLine" id="cb8-29" title="29">      In a case alternative: x : xs -&gt; _2</a>
<a class="sourceLine" id="cb8-30" title="30">      In the expression:</a>
<a class="sourceLine" id="cb8-31" title="31">        case ls of</a>
<a class="sourceLine" id="cb8-32" title="32">          [] -&gt; _1</a>
<a class="sourceLine" id="cb8-33" title="33">          x : xs -&gt; _2</a>
<a class="sourceLine" id="cb8-34" title="34">    • Relevant bindings include</a>
<a class="sourceLine" id="cb8-35" title="35">        xs :: [a] (bound at Main.hs:6:7)</a>
<a class="sourceLine" id="cb8-36" title="36">        x :: a (bound at Main.hs:6:5)</a>
<a class="sourceLine" id="cb8-37" title="37">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb8-38" title="38">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb8-39" title="39">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb8-40" title="40">  |</a>
<a class="sourceLine" id="cb8-41" title="41">6 |     x:xs -&gt; _2</a>
<a class="sourceLine" id="cb8-42" title="42">  |             ^^</a></code></pre></div>
<p>We haven’t learned anything new about the types, but we can make progress another way. The only sensible thing to put on the right hand side when given an empty list is another empty list, and after splitting a list apart the most reasonable thing to do is to combine two other things into a new list:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb9-4" title="4"><span class="fu">map</span> f ls <span class="ot">=</span> <span class="kw">case</span> ls <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-5" title="5">    [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb9-6" title="6">    x<span class="op">:</span>xs <span class="ot">-&gt;</span> _1<span class="op">:</span>_2</a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-9" title="9">plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-10" title="10"></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-12" title="12">main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Now the output gets a little more interesting:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb10-1" title="1">Main.hs:6:13-14: error:</a>
<a class="sourceLine" id="cb10-2" title="2">    • Found hole: _1 :: b</a>
<a class="sourceLine" id="cb10-3" title="3">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb10-4" title="4">               the type signature for:</a>
<a class="sourceLine" id="cb10-5" title="5">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb10-6" title="6">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb10-7" title="7">      Or perhaps ‘_1’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb10-8" title="8">    • In the first argument of ‘(:)’, namely ‘_1’</a>
<a class="sourceLine" id="cb10-9" title="9">      In the expression: _1 : _2</a>
<a class="sourceLine" id="cb10-10" title="10">      In a case alternative: x : xs -&gt; _1 : _2</a>
<a class="sourceLine" id="cb10-11" title="11">    • Relevant bindings include</a>
<a class="sourceLine" id="cb10-12" title="12">        xs :: [a] (bound at Main.hs:6:7)</a>
<a class="sourceLine" id="cb10-13" title="13">        x :: a (bound at Main.hs:6:5)</a>
<a class="sourceLine" id="cb10-14" title="14">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb10-15" title="15">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb10-16" title="16">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb10-17" title="17">  |</a>
<a class="sourceLine" id="cb10-18" title="18">6 |     x:xs -&gt; _1:_2</a>
<a class="sourceLine" id="cb10-19" title="19">  |             ^^</a>
<a class="sourceLine" id="cb10-20" title="20">Main.hs:6:16-17: error:</a>
<a class="sourceLine" id="cb10-21" title="21">    • Found hole: _2 :: [b]</a>
<a class="sourceLine" id="cb10-22" title="22">      Where: ‘b’ is a rigid type variable bound by</a>
<a class="sourceLine" id="cb10-23" title="23">               the type signature for:</a>
<a class="sourceLine" id="cb10-24" title="24">                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</a>
<a class="sourceLine" id="cb10-25" title="25">               at Main.hs:3:1-29</a>
<a class="sourceLine" id="cb10-26" title="26">      Or perhaps ‘_2’ is mis-spelled, or not in scope</a>
<a class="sourceLine" id="cb10-27" title="27">    • In the second argument of ‘(:)’, namely ‘_2’</a>
<a class="sourceLine" id="cb10-28" title="28">      In the expression: _1 : _2</a>
<a class="sourceLine" id="cb10-29" title="29">      In a case alternative: x : xs -&gt; _1 : _2</a>
<a class="sourceLine" id="cb10-30" title="30">    • Relevant bindings include</a>
<a class="sourceLine" id="cb10-31" title="31">        xs :: [a] (bound at Main.hs:6:7)</a>
<a class="sourceLine" id="cb10-32" title="32">        x :: a (bound at Main.hs:6:5)</a>
<a class="sourceLine" id="cb10-33" title="33">        ls :: [a] (bound at Main.hs:4:7)</a>
<a class="sourceLine" id="cb10-34" title="34">        f :: a -&gt; b (bound at Main.hs:4:5)</a>
<a class="sourceLine" id="cb10-35" title="35">        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</a>
<a class="sourceLine" id="cb10-36" title="36">  |</a>
<a class="sourceLine" id="cb10-37" title="37">6 |     x:xs -&gt; _1:_2</a>
<a class="sourceLine" id="cb10-38" title="38">  |                ^^</a></code></pre></div>
<p>Our first hole is now of type <code>b</code>, and we see that it’s possible to get a value of this type by applying <code>f</code> to <code>x</code>. The second hole is still of type <code>[b]</code>, and we see that the most reasonable way to get a value of this type is to recurse, using <code>map</code> with <code>f</code> and <code>xs</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb11-2" title="2"></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb11-4" title="4"><span class="fu">map</span> f ls <span class="ot">=</span> <span class="kw">case</span> ls <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-5" title="5">    [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb11-6" title="6">    x<span class="op">:</span>xs <span class="ot">-&gt;</span> f x<span class="op">:</span> <span class="fu">map</span> f xs</a>
<a class="sourceLine" id="cb11-7" title="7"></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-9" title="9">plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-10" title="10"></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-12" title="12">main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>And <code>ghcid</code> is satisfied:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb12-1" title="1">All good (1 module, at &lt;time&gt;)</a></code></pre></div>
<p>It compiles! But does it work?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" title="1">$ <span class="ex">runhaskell</span> Main.hs</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ex">True</span></a></code></pre></div>
<p>Fantastic! We were able to ask the compiler for hints and get useful answers back. This is a gigantic improvement over anything I’m aware of in Python land.</p>
<p>Unfortunately, there is a catch: this program is too easy to break. Let me demonstrate my favourite way:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb14-4" title="4"><span class="fu">map</span> f ls <span class="ot">=</span> []</a>
<a class="sourceLine" id="cb14-5" title="5"></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb14-7" title="7">plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-8" title="8"></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb14-10" title="10">main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>The astute reader will notice that this is the Haskell equivalent of the obviously broken Python program we started with. Here is what <code>ghcid</code> has to say:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb15-1" title="1">All good (1 module, at &lt;time&gt;)</a></code></pre></div>
<p>So what’s going on here? It turns out an empty list is a valid list of any type. Is it a list of Strings? Yup. Is it a list of Ints? Sure!</p>
<p>One way of avoiding this class of incorrect program is to specify that the input and the output lists should be of the same length. It’s possible to do this in Haskell, but it is a lot of work. Can we do better?</p>
<p>Enter Idris.</p>
<p>Idris is a functional programming language with a more sophisticated type system than Haskell’s. Unfortunately it trades off some type inference to achieve this, so it’s not strictly better than Haskell in every way. It has excellent built-in editor support, and therefore has fancier typed holes!</p>
<p>Let’s try to implement <code>map</code> again:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb16-4" title="4"></a>
<a class="sourceLine" id="cb16-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb16-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb16-8" title="8"></a>
<a class="sourceLine" id="cb16-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb16-10" title="10"></a>
<a class="sourceLine" id="cb16-11" title="11"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-12" title="12">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-13" title="13"></a>
<a class="sourceLine" id="cb16-14" title="14"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-15" title="15">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Instead of implementing <code>map</code> on lists, we’ll use a more interesting type called <code>Vect</code> which is essentially a list that knows about its length. A <code>Vect</code> can either be <code>Nil</code> of length <code>0</code> or an element on the front of another <code>Vect</code> of some length <code>length</code> giving us a new <code>Vect</code> of length <code>length + 1</code>. I’ve also gone ahead defined equality on these <code>Vect</code>s because I use it in <code>main</code>.</p>
<p>Loading the file into the Idris REPL gives us access to the editor integration:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb17-1" title="1">$ <span class="ex">idris</span> Main.idr</a>
<a class="sourceLine" id="cb17-2" title="2">     <span class="ex">____</span>    __     _</a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="ex">/</span>  _/___/ /____(_)<span class="ex">____</span></a>
<a class="sourceLine" id="cb17-4" title="4">    <span class="ex">/</span> // __  / ___/ / ___/     Version 1.3.0</a>
<a class="sourceLine" id="cb17-5" title="5">  <span class="ex">_/</span> // /_/ / /  / (__  )      <span class="ex">http</span>://www.idris-lang.org/</a>
<a class="sourceLine" id="cb17-6" title="6"> <span class="ex">/___</span>/\<span class="ex">__</span>,_/_/  /_/____/       Type :? for help</a>
<a class="sourceLine" id="cb17-7" title="7"></a>
<a class="sourceLine" id="cb17-8" title="8"><span class="ex">Idris</span> is free software with ABSOLUTELY NO WARRANTY.</a>
<a class="sourceLine" id="cb17-9" title="9"><span class="ex">For</span> details type :warranty.</a>
<a class="sourceLine" id="cb17-10" title="10"><span class="ex">Type</span> checking ./Main.idr</a>
<a class="sourceLine" id="cb17-11" title="11"><span class="ex">Holes</span>: Main.map</a>
<a class="sourceLine" id="cb17-12" title="12"><span class="ex">*Main</span><span class="op">&gt;</span></a></code></pre></div>
<p>In vim, I can use <code>&lt;localleader&gt;d</code> with the cursor on <code>map</code> to fill in a skeleton definition:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb18-4" title="4"></a>
<a class="sourceLine" id="cb18-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb18-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb18-8" title="8"></a>
<a class="sourceLine" id="cb18-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb18-10" title="10">map f x <span class="fu">=</span> <span class="ot">?map_rhs</span></a>
<a class="sourceLine" id="cb18-11" title="11"></a>
<a class="sourceLine" id="cb18-12" title="12"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-13" title="13">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb18-14" title="14"></a>
<a class="sourceLine" id="cb18-15" title="15"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb18-16" title="16">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Using <code>&lt;localleader&gt;t</code> with the cursor on the typed hole provides a type for us:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb19-1" title="1">  b : Type</a>
<a class="sourceLine" id="cb19-2" title="2">  a : Type</a>
<a class="sourceLine" id="cb19-3" title="3">  f : a -&gt; b</a>
<a class="sourceLine" id="cb19-4" title="4">  length : Nat</a>
<a class="sourceLine" id="cb19-5" title="5">  x : Vect length a</a>
<a class="sourceLine" id="cb19-6" title="6">--------------------------------------</a>
<a class="sourceLine" id="cb19-7" title="7">map_rhs : Vect length b</a></code></pre></div>
<p>But we don’t need to go down this route. We can make Idris do a case-split for us with <code>&lt;localleader&gt;c</code> with the cursor on <code>x</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb20-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb20-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb20-8" title="8"></a>
<a class="sourceLine" id="cb20-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb20-10" title="10">map f [] <span class="fu">=</span> <span class="ot">?map_rhs_1</span></a>
<a class="sourceLine" id="cb20-11" title="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> <span class="ot">?map_rhs_2</span></a>
<a class="sourceLine" id="cb20-12" title="12"></a>
<a class="sourceLine" id="cb20-13" title="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-14" title="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb20-15" title="15"></a>
<a class="sourceLine" id="cb20-16" title="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-17" title="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>Again, as with our Haskell example, the only sensible output when the input is an empty <code>Vect</code> is another empty <code>Vect</code>. We think so, but what does Idris think? It has a nifty feature called “proof search” that can search the space of all possible programs that fit and choose the first one. We can use this with <code>&lt;localleader&gt;o</code> (‘o’ is for obvious):</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb21-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb21-4" title="4"></a>
<a class="sourceLine" id="cb21-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb21-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb21-8" title="8"></a>
<a class="sourceLine" id="cb21-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb21-10" title="10">map f [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb21-11" title="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> <span class="ot">?map_rhs_2</span></a>
<a class="sourceLine" id="cb21-12" title="12"></a>
<a class="sourceLine" id="cb21-13" title="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb21-14" title="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb21-15" title="15"></a>
<a class="sourceLine" id="cb21-16" title="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb21-17" title="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>And we get the result we expect. This works for the simple case, but does it work for the more complex one?</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb22-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb22-4" title="4"></a>
<a class="sourceLine" id="cb22-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb22-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb22-8" title="8"></a>
<a class="sourceLine" id="cb22-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb22-10" title="10">map f [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb22-11" title="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> f x <span class="ot">::</span> map f y</a>
<a class="sourceLine" id="cb22-12" title="12"></a>
<a class="sourceLine" id="cb22-13" title="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb22-14" title="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-15" title="15"></a>
<a class="sourceLine" id="cb22-16" title="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb22-17" title="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>It does!</p>
<p>What happens when we try to break this like we broke our Haskell program?</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode idris"><code class="sourceCode idris"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" title="2">    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</a>
<a class="sourceLine" id="cb23-3" title="3">    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</a>
<a class="sourceLine" id="cb23-4" title="4"></a>
<a class="sourceLine" id="cb23-5" title="5">implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-6" title="6">    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb23-7" title="7">    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</a>
<a class="sourceLine" id="cb23-8" title="8"></a>
<a class="sourceLine" id="cb23-9" title="9"><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</a>
<a class="sourceLine" id="cb23-10" title="10">map f [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb23-11" title="11">map f (x <span class="ot">::</span> y) <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb23-12" title="12"></a>
<a class="sourceLine" id="cb23-13" title="13"><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb23-14" title="14">plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb23-15" title="15"></a>
<a class="sourceLine" id="cb23-16" title="16"><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb23-17" title="17">main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</a></code></pre></div>
<p>This is what Idris has to say:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb24-1" title="1">*Main&gt; :r</a>
<a class="sourceLine" id="cb24-2" title="2">Type checking ./Main.idr</a>
<a class="sourceLine" id="cb24-3" title="3">Main.idr:11:18-19:</a>
<a class="sourceLine" id="cb24-4" title="4">   |</a>
<a class="sourceLine" id="cb24-5" title="5">11 | map f (x :: y) = []</a>
<a class="sourceLine" id="cb24-6" title="6">   |                  ~~</a>
<a class="sourceLine" id="cb24-7" title="7">When checking right hand side of Main.map with expected type</a>
<a class="sourceLine" id="cb24-8" title="8">        Vect (1 + length) b</a>
<a class="sourceLine" id="cb24-9" title="9"></a>
<a class="sourceLine" id="cb24-10" title="10">Type mismatch between</a>
<a class="sourceLine" id="cb24-11" title="11">        Vect 0 a (Type of [])</a>
<a class="sourceLine" id="cb24-12" title="12">and</a>
<a class="sourceLine" id="cb24-13" title="13">        Vect (S length) b (Expected type)</a>
<a class="sourceLine" id="cb24-14" title="14"></a>
<a class="sourceLine" id="cb24-15" title="15">Specifically:</a>
<a class="sourceLine" id="cb24-16" title="16">        Type mismatch between</a>
<a class="sourceLine" id="cb24-17" title="17">                0</a>
<a class="sourceLine" id="cb24-18" title="18">        and</a>
<a class="sourceLine" id="cb24-19" title="19">                S length</a>
<a class="sourceLine" id="cb24-20" title="20"></a>
<a class="sourceLine" id="cb24-21" title="21">Holes: Main.map</a></code></pre></div>
<p>We get a useful and informative error message.</p>
<p>And we’ve done it! You can download and use these languages today. When using other languages with static types, I always felt that they existed merely as busywork and I essentially had to shove them down the compiler’s throat in order to get it to accept my program, and I feel the opposite way about these languages. In other words, types are friends, not food! They can help you design your program, write that program, and even debug it if necessary.</p>
<p>One aspect of programming that always bothered me was my perception of the compiler (or interpreter) as some sort of gatekeeper whose job was to dismiss my program until it met some arbitrary standard. Even worse, I would find myself writing a program that passed but was subtly incorrect, and I would iterate on this process, writing a series of subtly incorrect programs without any guidance from my tools. Discovering typed holes and the style of programming they enable has shown me a different approach, where I can open up a dialogue with my language and collaborate on writing a program whose correctness I am more confident of.</p>
<p>That’s all I have to say about typed holes, but there’s recently been interesting work on untyped holes that I would like to mention briefly. Suppose you like the idea of holes but not the idea of types, or you work in a language that isn’t statically typed and you want some of these benefits. What you could do is:</p>
<ol type="1">
<li>Write a program with gaps where you’re unsure what should happen (we’ll call this a <em>sketch</em>)</li>
<li>Write some test cases that the correct program should satisfy</li>
<li>Feed both these things to a SAT/SMT solver (a clever program with a bag of tricks)</li>
<li>???</li>
<li>Profit!!!</li>
</ol>
<p>The solver churns through the space of all prossible programs and picks the one that passes the tests, giving us the correct program we wanted!</p>
<p>This sounds great in theory, so why aren’t we doing this yet? There is (predictably) a catch, which is that this is still a research topic for now. You can read <a href="https://people.csail.mit.edu/asolar/papers/thesis.pdf">Armando Solar-Lezama’s PhD thesis on this</a>, and systems like <a href="http://comcom.csail.mit.edu/comcom/#Synquid">Synquid</a> and <a href="https://github.com/webyrd/Barliman">Barliman</a> demonstrate the current state of the art. I think it’s especially interesting that Synquid has both typed and untyped holes, which suggests to me that it is the most promising approach.</p>
<p>I’ll leave you with some resources about typed holes, particularly Conor McBride’s presentations at <a href="https://www.youtube.com/watch?v=3U3lV5VPmOU">YOW! Lambda Jam</a> and <a href="https://skillsmatter.com/skillscasts/8893-is-a-type-a-lifebuoy-or-a-lamp">Haskell eXchange</a> that are rich with insight. There’s also <a href="https://www.shimweasel.com/2015/02/17/typed-holes-for-beginners">a tutorial by Mark Wotton</a>, and finally <a href="http://hazel.org/">Hazel</a>, which is a live functional programming environment with typed holes!</p>
<p>I hope I’ve encouraged you to try this style of programming for yourself. There’s never been a better time to do it.</p>
]]></summary>
</entry>
<entry>
    <title>HAMTs from Scratch</title>
    <link href="https://vaibhavsagar.com/blog/2018/07/29/hamts-from-scratch/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/07/29/hamts-from-scratch/index.html</id>
    <published>2018-07-29T00:00:00Z</published>
    <updated>2018-07-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 29 July 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>
    
</div>

<p><em>This blog post is also an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/hamt/HAMTsFromScratch.ipynb">IHaskell notebook</a> and the source is available <a href="https://github.com/vaibhavsagar/notebooks/tree/master/hamt/hamt">separately</a>. I also <a href="https://www.youtube.com/watch?v=wgMgtgVZdYg">did a talk at NYHUG based on this material</a>.</em></p>
<p>I wanted an explanation for HAMTs (Hash Array Mapped Tries) that was more detailed than <a href="https://idea.popcount.org/2012-07-25-introduction-to-hamt/">Marek Majkowski’s introduction</a> and more approachable than <a href="https://lampwww.epfl.ch/papers/idealhashtrees.pdf"><em>Ideal Hash Trees</em> by Phil Bagwell</a>, the paper that introduced them. If you haven’t heard of them before, HAMTs are a way of efficiently representing a hashtable as a <a href="https://en.wikipedia.org/wiki/Trie">trie</a>, and although they were first envisioned as a mutable data structure they are easily adapted to work as a <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structure</a>. They form the backbone of the <a href="http://hackage.haskell.org/package/unordered-containers"><code>unordered-containers</code></a> library but the <a href="https://github.com/tibbe/unordered-containers/blob/efa43a2ab09dc6eb72893d12676a8e188cb4ca63/Data/HashMap/Base.hs">implementation has been lovingly optimised</a> to the point where I found it impenetrable. <a href="https://github.com/ezyang/hamt/blob/a43559795630980eb16ab832a003d8e6acd21cf6/HAMT.hs">Edward Z. Yang’s implementation</a> is much easier to follow and after adapting it I think I’m in a good place to provide my own take on them.</p>
<p>Let’s start with a few imports! I’ll be using these packages:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/base"><code>base</code></a></li>
<li><a href="http://hackage.haskell.org/package/bytestring"><code>bytestring</code></a></li>
<li><a href="http://hackage.haskell.org/package/memory"><code>memory</code></a></li>
<li><a href="http://hackage.haskell.org/package/pretty-show"><code>pretty-show</code></a></li>
<li><a href="http://hackage.haskell.org/package/timeit"><code>timeit</code></a></li>
<li><a href="http://hackage.haskell.org/package/vector"><code>vector</code></a></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="dt">Data.Bits</span>             (<span class="dt">Bits</span> (bit, complement, popCount, shiftR, (.&amp;.), (.|.)),</a>
<a class="sourceLine" id="cb1-2" title="2">                              <span class="dt">FiniteBits</span> (finiteBitSize))</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="dt">Data.ByteArray.Hash</span>   (<span class="dt">FnvHash32</span> (..), fnv1Hash)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="dt">Data.ByteString.Char8</span> (pack)</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="dt">Data.Char</span>             (intToDigit)</a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span> <span class="dt">Data.Semigroup</span>        ((&lt;&gt;))</a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">import</span> <span class="dt">Data.Vector</span>           (<span class="dt">Vector</span>, drop, singleton, take, (!), (//))</a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">import</span> <span class="dt">Data.Word</span>             (<span class="dt">Word16</span>, <span class="dt">Word32</span>)</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">import</span> <span class="dt">Numeric</span>               (showIntAtBase)</a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">import</span> <span class="dt">Prelude</span>               <span class="kw">hiding</span> (drop, lookup, take)</a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">import</span> <span class="dt">System.TimeIt</span>         (timeIt)</a>
<a class="sourceLine" id="cb1-12" title="12"><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span>      (pPrint)</a></code></pre></div>
<p>We’re going to be doing some bit twiddling. To make this easier to follow I’m going to define a <code>newtype</code> whose <code>Show</code> instance displays the binary representation.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">newtype</span> <span class="dt">Binary</span> a <span class="ot">=</span> <span class="dt">Binary</span> a</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="kw">deriving</span> (<span class="dt">Enum</span>, <span class="dt">Ord</span>, <span class="dt">Real</span>, <span class="dt">Integral</span>, <span class="dt">Eq</span>, <span class="dt">Num</span>, <span class="dt">Bits</span>, <span class="dt">FiniteBits</span>)</a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="kw">instance</span> (<span class="dt">FiniteBits</span> a, <span class="dt">Show</span> a, <span class="dt">Integral</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Binary</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="fu">show</span> (<span class="dt">Binary</span> n) <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb2-8" title="8">        str <span class="ot">=</span> showIntAtBase <span class="dv">2</span> <span class="fu">intToDigit</span> n <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb2-9" title="9">        size <span class="ot">=</span> finiteBitSize n</a>
<a class="sourceLine" id="cb2-10" title="10">        <span class="kw">in</span> <span class="fu">replicate</span> (size <span class="op">-</span> <span class="fu">length</span> str) <span class="ch">&#39;0&#39;</span> <span class="op">&lt;&gt;</span> str</a></code></pre></div>
<p>Using this <code>newtype</code> we can turn this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="dv">24732</span><span class="ot"> ::</span> <span class="dt">Word16</span></a></code></pre></div>
<pre><code>24732</code></pre>
<p>into this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="dv">24732</span><span class="ot"> ::</span> <span class="dt">Binary</span> <span class="dt">Word16</span></a></code></pre></div>
<pre><code>0110000010011100</code></pre>
<p>I’m going to use 32-bit hashes (because they’re more convenient to display than 64-bit ones) and 16-bit bitmaps.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">type</span> <span class="dt">Hash</span> <span class="ot">=</span> <span class="dt">Binary</span> <span class="dt">Word32</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">type</span> <span class="dt">Bitmap</span> <span class="ot">=</span> <span class="dt">Binary</span> <span class="dt">Word16</span></a></code></pre></div>
<p>The width of bitmaps is <span class="math inline">2<sup><em>n</em></sup></span> where <span class="math inline"><em>n</em></span> is the number of bits of the hash that we use at each level of the tree (more on this below). I’m setting <span class="math inline"><em>n</em> = 4</span> which is what <code>unordered-containers</code> uses (as of this writing), but we could e.g. set <span class="math inline"><em>n</em> = 5</span> and use 32-bit bitmaps if we wanted.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">bitsPerSubkey ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" title="2">bitsPerSubkey <span class="ot">=</span> <span class="dv">4</span></a></code></pre></div>
<p><code>Shift</code> is a multiple of <span class="math inline"><em>n</em></span> that we will use to focus on the correct part of the hash.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">type</span> <span class="dt">Shift</span> <span class="ot">=</span> <span class="dt">Int</span></a></code></pre></div>
<p>I’m also going to define a <code>Hashable</code> class to decouple the choice of a hash function from the implementation of <code>HAMT</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">class</span> <span class="dt">Hashable</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ot">    hash ::</span> a <span class="ot">-&gt;</span> <span class="dt">Hash</span></a></code></pre></div>
<p>For convenience, we’ll use the FNV-1 hash function with strings.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb11-3" title="3"></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">String</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-5" title="5">    hash s <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb11-6" title="6">        <span class="dt">FnvHash32</span> h <span class="ot">=</span> fnv1Hash (<span class="fu">pack</span> s)</a>
<a class="sourceLine" id="cb11-7" title="7">        <span class="kw">in</span> <span class="dt">Binary</span> h</a></code></pre></div>
<p>Here’s what it looks like in practice.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1">hash <span class="st">&quot;1&quot;</span><span class="ot"> ::</span> <span class="dt">Binary</span> <span class="dt">Word32</span></a></code></pre></div>
<pre><code>00000101000011000101110100101110</code></pre>
<p>A HAMT can be</p>
<ul>
<li>empty (<code>None</code>)</li>
<li>a leaf node with the hash, the key, and the value (<code>Leaf</code>)</li>
<li>a node with a bitmap and a (non-empty) vector of child HAMTs (<code>Many</code>)</li>
</ul>
<p>I’ve chosen to ignore the possibility of collisions, but we could handle them by adding an extra constructor, e.g. <code>Colliding</code> with a hash and a vector of key-value pairs.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">data</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb14-2" title="2">    <span class="ot">=</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="op">|</span> <span class="dt">Leaf</span> <span class="dt">Hash</span> key value</a>
<a class="sourceLine" id="cb14-4" title="4">    <span class="op">|</span> <span class="dt">Many</span> <span class="dt">Bitmap</span> (<span class="dt">Vector</span> (<span class="dt">HAMT</span> key value))</a>
<a class="sourceLine" id="cb14-5" title="5">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="ot">empty ::</span> <span class="dt">HAMT</span> k v</a>
<a class="sourceLine" id="cb14-8" title="8">empty <span class="ot">=</span> <span class="dt">None</span></a></code></pre></div>
<p>We’ll need some helper functions for vectors:</p>
<ul>
<li><code>insertAt</code> inserts an element at a specified index, shifting elements to the right forwards</li>
<li><code>updateAt</code> replaces an element at a specified index with a new element</li>
<li><code>deleteAt</code> removes an element at an index, shifting elements to the right backwards</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">insertAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</a>
<a class="sourceLine" id="cb15-2" title="2">insertAt vector <span class="fu">index</span> a <span class="ot">=</span> <span class="fu">take</span> <span class="fu">index</span> vector <span class="op">&lt;&gt;</span> singleton a <span class="op">&lt;&gt;</span> <span class="fu">drop</span> <span class="fu">index</span> vector</a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="ot">updateAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</a>
<a class="sourceLine" id="cb15-5" title="5">updateAt vector <span class="fu">index</span> a <span class="ot">=</span> vector <span class="op">//</span> [(<span class="fu">index</span>, a)]</a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="ot">deleteAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</a>
<a class="sourceLine" id="cb15-8" title="8">deleteAt vector <span class="fu">index</span> <span class="ot">=</span> <span class="fu">take</span> <span class="fu">index</span> vector <span class="op">&lt;&gt;</span> <span class="fu">drop</span> (<span class="fu">index</span><span class="op">+</span><span class="dv">1</span>) vector</a></code></pre></div>
<h3 id="insert">Insert</h3>
<p>I think the bit manipulation functions are crucial to understanding what’s going on, so I’m going to motivate them by trying to define <code>insert</code> without them and coming up with them as they are needed. This initial definition won’t be quite right so I’ll call it <code>insert_</code> to differentiate it from the correct <code>insert'</code> function I present later. The type signature for <code>insert_</code> is</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">insert_ ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a></code></pre></div>
<p>Inserting a key-value pair into an empty HAMT gives us a single leaf node:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1">insert_ hash key value <span class="dt">None</span> <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</a></code></pre></div>
<p>Inserting a key-value pair into a single leaf node where the hashes match gives us an updated leaf node (because we’re pretending collisions don’t exist):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">insert_ hash key value (<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</a></code></pre></div>
<p>Inserting into a HAMT consisting of a single leaf node where the hashes don’t match upgrades that leaf node to a <code>Many</code> node and inserts the key-value pair into that <code>Many</code> node:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1">insert_ hash key value leaf<span class="op">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb19-2" title="2">    <span class="op">|</span> hash <span class="op">/=</span> leafHash <span class="ot">=</span> insert_ key value (<span class="dt">Many</span> someBitmap (singleton leaf))</a>
<a class="sourceLine" id="cb19-3" title="3">    <span class="kw">where</span> someBitmap <span class="ot">=</span> <span class="fu">undefined</span></a></code></pre></div>
<h4 id="bit-masking">Bit Masking</h4>
<p>Where does <code>someBitmap</code> come from? Time for an example! Let’s start with a <code>Leaf (hash "1") "1" 1</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1">h <span class="ot">=</span> hash <span class="st">&quot;1&quot;</span></a>
<a class="sourceLine" id="cb20-2" title="2">leaf <span class="ot">=</span> <span class="dt">Leaf</span> h <span class="st">&quot;1&quot;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb20-3" title="3"></a>
<a class="sourceLine" id="cb20-4" title="4">leaf</a></code></pre></div>
<pre><code>Leaf 00000101000011000101110100101110 &quot;1&quot; 1</code></pre>
<p><code>someBitMap</code> is a 16-bit bitmap where the number of bits set (the <code>popCount</code>) is the length of the vector, which in this case is <span class="math inline">1</span>. We want to set one bit, but which bit? We carve off the last <span class="math inline"><em>n</em></span> bits using a mask:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="ot">subkeyMask ::</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb22-2" title="2">subkeyMask <span class="ot">=</span> (bit bitsPerSubkey) <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-3" title="3"></a>
<a class="sourceLine" id="cb22-4" title="4">subkeyMask</a></code></pre></div>
<pre><code>0000000000001111</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="co">--     0101110100101110</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="co">-- .&amp;. 0000000000001111</span></a>
<a class="sourceLine" id="cb24-3" title="3"><span class="co">-----------------------</span></a>
<a class="sourceLine" id="cb24-4" title="4"><span class="co">--     0000000000001110</span></a>
<a class="sourceLine" id="cb24-5" title="5"></a>
<a class="sourceLine" id="cb24-6" title="6">fragment <span class="ot">=</span> <span class="fu">fromIntegral</span> h <span class="op">.&amp;.</span> subkeyMask</a>
<a class="sourceLine" id="cb24-7" title="7"></a>
<a class="sourceLine" id="cb24-8" title="8">fragment</a></code></pre></div>
<pre><code>0000000000001110</code></pre>
<p>Then we interpret that fragment as a number:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="dt">Binary</span> position <span class="ot">=</span> fragment</a>
<a class="sourceLine" id="cb26-2" title="2"></a>
<a class="sourceLine" id="cb26-3" title="3">position</a></code></pre></div>
<pre><code>14</code></pre>
<p>Finally, we set that bit and we have our bitmap:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="ot">someBitmap ::</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb28-2" title="2">someBitmap <span class="ot">=</span> <span class="dt">Binary</span> <span class="op">$</span> bit <span class="op">$</span> <span class="fu">fromIntegral</span> position</a>
<a class="sourceLine" id="cb28-3" title="3"></a>
<a class="sourceLine" id="cb28-4" title="4">someBitmap</a></code></pre></div>
<pre><code>0100000000000000</code></pre>
<p>We’re going to be doing this a lot, so I’ll define this as <code>bitMask_</code>. The extra <code>_</code> is because it isn’t quite right for the same reason as <code>insert_</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="ot">bitMask_ ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb30-2" title="2">bitMask_ hash <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb30-3" title="3">    fragment <span class="ot">=</span> <span class="fu">fromIntegral</span> hash <span class="op">.&amp;.</span> subkeyMask</a>
<a class="sourceLine" id="cb30-4" title="4">    <span class="dt">Binary</span> position <span class="ot">=</span> fragment</a>
<a class="sourceLine" id="cb30-5" title="5">    <span class="kw">in</span> <span class="dt">Binary</span> (bit (<span class="fu">fromIntegral</span> position))</a></code></pre></div>
<p>Let’s look at the <code>Many</code> case. If we try inserting into a node where the bit in the bitmap corresponding to the mask is <code>0</code>, this means that there is an empty slot in the vector. We can insert a leaf node into this slot and set the corresponding bit in the bitmap to <code>1</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1">insert_ hash key value (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb31-2" title="2">    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb31-3" title="3">        leaf <span class="ot">=</span> <span class="dt">Leaf</span> (hash key) key value</a>
<a class="sourceLine" id="cb31-4" title="4">        vector&#39; <span class="ot">=</span> insertAt vector <span class="fu">index</span> leaf</a>
<a class="sourceLine" id="cb31-5" title="5">        bitmap&#39; <span class="ot">=</span> bitmap <span class="op">.|.</span> mask</a>
<a class="sourceLine" id="cb31-6" title="6">        <span class="kw">in</span> <span class="dt">Many</span> bitmap&#39; vector&#39;</a>
<a class="sourceLine" id="cb31-7" title="7">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-8" title="8">        mask <span class="ot">=</span> bitMask_ hash</a>
<a class="sourceLine" id="cb31-9" title="9">        <span class="fu">index</span> <span class="ot">=</span> <span class="fu">undefined</span></a></code></pre></div>
<h4 id="mask-indexing">Mask Indexing</h4>
<p>What <code>index</code> do we use? This is where <code>popCount</code> makes an appearance. Let’s demonstrate by inserting <code>("10", 2)</code> into our example. First we get the mask corresponding to <code>hash "10"</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1">mask <span class="ot">=</span> bitMask_ (hash <span class="st">&quot;10&quot;</span>)</a>
<a class="sourceLine" id="cb32-2" title="2"></a>
<a class="sourceLine" id="cb32-3" title="3">mask</a></code></pre></div>
<pre><code>0000010000000000</code></pre>
<p>Next we want to find the number of lower bits that have been set. We use <code>mask - 1</code> as a mask:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1">mask <span class="op">-</span> <span class="dv">1</span></a></code></pre></div>
<pre><code>0000001111111111</code></pre>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="co">--     0100000000000000</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="co">-- .&amp;. 0000001111111111</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="co">-----------------------</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="co">--     0000000000000000</span></a>
<a class="sourceLine" id="cb36-5" title="5"></a>
<a class="sourceLine" id="cb36-6" title="6">masked <span class="ot">=</span> someBitmap <span class="op">.&amp;.</span> (mask <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb36-7" title="7"></a>
<a class="sourceLine" id="cb36-8" title="8">masked</a></code></pre></div>
<pre><code>0000000000000000</code></pre>
<p>Then we count the number of bits set with <code>popCount</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="fu">index</span> <span class="ot">=</span> popCount masked</a>
<a class="sourceLine" id="cb38-2" title="2"></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="fu">index</span></a></code></pre></div>
<pre><code>0</code></pre>
<p>And this is the index we need to insert at! We’ll call this <code>maskIndex</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1"><span class="ot">maskIndex ::</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb40-2" title="2">maskIndex bitmap mask <span class="ot">=</span> popCount (bitmap <span class="op">.&amp;.</span> (mask <span class="op">-</span> <span class="dv">1</span>))</a></code></pre></div>
<p>The final case is where the bit in the bitmap is already set. We need to recursively update the HAMT at the corresponding index:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" title="1">insert_ hash key value (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb41-2" title="2">    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb41-3" title="3">        subtree&#39; <span class="ot">=</span> insert_ hash key value (vector <span class="op">!</span> <span class="fu">index</span>) <span class="co">-- WRONG!</span></a>
<a class="sourceLine" id="cb41-4" title="4">        vector&#39; <span class="ot">=</span> updateAt vector <span class="fu">index</span> subtree&#39;</a>
<a class="sourceLine" id="cb41-5" title="5">        <span class="kw">in</span> <span class="dt">Many</span> bitmap vector&#39;</a>
<a class="sourceLine" id="cb41-6" title="6">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-7" title="7">        mask <span class="ot">=</span> bitMask_ hash</a>
<a class="sourceLine" id="cb41-8" title="8">        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>But this definition is wrong, because instead of carving off the last <span class="math inline"><em>n</em></span> bits of <code>hash</code>, we want to recursively carve off the next <span class="math inline"><em>n</em></span> bits!</p>
<h4 id="shifting">Shifting</h4>
<p>This is what’s missing from our definition, a <code>shift</code> parameter corresponding to how far up the <code>hash</code> we’re looking. This is why we defined <code>Shift</code> above. Taking this extra parameter into account, our bit manipulation functions now become:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1"><span class="ot">subkeyMask ::</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb42-2" title="2">subkeyMask <span class="ot">=</span> (bit bitsPerSubkey) <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb42-3" title="3"></a>
<a class="sourceLine" id="cb42-4" title="4"><span class="ot">maskIndex ::</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb42-5" title="5">maskIndex bitmap mask <span class="ot">=</span> popCount (bitmap <span class="op">.&amp;.</span> (mask <span class="op">-</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb42-6" title="6"></a>
<a class="sourceLine" id="cb42-7" title="7"><span class="ot">subkey ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb42-8" title="8">subkey hash shift <span class="ot">=</span> <span class="fu">fromIntegral</span> <span class="op">$</span> (<span class="fu">fromIntegral</span> <span class="op">$</span> shiftR hash shift) <span class="op">.&amp;.</span> subkeyMask</a>
<a class="sourceLine" id="cb42-9" title="9"></a>
<a class="sourceLine" id="cb42-10" title="10"><span class="ot">bitMask ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span></a>
<a class="sourceLine" id="cb42-11" title="11">bitMask hash shift <span class="ot">=</span> bit (subkey hash shift)</a></code></pre></div>
<p>We plumb through this <code>shift</code> parameter, only modifying it in the final case, to give us the correct definitions of <code>insert'</code> and <code>insert</code>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1"><span class="ot">insert ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb43-2" title="2">insert key value hamt <span class="ot">=</span> insert&#39; <span class="dv">0</span> (hash key) key value hamt</a>
<a class="sourceLine" id="cb43-3" title="3"></a>
<a class="sourceLine" id="cb43-4" title="4"><span class="ot">insert&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb43-5" title="5">insert&#39; shift hash key value <span class="dt">None</span> <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</a>
<a class="sourceLine" id="cb43-6" title="6"></a>
<a class="sourceLine" id="cb43-7" title="7">insert&#39; shift hash key value leaf<span class="op">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb43-8" title="8">    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</a>
<a class="sourceLine" id="cb43-9" title="9">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> insert&#39; shift hash key value (<span class="dt">Many</span> (bitMask leafHash shift) (singleton leaf))</a>
<a class="sourceLine" id="cb43-10" title="10"></a>
<a class="sourceLine" id="cb43-11" title="11">insert&#39; shift hash key value (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb43-12" title="12">    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb43-13" title="13">        leaf <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</a>
<a class="sourceLine" id="cb43-14" title="14">        vector&#39; <span class="ot">=</span> insertAt vector <span class="fu">index</span> leaf</a>
<a class="sourceLine" id="cb43-15" title="15">        bitmap&#39; <span class="ot">=</span> bitmap <span class="op">.|.</span> mask</a>
<a class="sourceLine" id="cb43-16" title="16">        <span class="kw">in</span> <span class="dt">Many</span> bitmap&#39; vector&#39;</a>
<a class="sourceLine" id="cb43-17" title="17">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb43-18" title="18">        subtree <span class="ot">=</span> vector <span class="op">!</span> <span class="fu">index</span></a>
<a class="sourceLine" id="cb43-19" title="19">        subtree&#39; <span class="ot">=</span> insert&#39; (shift<span class="op">+</span>bitsPerSubkey) hash key value subtree</a>
<a class="sourceLine" id="cb43-20" title="20">        vector&#39; <span class="ot">=</span> updateAt vector <span class="fu">index</span> subtree&#39;</a>
<a class="sourceLine" id="cb43-21" title="21">        <span class="kw">in</span> <span class="dt">Many</span> bitmap vector&#39;</a>
<a class="sourceLine" id="cb43-22" title="22">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-23" title="23">        mask <span class="ot">=</span> bitMask hash shift</a>
<a class="sourceLine" id="cb43-24" title="24">        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>Now we can construct HAMTs and inspect them! I’ll define a <code>fromList</code> function and use <code>pPrint</code> from <code>pretty-show</code> to highlight the tree structure:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1"><span class="ot">fromList ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> [(key, value)] <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb44-2" title="2">fromList <span class="ot">=</span> <span class="fu">foldr</span> (<span class="fu">uncurry</span> insert) empty</a>
<a class="sourceLine" id="cb44-3" title="3"></a>
<a class="sourceLine" id="cb44-4" title="4">example <span class="ot">=</span> fromList [(<span class="st">&quot;1&quot;</span>, <span class="dv">1</span>), (<span class="st">&quot;10&quot;</span>, <span class="dv">2</span>), (<span class="st">&quot;100&quot;</span>, <span class="dv">3</span>), (<span class="st">&quot;1000&quot;</span>, <span class="dv">4</span>)]</a>
<a class="sourceLine" id="cb44-5" title="5"></a>
<a class="sourceLine" id="cb44-6" title="6">pPrint example</a></code></pre></div>
<pre><code>Many
  0100010000000000
  [ Many
      0000000100100000
      [ Leaf 00100000011101101010111101011010 &quot;10&quot; 2
      , Leaf 10001010111100101011011010001010 &quot;1000&quot; 4
      ]
  , Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<h3 id="lookup">Lookup</h3>
<p>Compared to <code>insert</code>, <code>lookup</code> is a walk in the park. It’s implemented along the same lines as <code>insert</code>:</p>
<ul>
<li>on <code>None</code> nodes, it fails</li>
<li>on <code>Leaf</code> nodes, it succeeds if the hashes match</li>
<li>on <code>Many</code> nodes, it fails if the bit isn’t set, and recurses into the child node otherwise</li>
</ul>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1"><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">Maybe</span> value</a>
<a class="sourceLine" id="cb46-2" title="2"><span class="fu">lookup</span> key hamt <span class="ot">=</span> lookup&#39; <span class="dv">0</span> (hash key) hamt</a>
<a class="sourceLine" id="cb46-3" title="3"></a>
<a class="sourceLine" id="cb46-4" title="4"><span class="ot">lookup&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">Maybe</span> value</a>
<a class="sourceLine" id="cb46-5" title="5">lookup&#39; shift hash <span class="dt">None</span> <span class="ot">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb46-6" title="6"></a>
<a class="sourceLine" id="cb46-7" title="7">lookup&#39; shift hash (<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb46-8" title="8">    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">Just</span> leafValue</a>
<a class="sourceLine" id="cb46-9" title="9">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb46-10" title="10"></a>
<a class="sourceLine" id="cb46-11" title="11">lookup&#39; shift hash (<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb46-12" title="12">    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb46-13" title="13">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> lookup&#39; (shift<span class="op">+</span>bitsPerSubkey) hash (vector <span class="op">!</span> <span class="fu">index</span>)</a>
<a class="sourceLine" id="cb46-14" title="14">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-15" title="15">        mask <span class="ot">=</span> bitMask hash shift</a>
<a class="sourceLine" id="cb46-16" title="16">        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>Let’s quickly confirm that it works.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1"><span class="fu">lookup</span> <span class="st">&quot;100&quot;</span> example</a></code></pre></div>
<pre><code>Just 3</code></pre>
<h4 id="memoising-fibonacci">Memoising Fibonacci</h4>
<p>We now have enough of an API to use this as a hashtable! Let’s use it to memoise the calculation of the Fibonacci sequence. The naive implementation does a lot of unnecessary recomputation:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" title="1"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb49-2" title="2">fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb49-3" title="3">fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb49-4" title="4">fib n <span class="ot">=</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb49-5" title="5"></a>
<a class="sourceLine" id="cb49-6" title="6">timeIt <span class="op">$</span> <span class="fu">print</span> <span class="op">$</span> fib <span class="dv">30</span></a></code></pre></div>
<pre><code>1346269
CPU time:   1.31s</code></pre>
<p>We can memoise it by storing previously calculated results and using them if they are available:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" title="1"><span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-2" title="2">    hash int <span class="ot">=</span> <span class="dt">Binary</span> (<span class="fu">fromIntegral</span> int)</a>
<a class="sourceLine" id="cb51-3" title="3"></a>
<a class="sourceLine" id="cb51-4" title="4"><span class="ot">fib&#39; ::</span> <span class="dt">HAMT</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">HAMT</span> <span class="dt">Int</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb51-5" title="5">fib&#39; table <span class="dv">0</span> <span class="ot">=</span> (<span class="dv">1</span>, insert <span class="dv">0</span> <span class="dv">1</span> table)</a>
<a class="sourceLine" id="cb51-6" title="6">fib&#39; table <span class="dv">1</span> <span class="ot">=</span> (<span class="dv">1</span>, insert <span class="dv">1</span> <span class="dv">1</span> table)</a>
<a class="sourceLine" id="cb51-7" title="7">fib&#39; table n <span class="ot">=</span> <span class="kw">case</span> <span class="fu">lookup</span> n table <span class="kw">of</span></a>
<a class="sourceLine" id="cb51-8" title="8">    <span class="dt">Just</span> i <span class="ot">-&gt;</span> (i, table)</a>
<a class="sourceLine" id="cb51-9" title="9">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb51-10" title="10">        (i1, table&#39;)  <span class="ot">=</span> fib&#39; table  (n<span class="op">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb51-11" title="11">        (i2, table&#39;&#39;) <span class="ot">=</span> fib&#39; table&#39; (n<span class="op">-</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb51-12" title="12">        <span class="kw">in</span> (i1 <span class="op">+</span> i2, insert n (i1 <span class="op">+</span> i2) table&#39;&#39;)</a>
<a class="sourceLine" id="cb51-13" title="13"></a>
<a class="sourceLine" id="cb51-14" title="14"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb51-15" title="15">fib n <span class="ot">=</span> <span class="fu">fst</span> <span class="op">$</span> fib&#39; empty n</a>
<a class="sourceLine" id="cb51-16" title="16"></a>
<a class="sourceLine" id="cb51-17" title="17">timeIt <span class="op">$</span> <span class="fu">print</span> <span class="op">$</span> fib <span class="dv">30</span></a></code></pre></div>
<pre><code>1346269
CPU time:   0.00s</code></pre>
<h3 id="delete">Delete</h3>
<p>Finally we come to <code>delete</code>, which is only a little more complex than <code>lookup</code>. It needs to make sure that no <code>Many</code> node has a child <code>None</code> node, so if a <code>None</code> node:</p>
<ul>
<li>is an only child, it will replace the parent node</li>
<li>has any sibling nodes, it will be removed from the parent node’s bitmap and vector</li>
</ul>
<p><code>Leaf</code> nodes similarly replace their parents if they are the only child.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" title="1"><span class="ot">delete ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb53-2" title="2">delete key hamt <span class="ot">=</span> delete&#39; <span class="dv">0</span> (hash key) hamt</a>
<a class="sourceLine" id="cb53-3" title="3"></a>
<a class="sourceLine" id="cb53-4" title="4"><span class="ot">delete&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</a>
<a class="sourceLine" id="cb53-5" title="5">delete&#39; shift hash <span class="dt">None</span> <span class="ot">=</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb53-6" title="6"></a>
<a class="sourceLine" id="cb53-7" title="7">delete&#39; shift hash leaf<span class="op">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</a>
<a class="sourceLine" id="cb53-8" title="8">    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb53-9" title="9">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> leaf</a>
<a class="sourceLine" id="cb53-10" title="10"></a>
<a class="sourceLine" id="cb53-11" title="11">delete&#39; shift hash many<span class="op">@</span>(<span class="dt">Many</span> bitmap vector)</a>
<a class="sourceLine" id="cb53-12" title="12">    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> many</a>
<a class="sourceLine" id="cb53-13" title="13">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb53-14" title="14">        subtree <span class="ot">=</span> vector <span class="op">!</span> <span class="fu">index</span></a>
<a class="sourceLine" id="cb53-15" title="15">        subtree&#39; <span class="ot">=</span> delete&#39; (shift<span class="op">+</span>bitsPerSubkey) hash subtree</a>
<a class="sourceLine" id="cb53-16" title="16">        <span class="kw">in</span> <span class="kw">case</span> subtree&#39; <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-17" title="17">            <span class="dt">None</span> <span class="ot">-&gt;</span> <span class="kw">if</span> <span class="fu">length</span> vector <span class="op">==</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb53-18" title="18">                <span class="kw">then</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb53-19" title="19">                <span class="kw">else</span> <span class="dt">Many</span> (bitmap <span class="op">.&amp;.</span> complement mask) (deleteAt vector <span class="fu">index</span>)</a>
<a class="sourceLine" id="cb53-20" title="20">            <span class="dt">Leaf</span>{} <span class="ot">-&gt;</span> <span class="kw">if</span> <span class="fu">length</span> vector <span class="op">==</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb53-21" title="21">                <span class="kw">then</span> subtree&#39;</a>
<a class="sourceLine" id="cb53-22" title="22">                <span class="kw">else</span>  <span class="dt">Many</span> bitmap (updateAt vector <span class="fu">index</span> subtree&#39;)</a>
<a class="sourceLine" id="cb53-23" title="23">            <span class="dt">Many</span>{} <span class="ot">-&gt;</span> <span class="dt">Many</span> bitmap (updateAt vector <span class="fu">index</span> subtree&#39;)</a>
<a class="sourceLine" id="cb53-24" title="24">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb53-25" title="25">        mask <span class="ot">=</span> bitMask hash shift</a>
<a class="sourceLine" id="cb53-26" title="26">        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</a></code></pre></div>
<p>Let’s see this in action.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" title="1">pPrint <span class="op">$</span> delete <span class="st">&quot;1000&quot;</span> example</a></code></pre></div>
<pre><code>Many
  0100010000000000
  [ Many
      0000000000100000 [ Leaf 00100000011101101010111101011010 &quot;10&quot; 2 ]
  , Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<p>It’s possible to have a situation where we have a <code>Many</code> node with only one child, because our replacement behaviour checks the length of the vector before any elements are removed from it. However, removing the last leaf will correctly delete the parent node.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" title="1">pPrint <span class="op">$</span> delete <span class="st">&quot;10&quot;</span> <span class="op">$</span> delete <span class="st">&quot;1000&quot;</span> example</a></code></pre></div>
<pre><code>Many
  0100000000000000
  [ Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<p>And we’re done! I hope you understand HAMTs better than when you started reading this.</p>
<p>If you want to use this for something other than educational purposes, I would recommend adding logic to deal with hash collisions, which I intentionally omitted. There’s also some low-hanging fruit in terms of performance optimisations. The first thing that comes to mind is an additional <code>Full</code> constructor for the case where all bits in the bitmap are set, and the next thing is the use of unsafe vector functions that omit bounds checking.</p>
<p>Thanks to <a href="https://twitter.com/evanborden">Evan Borden</a>, <a href="https://twitter.com/candeira">Javier Candeira</a>, <a href="https://hypirion.com/">Jean Niklas L’orange</a>, <a href="http://mjhopkins.github.io/">Mark Hopkins</a>, and <a href="https://teh.id.au/">Tim Humphries</a> for comments and feedback.</p>
]]></summary>
</entry>
<entry>
    <title>Trees That Shrink</title>
    <link href="https://vaibhavsagar.com/blog/2018/06/19/trees-that-shrink/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/06/19/trees-that-shrink/index.html</id>
    <published>2018-06-19T00:00:00Z</published>
    <updated>2018-06-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 19 June 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p><em>This blog post is also available as an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/trees-that-shrink/TreesThatShrink.ipynb">IHaskell notebook</a>.</em></p>
<p>I read <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf">this paper</a> a while ago and people seemed pretty excited about it, although I couldn’t see why. Fortunately, someone posed me an interesting problem recently and in the process of tackling it I think I understand now.</p>
<p>Suppose we have a simple algebraic data type representing the lambda calculus with <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a>, which are a way of avoiding the messy problem of variable names:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="ot">=</span> <span class="dt">Lit</span> a</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="op">|</span> <span class="dt">Var</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="op">|</span> <span class="dt">Abs</span> (<span class="dt">Expr</span> a)</a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="op">|</span> <span class="dt">App</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)</a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>So far so good! Now we want to have let bindings in this language, and we’ve decided that we want named variables as well while we’re at it because de Bruijn indices are not so much fun to work with. We dutifully define another data type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">Expr&#39;</span> a</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="ot">=</span> <span class="dt">Lit&#39;</span> a</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="op">|</span> <span class="dt">Var&#39;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="op">|</span> <span class="dt">Abs&#39;</span> (<span class="dt">Expr&#39;</span> a)</a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="op">|</span> <span class="dt">App&#39;</span> (<span class="dt">Expr&#39;</span> a) (<span class="dt">Expr&#39;</span> a)</a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="op">|</span> <span class="dt">Let&#39;</span> <span class="dt">String</span> (<span class="dt">Expr&#39;</span> a) (<span class="dt">Expr&#39;</span> a)</a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>Let bindings can be easily desugared into lambda abstractions as follows:</p>
<pre><code>let &lt;n&gt; = &lt;x&gt; in &lt;y&gt; &lt;=&gt; (\n -&gt; y) x</code></pre>
<p>which will help us to write a simpler evaluator. However, we’d also like to make sure the desugaring has been implemented correctly, perhaps by converting to some intermediate state where both the name and the correct de Bruijn index coexist peacefully. We have a couple of options, none of which are great:</p>
<ol type="1">
<li>Define a third data type and then write an indexing pass that converts <code>Var String</code> to <code>Var (String, Int)</code> and then a desugaring pass that converts that to <code>Expr a</code>.</li>
<li>Work entirely within the bigger data type, forget about indexing, and throw errors whenever a <code>Let</code> is encountered after a desugaring pass.</li>
<li>Combine the desugaring and indexing passes into one, and forget about keeping track of the desugaring.</li>
</ol>
<p>Let’s implement the third:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="ot">desugarAndAnonymise ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr&#39;</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</a>
<a class="sourceLine" id="cb4-6" title="6">desugarAndAnonymise env expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="dt">Lit&#39;</span> a <span class="ot">-&gt;</span> <span class="dt">Lit</span> a</a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="dt">Var&#39;</span> name <span class="ot">-&gt;</span> <span class="dt">Var</span> (env <span class="op">Map.!</span> name)</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="dt">Abs&#39;</span> expr&#39; <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb4-10" title="10">        env&#39;  <span class="ot">=</span> Map.map <span class="fu">succ</span> env</a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="kw">in</span> <span class="dt">Abs</span> (desugarAndAnonymise env&#39; expr&#39;)</a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="dt">App&#39;</span> f x <span class="ot">-&gt;</span> <span class="dt">App</span> (desugarAndAnonymise env f) (desugarAndAnonymise env x)</a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="dt">Let&#39;</span> n v expr&#39; <span class="ot">-&gt;</span> desugarAndAnonymise env (<span class="dt">App&#39;</span> (<span class="dt">Abs&#39;</span> expr&#39;) v)</a></code></pre></div>
<p>That wasn’t a lot of fun to write, I have no idea if I did the conversion from names to indices correctly, and there’s no easy way to check if I did.</p>
<p>These problems are (barely) manageable in this case, but what if we want to add more syntax sugar or share this data type with other libraries that have different use cases? We’d either have to write variations on a theme over and over again or say goodbye to type safety. It also becomes harder and harder to decompose our functions into smaller ones that only do one thing. There has to be a better way!</p>
<p>This is the subject of <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf">Trees that Grow</a> by Shayan Najd and Simon Peyton Jones. They noticed the need for this approach when looking at GHC’s abstract syntax tree type but the idiom is generally applicable.</p>
<p>The first insight is that defining different data types for each use case is the wrong approach. Conceptually all these data types are the same type, just with different annotations or decoration, and we should be able to define the base data type with enough extensibility to accommodate all the other use cases.</p>
<p>The second insight is that we can use some of GHC’s fancier features to ease the pain of working with this ridiculously extensible data type, such as type families and pattern synonyms.</p>
<p>The third insight is that this can be made to work with other language features, such as generalised abstract data types and existentials! We won’t use this here, but it’s great to know that it’s possible.</p>
<p>Let’s see how we can use it to solve our problem. The first thing to do is turn on some language extensions, as with anything moderately fun in Haskell:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ot">{-# LANGUAGE PatternSynonyms   #-}</span></a></code></pre></div>
<p>The next steps are:</p>
<ol type="1">
<li>Add a type parameter to the data type declaration.</li>
<li>Add a field to each constructor with a new data type that uses this parameter (and any others).</li>
<li>Add an extra constructor to enable extending this data type, also with a new data type as in step 2.</li>
<li>Define type families for each of the new data types you declared in steps 2 and 3.</li>
</ol>
<p>And we’re done! This is what that looks like for our example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">ExpX</span> i a</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="ot">=</span> <span class="dt">LitX</span> (<span class="dt">XLit</span> i a) a</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="op">|</span> <span class="dt">VarX</span> (<span class="dt">XVar</span> i a)</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="op">|</span> <span class="dt">AbsX</span> (<span class="dt">XAbs</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="op">|</span> <span class="dt">AppX</span> (<span class="dt">XApp</span> i a) (<span class="dt">ExpX</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="op">|</span> <span class="dt">ExpX</span> (<span class="dt">XExp</span> i a)</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XLit</span> i a</a>
<a class="sourceLine" id="cb6-9" title="9"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XVar</span> i a</a>
<a class="sourceLine" id="cb6-10" title="10"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XAbs</span> i a</a>
<a class="sourceLine" id="cb6-11" title="11"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XApp</span> i a</a>
<a class="sourceLine" id="cb6-12" title="12"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XExp</span> i a</a></code></pre></div>
<p>The next thing to do is to reconstruct our original data type with no extensions. To do this we’ll need to use the <a href="http://hackage.haskell.org/package/base/docs/Data-Void.html"><code>Data.Void</code></a> package:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ot">void ::</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb7-4" title="4">void <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Attempt to evaluate void&quot;</span></a></code></pre></div>
<p>Now we can define <code>ExpUD</code> (UD for “undecorated”) using <code>Int</code> for our <code>Var</code> like we originally wanted and <code>Void</code> for all other extension points. It might get frustrating to construct and work with these values by hand, so we can use pattern synonyms to ease this pain.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">type</span> <span class="dt">ExpUD</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">UD</span> a</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">data</span> <span class="dt">UD</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="kw">pattern</span> <span class="dt">LitUD</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-10" title="10"><span class="kw">pattern</span> <span class="dt">LitUD</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</a>
<a class="sourceLine" id="cb8-11" title="11">    <span class="kw">where</span> <span class="dt">LitUD</span> a <span class="ot">=</span> <span class="dt">LitX</span> void a</a>
<a class="sourceLine" id="cb8-12" title="12"><span class="kw">pattern</span> <span class="dt">VarUD</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-13" title="13"><span class="kw">pattern</span> <span class="dt">VarUD</span> i <span class="ot">&lt;-</span> <span class="dt">VarX</span> i</a>
<a class="sourceLine" id="cb8-14" title="14">    <span class="kw">where</span> <span class="dt">VarUD</span> i <span class="ot">=</span> <span class="dt">VarX</span> i</a>
<a class="sourceLine" id="cb8-15" title="15"><span class="kw">pattern</span> <span class="dt">AbsUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-16" title="16"><span class="kw">pattern</span> <span class="dt">AbsUD</span> a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> _ a</a>
<a class="sourceLine" id="cb8-17" title="17">    <span class="kw">where</span> <span class="dt">AbsUD</span> a <span class="ot">=</span> <span class="dt">AbsX</span> void a</a>
<a class="sourceLine" id="cb8-18" title="18"><span class="kw">pattern</span> <span class="dt">AppUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb8-19" title="19"><span class="kw">pattern</span> <span class="dt">AppUD</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</a>
<a class="sourceLine" id="cb8-20" title="20">    <span class="kw">where</span> <span class="dt">AppUD</span> f a <span class="ot">=</span> <span class="dt">AppX</span> void f a</a></code></pre></div>
<p>This is unfortunately a bit boilerplate-y, but now we can define that intermediate data type that uses named variables as well as de Bruijn indices! As a bonus, we can now have named parameters to lambdas, which would not have been possible with the approach we tried to use above.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">type</span> <span class="dt">ExpAnn</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Ann</span> a</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">data</span> <span class="dt">Ann</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Ann</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb9-5" title="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb9-7" title="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9"><span class="kw">pattern</span> <span class="dt">LitAnn</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-10" title="10"><span class="kw">pattern</span> <span class="dt">LitAnn</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</a>
<a class="sourceLine" id="cb9-11" title="11">    <span class="kw">where</span> <span class="dt">LitAnn</span> a <span class="ot">=</span> <span class="dt">LitX</span> void a</a>
<a class="sourceLine" id="cb9-12" title="12"><span class="kw">pattern</span> <span class="dt">VarAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-13" title="13"><span class="kw">pattern</span> <span class="dt">VarAnn</span> s i <span class="ot">&lt;-</span> <span class="dt">VarX</span> (s,i)</a>
<a class="sourceLine" id="cb9-14" title="14">    <span class="kw">where</span> <span class="dt">VarAnn</span> s i <span class="ot">=</span> <span class="dt">VarX</span> (s, i)</a>
<a class="sourceLine" id="cb9-15" title="15"><span class="kw">pattern</span> <span class="dt">AbsAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-16" title="16"><span class="kw">pattern</span> <span class="dt">AbsAnn</span> s a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb9-17" title="17">    <span class="kw">where</span> <span class="dt">AbsAnn</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb9-18" title="18"><span class="kw">pattern</span> <span class="dt">AppAnn</span><span class="ot"> ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb9-19" title="19"><span class="kw">pattern</span> <span class="dt">AppAnn</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</a>
<a class="sourceLine" id="cb9-20" title="20">    <span class="kw">where</span> <span class="dt">AppAnn</span> f a <span class="ot">=</span> <span class="dt">AppX</span> void f a</a></code></pre></div>
<p>Now for my favourite part, where we add let bindings! We achieve this by using a tuple to represent <code>let &lt;name&gt; = &lt;expr&gt; in &lt;expr&gt;</code> as <code>(&lt;name&gt;, &lt;expr&gt;, &lt;expr&gt;)</code>, and we use named variables and parameters in this representation.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">type</span> <span class="dt">ExpLet</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Let</span> a</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">data</span> <span class="dt">Let</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Let</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">ExpLet</span> a, <span class="dt">ExpLet</span> a)</a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="kw">pattern</span> <span class="dt">LitLet</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-10" title="10"><span class="kw">pattern</span> <span class="dt">LitLet</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</a>
<a class="sourceLine" id="cb10-11" title="11">    <span class="kw">where</span> <span class="dt">LitLet</span> a <span class="ot">=</span> <span class="dt">LitX</span> void a</a>
<a class="sourceLine" id="cb10-12" title="12"><span class="kw">pattern</span> <span class="dt">VarLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-13" title="13"><span class="kw">pattern</span> <span class="dt">VarLet</span> s <span class="ot">&lt;-</span> <span class="dt">VarX</span> s</a>
<a class="sourceLine" id="cb10-14" title="14">    <span class="kw">where</span> <span class="dt">VarLet</span> s <span class="ot">=</span> <span class="dt">VarX</span> s</a>
<a class="sourceLine" id="cb10-15" title="15"><span class="kw">pattern</span> <span class="dt">AbsLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-16" title="16"><span class="kw">pattern</span> <span class="dt">AbsLet</span> s a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb10-17" title="17">    <span class="kw">where</span> <span class="dt">AbsLet</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb10-18" title="18"><span class="kw">pattern</span> <span class="dt">AppLet</span><span class="ot"> ::</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb10-19" title="19"><span class="kw">pattern</span> <span class="dt">AppLet</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</a>
<a class="sourceLine" id="cb10-20" title="20">    <span class="kw">where</span> <span class="dt">AppLet</span> f a <span class="ot">=</span> <span class="dt">AppX</span> void f a</a>
<a class="sourceLine" id="cb10-21" title="21"><span class="kw">pattern</span> <span class="dt">LetLet</span> n v e <span class="ot">&lt;-</span> <span class="dt">ExpX</span> (n,v,e)</a></code></pre></div>
<p>Now instead of writing a single giant pass, we can write smaller ones!</p>
<p>We can write a desugarer that preserves names and rewrites our let bindings as follows:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">desugar ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb11-2" title="2">desugar env expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="dt">LitLet</span> a <span class="ot">-&gt;</span> <span class="dt">LitAnn</span> a</a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="dt">VarLet</span> name <span class="ot">-&gt;</span> <span class="dt">VarAnn</span> name (env <span class="op">Map.!</span> name)</a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="dt">AbsLet</span> name expr&#39; <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb11-6" title="6">        env&#39;  <span class="ot">=</span> Map.map <span class="fu">succ</span> env</a>
<a class="sourceLine" id="cb11-7" title="7">        env&#39;&#39; <span class="ot">=</span> Map.insert name <span class="dv">0</span> env&#39;</a>
<a class="sourceLine" id="cb11-8" title="8">        <span class="kw">in</span> <span class="dt">AbsAnn</span> name (desugar env&#39;&#39; expr&#39;)</a>
<a class="sourceLine" id="cb11-9" title="9">    <span class="dt">AppLet</span> f x <span class="ot">-&gt;</span> <span class="dt">AppAnn</span> (desugar env f) (desugar env x)</a>
<a class="sourceLine" id="cb11-10" title="10">    <span class="dt">LetLet</span> n v expr&#39; <span class="ot">-&gt;</span> desugar env (<span class="dt">AppLet</span> (<span class="dt">AbsLet</span> n expr&#39;) v)</a></code></pre></div>
<p>We can also write an anonymiser that throws the names away:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">anonymise ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb12-2" title="2">anonymise expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="dt">LitAnn</span> a <span class="ot">-&gt;</span> <span class="dt">LitUD</span> a</a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="dt">VarAnn</span> _ i <span class="ot">-&gt;</span> <span class="dt">VarUD</span> i</a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="dt">AbsAnn</span> _ e <span class="ot">-&gt;</span> <span class="dt">AbsUD</span> (anonymise e)</a>
<a class="sourceLine" id="cb12-6" title="6">    <span class="dt">AppAnn</span> f x <span class="ot">-&gt;</span> <span class="dt">AppUD</span> (anonymise f) (anonymise x)</a></code></pre></div>
<p>And finally an evaluator that operates on undecorated expressions:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">eval ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb13-2" title="2">eval env expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="dt">LitUD</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb13-4" title="4">    <span class="dt">VarUD</span> i <span class="ot">-&gt;</span> env <span class="op">!!</span> i</a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="dt">AbsUD</span> f <span class="ot">-&gt;</span> eval env f</a>
<a class="sourceLine" id="cb13-6" title="6">    <span class="dt">AppUD</span> f x <span class="ot">-&gt;</span> <span class="kw">let</span></a>
<a class="sourceLine" id="cb13-7" title="7">        x&#39; <span class="ot">=</span> eval env x</a>
<a class="sourceLine" id="cb13-8" title="8">        <span class="kw">in</span> eval (x&#39;<span class="op">:</span>env) f</a></code></pre></div>
<p>Let’s see it in action!</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">identity <span class="ot">=</span> <span class="dt">AbsLet</span> <span class="st">&quot;i&quot;</span> (<span class="dt">VarLet</span> <span class="st">&quot;i&quot;</span>)</a>
<a class="sourceLine" id="cb14-2" title="2">konst <span class="ot">=</span> (<span class="dt">AbsLet</span> <span class="st">&quot;x&quot;</span> (<span class="dt">AbsLet</span> <span class="st">&quot;y&quot;</span> (<span class="dt">VarLet</span> <span class="st">&quot;x&quot;</span>)))</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4">eval [] <span class="op">.</span> anonymise <span class="op">.</span> desugar Map.empty <span class="op">$</span> <span class="dt">AppLet</span> (<span class="dt">AppLet</span> konst (<span class="dt">LitLet</span> <span class="dv">1</span>)) (<span class="dt">LitLet</span> <span class="dv">2</span>)</a></code></pre></div>
<pre><code>2</code></pre>
<p>Awesome! We have composable compiler passes that are easier to write and to think about. Even with this small example, I hope the benefits are clear.</p>
<p>Edit: <a href="https://www.reddit.com/r/haskell/comments/8s75n3/trees_that_shrink/e0x8se2">Edward Kmett points out</a> that using <code>Void</code> makes this approach unnecessarily footgun-prone and suggests using strict fields and <code>()</code> instead. This allows for simpler pattern synonyms and comes with the additional benefit that we can disable constructors with <code>Void</code> so we can actually have trees that shrink:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">data</span> <span class="dt">ExpX</span> i a</a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="ot">=</span> <span class="dt">LitX</span> <span class="op">!</span>(<span class="dt">XLit</span> i a) a</a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="op">|</span> <span class="dt">VarX</span> <span class="op">!</span>(<span class="dt">XVar</span> i a)</a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="op">|</span> <span class="dt">AbsX</span> <span class="op">!</span>(<span class="dt">XAbs</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb16-5" title="5">    <span class="op">|</span> <span class="dt">AppX</span> <span class="op">!</span>(<span class="dt">XApp</span> i a) (<span class="dt">ExpX</span> i a) (<span class="dt">ExpX</span> i a)</a>
<a class="sourceLine" id="cb16-6" title="6">    <span class="op">|</span> <span class="dt">ExpX</span> <span class="op">!</span>(<span class="dt">XExp</span> i a)</a>
<a class="sourceLine" id="cb16-7" title="7"></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XLit</span> i a</a>
<a class="sourceLine" id="cb16-9" title="9"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XVar</span> i a</a>
<a class="sourceLine" id="cb16-10" title="10"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XAbs</span> i a</a>
<a class="sourceLine" id="cb16-11" title="11"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XApp</span> i a</a>
<a class="sourceLine" id="cb16-12" title="12"><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XExp</span> i a</a>
<a class="sourceLine" id="cb16-13" title="13"></a>
<a class="sourceLine" id="cb16-14" title="14"><span class="kw">type</span> <span class="dt">ExpUD</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">UD</span> a</a>
<a class="sourceLine" id="cb16-15" title="15"><span class="kw">data</span> <span class="dt">UD</span></a>
<a class="sourceLine" id="cb16-16" title="16"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">UD</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-17" title="17"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-18" title="18"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">UD</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-19" title="19"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">UD</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-20" title="20"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-21" title="21"></a>
<a class="sourceLine" id="cb16-22" title="22"><span class="kw">pattern</span> <span class="dt">LitUD</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-23" title="23"><span class="kw">pattern</span> <span class="dt">LitUD</span> a <span class="ot">=</span> <span class="dt">LitX</span> () a</a>
<a class="sourceLine" id="cb16-24" title="24"><span class="kw">pattern</span> <span class="dt">VarUD</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-25" title="25"><span class="kw">pattern</span> <span class="dt">VarUD</span> i <span class="ot">=</span> <span class="dt">VarX</span> i</a>
<a class="sourceLine" id="cb16-26" title="26"><span class="kw">pattern</span> <span class="dt">AbsUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-27" title="27"><span class="kw">pattern</span> <span class="dt">AbsUD</span> a <span class="ot">=</span> <span class="dt">AbsX</span> () a</a>
<a class="sourceLine" id="cb16-28" title="28"><span class="kw">pattern</span> <span class="dt">AppUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</a>
<a class="sourceLine" id="cb16-29" title="29"><span class="kw">pattern</span> <span class="dt">AppUD</span> f a <span class="ot">=</span> <span class="dt">AppX</span> () f a</a>
<a class="sourceLine" id="cb16-30" title="30"></a>
<a class="sourceLine" id="cb16-31" title="31"><span class="kw">type</span> <span class="dt">ExpAnn</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Ann</span> a</a>
<a class="sourceLine" id="cb16-32" title="32"><span class="kw">data</span> <span class="dt">Ann</span></a>
<a class="sourceLine" id="cb16-33" title="33"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Ann</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-34" title="34"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Ann</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb16-35" title="35"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb16-36" title="36"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Ann</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-37" title="37"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></a>
<a class="sourceLine" id="cb16-38" title="38"></a>
<a class="sourceLine" id="cb16-39" title="39"><span class="kw">pattern</span> <span class="dt">LitAnn</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-40" title="40"><span class="kw">pattern</span> <span class="dt">LitAnn</span> a <span class="ot">=</span> <span class="dt">LitX</span> () a</a>
<a class="sourceLine" id="cb16-41" title="41"><span class="kw">pattern</span> <span class="dt">VarAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-42" title="42"><span class="kw">pattern</span> <span class="dt">VarAnn</span> s i <span class="ot">=</span> <span class="dt">VarX</span> (s, i)</a>
<a class="sourceLine" id="cb16-43" title="43"><span class="kw">pattern</span> <span class="dt">AbsAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-44" title="44"><span class="kw">pattern</span> <span class="dt">AbsAnn</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb16-45" title="45"><span class="kw">pattern</span> <span class="dt">AppAnn</span><span class="ot"> ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</a>
<a class="sourceLine" id="cb16-46" title="46"><span class="kw">pattern</span> <span class="dt">AppAnn</span> f a <span class="ot">=</span> <span class="dt">AppX</span> () f a</a>
<a class="sourceLine" id="cb16-47" title="47"></a>
<a class="sourceLine" id="cb16-48" title="48"><span class="kw">type</span> <span class="dt">ExpLet</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Let</span> a</a>
<a class="sourceLine" id="cb16-49" title="49"><span class="kw">data</span> <span class="dt">Let</span></a>
<a class="sourceLine" id="cb16-50" title="50"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Let</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-51" title="51"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb16-52" title="52"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb16-53" title="53"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Let</span> a <span class="ot">=</span> ()</a>
<a class="sourceLine" id="cb16-54" title="54"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Let</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">ExpLet</span> a, <span class="dt">ExpLet</span> a)</a>
<a class="sourceLine" id="cb16-55" title="55"></a>
<a class="sourceLine" id="cb16-56" title="56"><span class="kw">pattern</span> <span class="dt">LitLet</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-57" title="57"><span class="kw">pattern</span> <span class="dt">LitLet</span> a <span class="ot">=</span> <span class="dt">LitX</span> () a</a>
<a class="sourceLine" id="cb16-58" title="58"><span class="kw">pattern</span> <span class="dt">VarLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-59" title="59"><span class="kw">pattern</span> <span class="dt">VarLet</span> s <span class="ot">=</span> <span class="dt">VarX</span> s</a>
<a class="sourceLine" id="cb16-60" title="60"><span class="kw">pattern</span> <span class="dt">AbsLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-61" title="61"><span class="kw">pattern</span> <span class="dt">AbsLet</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</a>
<a class="sourceLine" id="cb16-62" title="62"><span class="kw">pattern</span> <span class="dt">AppLet</span><span class="ot"> ::</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</a>
<a class="sourceLine" id="cb16-63" title="63"><span class="kw">pattern</span> <span class="dt">AppLet</span> f a <span class="ot">=</span> <span class="dt">AppX</span> () f a</a>
<a class="sourceLine" id="cb16-64" title="64"><span class="kw">pattern</span> <span class="dt">LetLet</span> n v e <span class="ot">&lt;-</span> <span class="dt">ExpX</span> (n,v,e)</a></code></pre></div>
<p>The definitions of <code>desugar</code>, <code>anonymise</code>, and <code>eval</code> are unchanged.</p>
<p>Thanks to <a href="http://andychu.net/">Andy Chu</a> and <a href="https://push.cx/">Peter Bhat Harkins</a> for comments and feedback.</p>
]]></summary>
</entry>
<entry>
    <title>Quick and Easy Nixpkgs Pinning</title>
    <link href="https://vaibhavsagar.com/blog/2018/05/27/quick-easy-nixpkgs-pinning/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/05/27/quick-easy-nixpkgs-pinning/index.html</id>
    <published>2018-05-27T00:00:00Z</published>
    <updated>2018-05-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on 27 May 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/nix/index.html">nix</a>
    
</div>

<p>I love Nix because it makes packaging and using software so easy. For example, here’s a first stab at an expression that makes a recent version of Pandoc available in a <code>nix-shell</code> (be warned, this will take a while the first time!):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {};</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="ex">haskellPackages</span> = pkgs.haskellPackages.override {</a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="ex">overrides</span> = self: super: {</a>
<a class="sourceLine" id="cb1-5" title="5">      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.2&quot;</span> {};</a>
<a class="sourceLine" id="cb1-6" title="6">      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.4.2&quot;</span> {};</a>
<a class="sourceLine" id="cb1-7" title="7">    };</a>
<a class="sourceLine" id="cb1-8" title="8">  };</a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {</a>
<a class="sourceLine" id="cb1-10" title="10">  <span class="ex">buildInputs</span> = [ haskellPackages.pandoc ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb1-11" title="11">} <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>If we save this to <code>default.nix</code> we can use it as follows (unless you’re reading this after the release of NixOS 18.09, more on that below):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1">$ <span class="ex">nix-shell</span> default.nix</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb2-3" title="3">[<span class="ex">nix-shell</span>]$ pandoc --version</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ex">pandoc</span> 2.2</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></a></code></pre></div>
<p>Pandoc is infamously large, so this will probably take a while the first time. Fortunately, Nix caches build artifacts and knows to provide the same output if the inputs are unchanged, so if we immediately try this again a second time it should be nearly instantaneous.</p>
<p>Barring an event like the garbage collection of the Nix store or a change in the expression above, we would like to never rebuild this package again.</p>
<p>Unfortunately, there is a serious flaw with this expression that prevents us from guaranteeing this.</p>
<p>The problem is not immediately obvious, and might only manifest days or weeks later, or when you upgrade NixOS to the next version. The issue is with the second line,</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span><span class="kw">;</span></a></code></pre></div>
<p>where we import the system-wide <code>nixpkgs</code>. If we later update this by running</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1">$ <span class="ex">nix-channel</span> --update</a></code></pre></div>
<p>and any of the transitive dependencies of our expression are updated, this will cause a rebuild because Nix will rightly detect that the inputs have changed.</p>
<p>This might be desirable in many cases, but for us it means a lot of waiting for no benefit. We can avoid this by pinning <code>nixpkgs</code> to a known-good commit. One way to do this is by setting the <code>NIX_PATH</code> environment variable, which is where Nix looks for the location of <code>nixpkgs</code>. We could do this as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1">$ <span class="va">NIX_PATH=</span>nixpkgs=<span class="ex">https</span>://github.com/NixOS/nixpkgs-channels/archive/2f6440eb09b7e6e3322720ac91ce7e2cdeb413f9.tar.gz nix-shell default.nix</a></code></pre></div>
<p>which takes advantage of the fact that Nix will transparently download a URL for <code>nixpkgs</code> instead of a filepath. This can quickly get tedious and is easy to forget though. Let’s pin <code>nixpkgs</code> directly in the expression:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="ex">inherit</span> (import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {}) <span class="ex">fetchFromGitHub</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="ex">nixpkgs</span> = fetchFromGitHub {</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="ex">owner</span>  = <span class="st">&quot;NixOS&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="ex">repo</span>   = <span class="st">&quot;nixpkgs-channels&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="fu">rev</span>    = <span class="st">&quot;2f6440eb09b7e6e3322720ac91ce7e2cdeb413f9&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="ex">sha256</span> = <span class="st">&quot;0vb7ikjscrp2rw0dfw6pilxqpjm50l5qg2x2mn1vfh93dkl2aan7&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb6-8" title="8">  };</a>
<a class="sourceLine" id="cb6-9" title="9">  <span class="ex">pkgs</span> = import nixpkgs {};</a>
<a class="sourceLine" id="cb6-10" title="10">  <span class="ex">haskellPackages</span> = pkgs.haskellPackages.override {</a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="ex">overrides</span> = self: super: {</a>
<a class="sourceLine" id="cb6-12" title="12">      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.2&quot;</span> {};</a>
<a class="sourceLine" id="cb6-13" title="13">      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.4.2&quot;</span> {};</a>
<a class="sourceLine" id="cb6-14" title="14">    };</a>
<a class="sourceLine" id="cb6-15" title="15">  };</a>
<a class="sourceLine" id="cb6-16" title="16"><span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {</a>
<a class="sourceLine" id="cb6-17" title="17">  <span class="ex">buildInputs</span> = [ haskellPackages.pandoc ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb6-18" title="18">} <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>Now we use the system-wide <code>nixpkgs</code> only to provide one function, <code>fetchFromGitHub</code>, which we then use to download a specific version of <code>nixpkgs</code> that we import instead. This is easier to use but computing the <code>sha256</code> is frustrating. One trick to keep in mind is that <code>fetchFromGitHub</code> is equivalent to</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1">$ <span class="ex">nix-prefetch-url</span> --unpack https://github.com/<span class="op">&lt;</span>owner<span class="op">&gt;</span>/<span class="op">&lt;</span>repo<span class="op">&gt;</span>/archive/<span class="op">&lt;</span>rev<span class="op">&gt;</span>.tar.gz</a></code></pre></div>
<p>which outputs the correct hash at the end.</p>
<p>What happens if we want to update the pinned version? One workflow I’ve seen suggested is to update the <code>rev</code>, change one character in the <code>sha256</code>, and let the Nix error message tell you the correct hash to use. I think we can do better than this.</p>
<p><a href="https://github.com/expipiplus1">Joe Hermaszewski</a> has a handy tool called <a href="https://github.com/expipiplus1/update-nix-fetchgit">update-nix-fetchgit</a> that parses Nix files and automatically updates any <code>fetchFromGitHub</code> calls to the latest <code>master</code> revision and SHA256 of the repository. This is certainly a lot more convenient, but it doesn’t seem to work for repositories that don’t have a <code>master</code> branch or that we want to update to the <code>HEAD</code> of a different branch. This seems like an unimportant omission except that <code>nixpkgs-channels</code> is one such repository, and we want to update it to the <code>HEAD</code> of e.g. <code>nixos-18.03</code>.</p>
<p>So, we have a tedious manual process on one hand and a quick, efficient, and wrong process on the other. There has to be a better way!</p>
<p>I’ve settled on a solution that uses two extra files: an <code>updater</code> script and a <code>versions.json</code> that stores the arguments to <code>fetchFromGitHub</code> as JSON.</p>
<p>My <code>updater</code> script looks like</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="co">#! /usr/bin/env nix-shell</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="co">#! nix-shell -i bash</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co">#! nix-shell -p curl jq nix</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">set</span> <span class="ex">-eufo</span> pipefail</a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="va">FILE=$1</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="va">PROJECT=$2</span></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="va">BRANCH=${3:-</span>master<span class="va">}</span></a>
<a class="sourceLine" id="cb8-10" title="10"></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="va">OWNER=$(</span><span class="ex">jq</span> -r <span class="st">&#39;.[$project].owner&#39;</span> --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="va">REPO=$(</span><span class="ex">jq</span> -r <span class="st">&#39;.[$project].repo&#39;</span> --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-13" title="13"></a>
<a class="sourceLine" id="cb8-14" title="14"><span class="va">REV=$(</span><span class="ex">curl</span> <span class="st">&quot;https://api.github.com/repos/</span><span class="va">$OWNER</span><span class="st">/</span><span class="va">$REPO</span><span class="st">/branches/</span><span class="va">$BRANCH</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="ex">jq</span> -r <span class="st">&#39;.commit.sha&#39;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-15" title="15"><span class="va">SHA256=$(</span><span class="ex">nix-prefetch-url</span> --unpack <span class="st">&quot;https://github.com/</span><span class="va">$OWNER</span><span class="st">/</span><span class="va">$REPO</span><span class="st">/archive/</span><span class="va">$REV</span><span class="st">.tar.gz&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-16" title="16"><span class="va">TJQ=$(</span><span class="ex">jq</span> <span class="st">&#39;.[$project] = {owner: $owner, repo: $repo, rev: $rev, sha256: $sha256}&#39;</span> \</a>
<a class="sourceLine" id="cb8-17" title="17">  --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-18" title="18">  --arg owner <span class="st">&quot;</span><span class="va">$OWNER</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-19" title="19">  --arg repo <span class="st">&quot;</span><span class="va">$REPO</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-20" title="20">  --arg rev <span class="st">&quot;</span><span class="va">$REV</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-21" title="21">  --arg sha256 <span class="st">&quot;</span><span class="va">$SHA256</span><span class="st">&quot;</span> \</a>
<a class="sourceLine" id="cb8-22" title="22">  <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span></a>
<a class="sourceLine" id="cb8-23" title="23"><span class="kw">[[</span> <span class="va">$?</span> <span class="ot">==</span> 0<span class="kw"> ]]</span> <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">${TJQ}</span><span class="st">&quot;</span> <span class="op">&gt;</span><span class="kw">|</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span></a></code></pre></div>
<p>It uses <code>curl</code> and <code>jq</code> to interact with the GitHub API and <code>nix</code> to calculate the appropriate hashes.</p>
<p>A simple <code>versions.json</code> looks like</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode json"><code class="sourceCode json"><a class="sourceLine" id="cb9-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="dt">&quot;nixpkgs&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="dt">&quot;owner&quot;</span><span class="fu">:</span> <span class="st">&quot;NixOS&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="dt">&quot;repo&quot;</span><span class="fu">:</span> <span class="st">&quot;nixpkgs-channels&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="dt">&quot;rev&quot;</span><span class="fu">:</span> <span class="st">&quot;2f6440eb09b7e6e3322720ac91ce7e2cdeb413f9&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="dt">&quot;sha256&quot;</span><span class="fu">:</span> <span class="st">&quot;0vb7ikjscrp2rw0dfw6pilxqpjm50l5qg2x2mn1vfh93dkl2aan7&quot;</span></a>
<a class="sourceLine" id="cb9-7" title="7">  <span class="fu">}</span></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="fu">}</span></a></code></pre></div>
<p>And a Nix expression using these files looks like</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" title="1"><span class="bu">let</span></a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="ex">inherit</span> (import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {}) <span class="ex">fetchFromGitHub</span> lib<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="ex">versions</span> = lib.mapAttrs</a>
<a class="sourceLine" id="cb10-4" title="4">    <span class="kw">(</span><span class="ex">_</span>: fetchFromGitHub<span class="kw">)</span></a>
<a class="sourceLine" id="cb10-5" title="5">    <span class="kw">(</span><span class="ex">builtins.fromJSON</span> (builtins.readFile ./versions.json<span class="kw">)</span>);</a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="co"># ./updater versions.json nixpkgs nixos-18.03</span></a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="ex">pkgs</span> = import versions.nixpkgs {};</a>
<a class="sourceLine" id="cb10-8" title="8">  <span class="ex">haskellPackages</span> = pkgs.haskellPackages.override {</a>
<a class="sourceLine" id="cb10-9" title="9">    <span class="ex">overrides</span> = self: super: {</a>
<a class="sourceLine" id="cb10-10" title="10">      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.2&quot;</span> {};</a>
<a class="sourceLine" id="cb10-11" title="11">      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.4.2&quot;</span> {};</a>
<a class="sourceLine" id="cb10-12" title="12">    };</a>
<a class="sourceLine" id="cb10-13" title="13">  };</a>
<a class="sourceLine" id="cb10-14" title="14"><span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {</a>
<a class="sourceLine" id="cb10-15" title="15">  <span class="ex">buildInputs</span> = [ haskellPackages.pandoc ]<span class="kw">;</span></a>
<a class="sourceLine" id="cb10-16" title="16">} <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>And the command to update <code>nixpkgs</code> is</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1">$ <span class="ex">./updater</span> versions.json nixpkgs nixos-18.03</a></code></pre></div>
<p>The reason I went with this approach is that <code>jq</code> is easier and friendlier to use than most of the Nix tooling available, and Nix fortunately has good JSON interoperability. I’ve toyed with the idea of rewriting my updater script in a language that is more robust (possibly Haskell with <a href="https://github.com/haskell-nix/hnix">hnix</a>) but I feel like it’s at a local maximum and I’m happy with the way it works for now.</p>
<p>I hope you find some of the ideas and/or code here useful the next time you’re wondering if you should pin <code>nixpkgs</code> and how to do so!</p>
<p><strong>Appendix 1</strong></p>
<p>If you use Nix 2.0 or newer, the <code>builtins.fetchTarball</code> command takes a <code>sha256</code> which means you can replace <code>fetchFromGitHub</code> and bootstrap without an existing <code>&lt;nixpkgs&gt;</code>! The following code snippet is identical to <code>fetchFromGitHub</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode nix"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" title="1"><span class="ex">fetcher</span> = { owner, repo, rev, sha256 }: <span class="ex">builtins.fetchTarball</span> {</a>
<a class="sourceLine" id="cb12-2" title="2">  <span class="ex">inherit</span> sha256<span class="kw">;</span></a>
<a class="sourceLine" id="cb12-3" title="3">  <span class="ex">url</span> = <span class="st">&quot;https://github.com/</span><span class="va">${owner}</span><span class="st">/</span><span class="va">${repo}</span><span class="st">/archive/</span><span class="va">${rev}</span><span class="st">.tar.gz&quot;</span><span class="kw">;</span></a>
<a class="sourceLine" id="cb12-4" title="4">};</a></code></pre></div>
<p>Thanks to <a href="https://jarmac.org/">Ahmad Jarara</a>, <a href="https://twitter.com/@chrisczynski">Chris Stryczynski</a>, <a href="https://github.com/garry-cairns">Garry Cairns</a>, <a href="https://haroldtreen.com/">Harold Treen</a>, <a href="https://ren.zone/">Renzo Carbonara</a>, <a href="http://susanpotter.net/">Susan Potter</a>, and <a href="https://twitter.com/tpflug">Tobias Pflug</a> for comments and feedback!</p>
]]></summary>
</entry>
<entry>
    <title>IHaskell on CoCalc!</title>
    <link href="https://vaibhavsagar.com/blog/2018/04/08/ihaskell-cocalc/index.html" />
    <id>https://vaibhavsagar.com/blog/2018/04/08/ihaskell-cocalc/index.html</id>
    <published>2018-04-08T00:00:00Z</published>
    <updated>2018-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    Posted on  8 April 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>
    
</div>

<p>IHaskell is now available on <a href="https://cocalc.com/">CoCalc</a>! I’m excited that there are even more options for creating your own IHaskell notebooks without having to install anything.</p>
<p>This is the result of a long collaboration with the lovely people at CoCalc, particularly <a href="https://wstein.org/">William Stein</a> and <a href="http://harald.schil.ly/">Harald Schilly</a>. I’d like to say a little about how this happened, but if you’re not interested you can stop reading here!</p>
<p>During the wonderful and magical time that was my batch at the <a href="https://www.recurse.com/scout/click?t=5ac465e5d3396a7e491e42afac4c5c90">Recurse Center</a>, I fulfilled a long-term goal of <a href="https://www.youtube.com/watch?v=wsNnP3we_R4">speaking at the NYHUG</a>. I was particularly enthusiastic about IHaskell, and <a href="http://gbaz.github.io/">Gershom</a> mentioned that people at SageMathCloud were interested in <a href="https://github.com/sagemathinc/cocalc/issues/125">getting it working</a> and offered to put me in touch.</p>
<p>I immediately encountered an issue where <a href="https://github.com/gibiansky/IHaskell/issues/694">IHaskell wasn’t handling all valid inputs</a> and complained about it on <a href="https://www.recurse.com/blog/112-how-rc-uses-zulip">Zulip</a>. I woke up the next day to find that <a href="https://twitter.com/horrorcheck">Libby Horacek</a> had gone ahead and <a href="https://github.com/gibiansky/IHaskell/pull/697">fixed the issue</a>. What a legend! This was also my first open-source contribution to a Haskell project ever.</p>
<p>I then tried the obvious thing, <code>stack build &amp;&amp; stack install</code> which resulted in a working notebook but an impossible deploy, because they needed the whole installation to be self-contained whereas Stack stores some things in <code>~/.stack</code> and other things in <code>&lt;project&gt;/.stack-work</code>. I (incorrectly) assumed that having <code>ihaskell</code> be a static binary would fix the issue, so then I spent a few weeks faffing around with <a href="https://www.fpcomplete.com/blog/2016/10/static-compilation-with-stack">this</a> which resulted in a static binary and made no difference otherwise.</p>
<p>Frustrated that my first attempt failed, I went silent for a while. My batch ended, I was unemployed for a few more months, I started a new role, and I moved to a new country. Because <a href="https://github.com/gibiansky/IHaskell/pull/716#issuecomment-305934463">I asked at the right time</a>, I became a maintainer of IHaskell and we finally got GHC 8 support! We also dropped GHC 7.10 support, which was <a href="https://github.com/gibiansky/IHaskell/pull/747">controversial</a>.</p>
<p>In the meantime SageMathCloud rebranded to CoCalc and revamped its infrastructure, and <a href="https://github.com/gibiansky/IHaskell/issues/731">they put the feelers out to try again</a>.</p>
<p>I saw that they were still running GHC 7.10 and went silent again, because I didn’t want to use an old version of IHaskell or have the discussion about installing a newer GHC just so I could fiddle some more. Instead, I worked on keeping IHaskell up-to-date and making it easier to use, with PRs for <a href="https://github.com/gibiansky/IHaskell/pull/735">GHC 8.2</a>, <a href="https://github.com/gibiansky/IHaskell/pull/817">GHC 8.4</a> and supporting installation with Nix.</p>
<p>Despite my best efforts, I was still getting lots of questions about installing IHaskell and I got fed up and <a href="https://twitter.com/vbhvsgr/status/975388161898561536">whinged about it on Twitter</a>. In response, Gershom DMed me to ask how the CoCalc stuff was progressing, after which I got back in touch and asked for a newer version of GHC. They obliged with GHC 8.4.</p>
<p>By this time we had realised that Stack wasn’t going to work, so we tried old-style Cabal and new-style Cabal, which both have similar issues with dependencies in <code>~/.cabal</code>. Finally Harald suggested using <code>cabal sandbox</code> and we were able to come up with a working, self-contained IHaskell install.</p>
<p>This would have been impossible without the patience and generosity of everyone involved. All told, it took almost a year and a half to get this working, which doesn’t come across in the <a href="https://twitter.com/cocalc_com/status/982650432928583680">announcement</a>.</p>
]]></summary>
</entry>

</feed>
