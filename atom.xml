<?xml version="1.0" encoding="utf-8" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Vaibhav Sagar's blog</title>
    <link href="https://vaibhavsagar.com/atom.xml" rel="self" />
    <link href="https://vaibhavsagar.com" />
    <id>https://vaibhavsagar.com/atom.xml</id>
    <author>
        <name>Vaibhav Sagar</name>
        <email>vaibhavsagar@gmail.com</email>
    </author>
    <updated>2019-10-29T00:00:00Z</updated>
    <entry>
    <title>Getting Along with JavaScript</title>
    <link href="https://vaibhavsagar.com/blog/2019/10/29/getting-along-with-javascript/" />
    <id>https://vaibhavsagar.com/blog/2019/10/29/getting-along-with-javascript/index.html</id>
    <published>2019-10-29</published>
    <updated>2019-10-29T00:00:00Z</updated>
    <summary type="html"><div class="info">
    Posted on 29 October 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/nix/index.html">nix</a>
    
</div>

<p>For the last couple of weeks, I’ve been obsessed with the idea of running Haskell in the browser. I know this is possible, because this is what I do at work every day, but the applications I work on professionally are complex beasts with Haskell backends and dedicated servers making them available to users. I’m looking for something lighter that I can serve statically using GitHub Pages or <a href="https://glitch.com">Glitch</a>, so I can plop some code on a webpage and never worry about hosting ever again.</p>
<p>My first instinct was to reach for a tool like <a href="https://github.com/obsidiansystems/obelisk">Obelisk</a>, which bills itself as “an easy way to develop and deploy your Reflex project”. Although it does work as advertised(!), it is geared towards the needs of the large apps I mentioned above. It prerenders webpages where possible to make projects as snappy as possible, works best within the confines of the Obelisk libraries, and assumes at least one NixOS target that will host your website, all of which mean it doesn’t yet scale down to my comparatively modest needs. It is possible to use Obelisk anyway, but I found myself using too few of its features to justify the effort, and I decided to move down a level and use <a href="https://github.com/reflex-frp/reflex-platform">Reflex Platform</a> directly, which is a set of changes and overrides to a revision of <a href="https://github.com/NixOS/nixpkgs">Nixpkgs</a> to best support building full-stack and mobile Haskell applications.</p>
<p>If you’d like to follow along, I have the code available <a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8">at this gist</a> with <a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/revisions">each revision</a> representing a step in the progression.</p>
<h3 id="setting-up-reflex-platform">Setting up reflex-platform</h3>
<p>I like to use the <code>updater</code> script described in <a href="/blog/quick-easy-nixpkgs-pinning">a previous blog post</a>, so I’ll start by copying that over and creating a <code>versions.json</code> with the following contents:</p>
<details>
<p><summary style="cursor: pointer"><code>versions.json</code></summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1"></a><span class="fu">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="dt">&quot;reflex-platform&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="dt">&quot;owner&quot;</span><span class="fu">:</span> <span class="st">&quot;reflex-frp&quot;</span><span class="fu">,</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="dt">&quot;repo&quot;</span><span class="fu">:</span> <span class="st">&quot;reflex-platform&quot;</span><span class="fu">,</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="dt">&quot;branch&quot;</span><span class="fu">:</span> <span class="st">&quot;develop&quot;</span><span class="fu">,</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="dt">&quot;rev&quot;</span><span class="fu">:</span> <span class="st">&quot;&quot;</span><span class="fu">,</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>    <span class="dt">&quot;sha256&quot;</span><span class="fu">:</span> <span class="st">&quot;&quot;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>  <span class="fu">}</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="fu">}</span></span></code></pre></div>
</details>
<p>I can then update this by running:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a>$ <span class="ex">./updater</span> versions.json reflex-platform</span></code></pre></div>
<p>to get the latest <code>reflex-platform</code>. At the time of writing, this is the revision I used:</p>
<details>
<p><summary style="cursor: pointer">pinned <code>versions.json</code></summary></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb3-1"><a href="#cb3-1"></a><span class="fu">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="dt">&quot;reflex-platform&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="dt">&quot;owner&quot;</span><span class="fu">:</span> <span class="st">&quot;reflex-frp&quot;</span><span class="fu">,</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    <span class="dt">&quot;repo&quot;</span><span class="fu">:</span> <span class="st">&quot;reflex-platform&quot;</span><span class="fu">,</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="dt">&quot;branch&quot;</span><span class="fu">:</span> <span class="st">&quot;develop&quot;</span><span class="fu">,</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    <span class="dt">&quot;rev&quot;</span><span class="fu">:</span> <span class="st">&quot;8f4b8973a06f78c7aaf1a222f8f8443cd934569f&quot;</span><span class="fu">,</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="dt">&quot;sha256&quot;</span><span class="fu">:</span> <span class="st">&quot;167smg7dyvg5yf1wn9bx6yxvazlk0qk64rzgm2kfzn9mx873s0vp&quot;</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>  <span class="fu">}</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="fu">}</span></span></code></pre></div>
</details>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/c21e62ecdcc053273ee5e4815ef538e1e8a29e55#file-versions-json">revision</a>)</em></p>
<h3 id="creating-a-project-skeleton">Creating a project skeleton</h3>
<p>The next step is to get a Haskell project skeleton in place. I used <code>cabal init</code> for this as follows:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a>$ <span class="ex">nix-shell</span> -p ghc cabal-install --run <span class="st">&#39;cabal init -lBSD3&#39;</span></span></code></pre></div>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/d4c4f9ff39b595f5c8858892328adfa6ab4a4cc8#file-small-viz-cabal">revision</a>)</em></p>
<p>which generated an executable-only project, just like I wanted. I named this project <code>small-viz</code>, because it’s a small project using the <a href="http://viz-js.com/">Viz.js</a> library, but more on that later.</p>
<p>The next step is to actually use <code>reflex-platform</code> to develop this project, for which we need to write a little Nix. Here’s the <code>default.nix</code> I used:</p>
<details>
<p><summary style="cursor: pointer"><code>default.nix</code></summary></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1"></a><span class="bu">let</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="co"># ./updater versions.json reflex-platform</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="ex">fetcher</span> = { owner, repo, rev, sha256, ... }: <span class="ex">builtins.fetchTarball</span> {</span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="ex">inherit</span> sha256<span class="kw">;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="ex">url</span> = <span class="st">&quot;https://github.com/</span><span class="va">${owner}</span><span class="st">/</span><span class="va">${repo}</span><span class="st">/tarball/</span><span class="va">${rev}</span><span class="st">&quot;</span><span class="kw">;</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>  };</span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="ex">reflex-platform</span> = fetcher (builtins.fromJSON (builtins.readFile ./versions.json))<span class="ex">.reflex-platform</span><span class="kw">;</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">in</span> <span class="kw">(</span><span class="ex">import</span> reflex-platform { system = builtins.currentSystem<span class="kw">;</span> }<span class="kw">)</span><span class="ex">.project</span> ({ pkgs, ... }: <span class="kw">{</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>  <span class="ex">useWarp</span> = true<span class="kw">;</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>  <span class="ex">withHoogle</span> = false<span class="kw">;</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>  <span class="ex">packages</span> = {</span>
<span id="cb5-12"><a href="#cb5-12"></a>    <span class="ex">small-viz</span> = ./.<span class="kw">;</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>  <span class="kw">}</span>;</span>
<span id="cb5-14"><a href="#cb5-14"></a>  <span class="ex">shells</span> = {</span>
<span id="cb5-15"><a href="#cb5-15"></a>    <span class="ex">ghc</span> = [<span class="st">&quot;small-viz&quot;</span>]<span class="kw">;</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="ex">ghcjs</span> = [<span class="st">&quot;small-viz&quot;</span>]<span class="kw">;</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>  };</span>
<span id="cb5-18"><a href="#cb5-18"></a>})</span></code></pre></div>
</details>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/348b759019bc19aec9833a6b5f042c1d2f5e9b13#file-default-nix">revision</a>)</em></p>
<p>This sets up our project to build with both GHC and GHCJS, because we want to develop with GHC but eventually use GHCJS to create our final artifact. I also set a few more options:</p>
<ol type="1">
<li><p><code>useWarp = true</code> changes the JSaddle backend to <code>jsaddle-warp</code> so we can develop using the browser, as described <a href="https://github.com/reflex-frp/reflex-platform/blob/8f4b8973a06f78c7aaf1a222f8f8443cd934569f/docs/project-development.md#building-frontends-with-ghc">here</a>.</p></li>
<li><p><code>withHoogle = false</code> means we don’t build a local Hoogle database every time our packages are updated, because this step is slow and I never used the local documentation anyway.</p></li>
</ol>
<p>For the next step I’ll assume binary cache substitution has been set up as described <a href="https://github.com/reflex-frp/reflex-platform/blob/develop/notes/NixOS.md#enabling-the-binary-cache-on-nixos">here</a>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a>$ <span class="ex">nix-shell</span> -A shells.ghc</span></code></pre></div>
<p>This should download a lot (and build almost nothing from source since we are pulling from the cache), and then enter a shell environment with our dependencies in scope.</p>
<h3 id="starting-our-reflex-app">Starting our Reflex app</h3>
<p>Now we can start developing our Reflex app! We can start from the small example described <a href="https://github.com/reflex-frp/reflex-platform/tree/8f4b8973a06f78c7aaf1a222f8f8443cd934569f#dynamics-and-events">here</a>:</p>
<details>
<p><summary style="cursor: pointer"><code>Main.hs</code></summary></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">import</span> <span class="dt">Reflex.Dom</span></span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a>main <span class="ot">=</span> mainWidget <span class="op">$</span> el <span class="st">&quot;div&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>  t <span class="ot">&lt;-</span> inputElement def</span>
<span id="cb7-6"><a href="#cb7-6"></a>  dynText <span class="op">$</span> _inputElement_value t</span></code></pre></div>
</details>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/93c510d77f7a8d6b1d8d63bb1cb0be37c6d575b5#file-main-hs">revision</a>)</em></p>
<p>We also have to add <code>reflex-dom</code> and <code>reflex</code> to our dependencies in our <code>.cabal</code> file, and then we can get a automatically-reloading development build with one command:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1"></a>$ <span class="ex">nix-shell</span> -A shells.ghc --run <span class="st">&#39;ghcid -T &quot;Main.main&quot; --command &quot;cabal new-repl&quot;&#39;</span></span></code></pre></div>
<p>This allows a native Haskell process to control a web page, so we can navigate to it using our browser at <code>http://localhost:3003</code> and have a fast feedback loop. In practice there is a lot of brower refreshing involved, but this is still much nicer than having to do a GHCJS build each time we want to look at our changes. Now we have an input box that repeats what we type into it, which is a good start. I should point out that this works a lot better on Google Chrome (or Chromium) than it does on Firefox, and that’s what I’ll be using for development. The final GHCJS output does not have this limitation.</p>
<p>So where are we going with this? My plan is to build a crude version of the <a href="http://viz-js.com">Viz.js</a> homepage, where you can write <a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">DOT</a> and see it rendered instantly. Viz.js is the result of compiling the venerable <a href="http://graphviz.org/">Graphviz</a> to JavaScript using <a href="https://emscripten.org">Emscripten</a>. It’s no longer maintained but still works fine as far as I can tell. In order to do this I want to use some kind of JavaScript FFI to call out to <code>viz.js</code>, but first I want to swap out our text input for a text area, and move the repeated output to just below the text area instead of beside it.</p>
<details>
<p><summary style="cursor: pointer"><code>Main.hs</code></summary></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">import</span> <span class="dt">Reflex.Dom</span></span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a>main <span class="ot">=</span> mainWidget <span class="op">$</span> el <span class="st">&quot;div&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>  t <span class="ot">&lt;-</span> textArea def</span>
<span id="cb9-6"><a href="#cb9-6"></a>  el <span class="st">&quot;div&quot;</span> <span class="op">$</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>    dynText <span class="op">$</span> _textArea_value t</span></code></pre></div>
</details>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/d5ff4725b26db3dd596abb2e751711f5c568b6bc#file-main-hs">revision</a>)</em></p>
<h3 id="integrating-with-viz.js">Integrating with Viz.js</h3>
<p>The latest version of Viz.js is available <a href="https://www.jsdelivr.com/package/npm/viz.js">here</a>, and we can include it using <code>mainWidgetWithHead</code>:</p>
<details>
<p><summary style="cursor: pointer"><code>Main.hs</code></summary></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">import</span> <span class="dt">Reflex.Dom</span></span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a>main <span class="ot">=</span> mainWidgetWithHead widgetHead <span class="op">$</span> el <span class="st">&quot;div&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>  t <span class="ot">&lt;-</span> textArea def</span>
<span id="cb10-6"><a href="#cb10-6"></a>  el <span class="st">&quot;div&quot;</span> <span class="op">$</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>    dynText <span class="op">$</span> _textArea_value t</span>
<span id="cb10-8"><a href="#cb10-8"></a>  <span class="kw">where</span></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="ot">    widgetHead ::</span> <span class="dt">DomBuilder</span> t m <span class="ot">=&gt;</span> m ()</span>
<span id="cb10-10"><a href="#cb10-10"></a>    widgetHead <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>      script <span class="st">&quot;https://cdn.jsdelivr.net/npm/viz.js@2.1.2/viz.min.js&quot;</span></span>
<span id="cb10-12"><a href="#cb10-12"></a>      script <span class="st">&quot;https://cdn.jsdelivr.net/npm/viz.js@2.1.2/full.render.min.js&quot;</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>    script src <span class="ot">=</span> elAttr <span class="st">&quot;script&quot;</span> (<span class="st">&quot;type&quot;</span> <span class="op">=:</span> <span class="st">&quot;text/javascript&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot;src&quot;</span> <span class="op">=:</span> src) blank</span></code></pre></div>
</details>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/6a856c34755f730793f3b588a82f0fc9f836bf9c#file-main-hs">revision</a>)</em></p>
<p>Now we can poke around with our browser developer tools until we have a useful JavaScript function. Here’s what I came up with, based on the examples in the <a href="https://github.com/mdaines/viz.js/wiki/Usage#using-a-script-tag">wiki</a>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">function</span>(e<span class="op">,</span> string) <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>  <span class="kw">var</span> viz <span class="op">=</span> <span class="kw">new</span> <span class="at">Viz</span>()<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="va">viz</span>.<span class="at">renderSVGElement</span>(string)</span>
<span id="cb11-4"><a href="#cb11-4"></a>  .<span class="at">then</span>(<span class="kw">function</span>(element) <span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>    <span class="va">e</span>.<span class="at">innerHTML</span> <span class="op">=</span> <span class="va">element</span>.<span class="at">outerHTML</span><span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>  <span class="op">}</span>)</span>
<span id="cb11-7"><a href="#cb11-7"></a>  .<span class="at">catch</span>(<span class="kw">function</span>(error) <span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="va">e</span>.<span class="at">innerHTML</span> <span class="op">=</span> error<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>  <span class="op">}</span>)</span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="op">}</span></span></code></pre></div>
<p>Then we can start thinking about how we want to do JavaScript interop! Although there is a GHCJS FFI as described <a href="https://github.com/ghcjs/ghcjs/wiki/A-few-examples-of-Foreign-Function-Interface">in the wiki</a>, this doesn’t seem to work at all with GHC, and that means we can’t use it during development. I don’t think that’s good enough, and fortunately we don’t have to settle for this and instead can use <a href="http://hackage.haskell.org/package/jsaddle-0.9.6.0"><code>jsaddle</code></a>, which describes itself as “an EDSL for calling JavaScript that can be used both from GHCJS and GHC”. We can add <code>jsaddle</code> to our dependencies, add <code>Viz</code> to the <code>exposed-modules</code> stanza in our <code>.cabal</code> file, and create a new module <code>Viz</code>, and then we can use the <code>eval</code> and <code>call</code> functions to call our JavaScript directly:</p>
<details>
<p><summary style="cursor: pointer"><code>Viz.hs</code></summary></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">module</span> <span class="dt">Viz</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="kw">import</span> <span class="dt">Language.Javascript.JSaddle</span></span>
<span id="cb12-4"><a href="#cb12-4"></a></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="ot">viz ::</span> <span class="dt">JSVal</span> <span class="ot">-&gt;</span> <span class="dt">JSVal</span> <span class="ot">-&gt;</span> <span class="dt">JSM</span> ()</span>
<span id="cb12-6"><a href="#cb12-6"></a>viz element string <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>  call vizJs vizJs [element, string]</span>
<span id="cb12-8"><a href="#cb12-8"></a>  <span class="fu">pure</span> ()</span>
<span id="cb12-9"><a href="#cb12-9"></a></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="ot">vizJs ::</span> <span class="dt">JSM</span> <span class="dt">JSVal</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>vizJs <span class="ot">=</span> eval</span>
<span id="cb12-12"><a href="#cb12-12"></a>  <span class="st">&quot;(function(e, string) { \</span></span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="st">  \  var viz = new Viz(); \</span></span>
<span id="cb12-14"><a href="#cb12-14"></a><span class="st">  \  viz.renderSVGElement(string) \</span></span>
<span id="cb12-15"><a href="#cb12-15"></a><span class="st">  \  .then(function(element) { \</span></span>
<span id="cb12-16"><a href="#cb12-16"></a><span class="st">  \    e.innerHTML = element.outerHTML; \</span></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="st">  \  }) \</span></span>
<span id="cb12-18"><a href="#cb12-18"></a><span class="st">  \  .catch(function(error) { \</span></span>
<span id="cb12-19"><a href="#cb12-19"></a><span class="st">  \    e.innerHTML = error; \</span></span>
<span id="cb12-20"><a href="#cb12-20"></a><span class="st">  \  }) \</span></span>
<span id="cb12-21"><a href="#cb12-21"></a><span class="st">  \})&quot;</span></span></code></pre></div>
</details>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/b234b2649022b1b560df1281f053bac30289ce12#file-viz-hs">revision</a>)</em></p>
<p>JSaddle runs operations in <code>JSM</code>, which is similar to <code>IO</code>, and all functions take values of type <code>JSVal</code> that can be represented as JavaScript values. We pass <code>vizJs</code> to <code>call</code> twice because the second parameter represents the <code>this</code> keyword.</p>
<p>Wiring everything up together is just a few more lines of code:</p>
<details>
<p><summary style="cursor: pointer"><code>Main.hs</code></summary></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">import</span> <span class="dt">Reflex.Dom</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">import</span> <span class="dt">Language.Javascript.JSaddle</span> (liftJSM, toJSVal)</span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="kw">import</span> <span class="dt">Viz</span> (viz)</span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a>main <span class="ot">=</span> mainWidgetWithHead widgetHead <span class="op">$</span> el <span class="st">&quot;div&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>  t <span class="ot">&lt;-</span> textArea def</span>
<span id="cb13-8"><a href="#cb13-8"></a>  e <span class="ot">&lt;-</span> _element_raw <span class="op">.</span> <span class="fu">fst</span> <span class="op">&lt;$&gt;</span> el&#39; <span class="st">&quot;div&quot;</span> blank</span>
<span id="cb13-9"><a href="#cb13-9"></a>  performEvent_ <span class="op">$</span> ffor (updated (_textArea_value t)) <span class="op">$</span> \text <span class="ot">-&gt;</span> liftJSM <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>    jsE <span class="ot">&lt;-</span> toJSVal e</span>
<span id="cb13-11"><a href="#cb13-11"></a>    jsT <span class="ot">&lt;-</span> toJSVal text</span>
<span id="cb13-12"><a href="#cb13-12"></a>    viz jsE jsT</span>
<span id="cb13-13"><a href="#cb13-13"></a>  <span class="kw">where</span></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="ot">    widgetHead ::</span> <span class="dt">DomBuilder</span> t m <span class="ot">=&gt;</span> m ()</span>
<span id="cb13-15"><a href="#cb13-15"></a>    widgetHead <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-16"><a href="#cb13-16"></a>      script <span class="st">&quot;https://cdn.jsdelivr.net/npm/viz.js@2.1.2/viz.min.js&quot;</span></span>
<span id="cb13-17"><a href="#cb13-17"></a>      script <span class="st">&quot;https://cdn.jsdelivr.net/npm/viz.js@2.1.2/full.render.min.js&quot;</span></span>
<span id="cb13-18"><a href="#cb13-18"></a>    script src <span class="ot">=</span> elAttr <span class="st">&quot;script&quot;</span> (<span class="st">&quot;type&quot;</span> <span class="op">=:</span> <span class="st">&quot;text/javascript&quot;</span> <span class="op">&lt;&gt;</span> <span class="st">&quot;src&quot;</span> <span class="op">=:</span> src) blank</span></code></pre></div>
</details>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/e0e886959e338803f9c4a1a3596f8eb88474424d#file-main-hs">revision</a>)</em></p>
<p>There’s a lot going on here, so I’ll explain in a little more detail.</p>
<p>Instead of an element which displays the textarea contents as they are updated, we just want a reference to a blank <code>&lt;div&gt;</code>, so we use the <a href="https://hackage.haskell.org/package/reflex-dom-core-0.5/docs/Reflex-Dom-Widget-Basic.html#v:el-39-"><code>el'</code></a> function and pull out the raw element. <a href="http://hackage.haskell.org/package/reflex-0.6.2.4/docs/Reflex-PerformEvent-Class.html#v:performEvent_"><code>performEvent_</code></a> mediates the interaction between Reflex and side-effecting actions, like our function that updates the DOM with a rendered graph, so we want to use it to render a new graph every time the textarea is updated.</p>
<p>An introduction to Reflex is out of scope for this blog post, but it’s worth mentioning that the textarea value is represented as a <a href="http://hackage.haskell.org/package/reflex-0.6.2.4/docs/Reflex-Class.html#t:Dynamic"><code>Dynamic</code></a>, which can change over time and notify consumers when it has changed. This can be thought of as the combination of a related <a href="http://hackage.haskell.org/package/reflex-0.6.2.4/docs/Reflex-Class.html#t:Behavior"><code>Behavior</code></a> and <a href="http://hackage.haskell.org/package/reflex-0.6.2.4/docs/Reflex-Class.html#t:Event"><code>Event</code></a>. <code>performEvent_</code> only takes an <code>Event</code>, and we can get the underlying <code>Event</code> out of a <code>Dynamic</code> with <a href="http://hackage.haskell.org/package/reflex-0.6.2.4/docs/Reflex-Class.html#v:updated"><code>updated</code></a>.</p>
<p><code>ffor</code> is just <code>flip fmap</code>, and we use it to operate on the underlying <code>Text</code> value, convert both it and the reference to the element we want to update to <code>JSVal</code>s, and then pass them as arguments to the <code>viz</code> function we defined earlier. Now we should have a working GraphViz renderer in our browser!</p>
<h3 id="using-the-ffi-better">Using the FFI better</h3>
<p>We could stop here, but I think we can do better than evaluating JavaScript strings directly. JSaddle is an EDSL, which means we can rewrite our JavaScript in Haskell:</p>
<details>
<p><summary style="cursor: pointer"><code>Viz.hs</code></summary></p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">module</span> <span class="dt">Viz</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">import</span> <span class="dt">Language.Javascript.JSaddle</span></span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="ot">viz ::</span> <span class="dt">JSVal</span> <span class="ot">-&gt;</span> <span class="dt">JSVal</span> <span class="ot">-&gt;</span> <span class="dt">JSM</span> ()</span>
<span id="cb14-6"><a href="#cb14-6"></a>viz element string <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>  viz <span class="ot">&lt;-</span> new (jsg <span class="st">&quot;Viz&quot;</span>) ()</span>
<span id="cb14-8"><a href="#cb14-8"></a>  render <span class="ot">&lt;-</span> viz <span class="op">#</span> <span class="st">&quot;renderSVGElement&quot;</span> <span class="op">$</span> [string]</span>
<span id="cb14-9"><a href="#cb14-9"></a>  result <span class="ot">&lt;-</span> render <span class="op">#</span> <span class="st">&quot;then&quot;</span> <span class="op">$</span> [(fun <span class="op">$</span> \_ _ [e] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>    outer <span class="ot">&lt;-</span> e <span class="op">!</span> <span class="st">&quot;outerHTML&quot;</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>    element <span class="op">&lt;#</span> <span class="st">&quot;innerHTML&quot;</span> <span class="op">$</span> outer</span>
<span id="cb14-12"><a href="#cb14-12"></a>  )]</span>
<span id="cb14-13"><a href="#cb14-13"></a>  result <span class="op">#</span> <span class="st">&quot;catch&quot;</span> <span class="op">$</span> [(fun <span class="op">$</span> \_ _ [err] <span class="ot">-&gt;</span></span>
<span id="cb14-14"><a href="#cb14-14"></a>    element <span class="op">&lt;#</span> <span class="st">&quot;innerHTML&quot;</span> <span class="op">$</span> err</span>
<span id="cb14-15"><a href="#cb14-15"></a>  )]</span>
<span id="cb14-16"><a href="#cb14-16"></a>  <span class="fu">pure</span> ()</span></code></pre></div>
</details>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/96e0dbda1ba9dc5712342bf1b123fe5d463201d0#file-viz-hs">revision</a>)</em></p>
<p>This is recognisably the same logic as before, using some new JSaddle operators:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/jsaddle-0.9.6.0/docs/Language-Javascript-JSaddle.html#v:-35-"><code>#</code></a> is for calling a JavaScript function</li>
<li><a href="http://hackage.haskell.org/package/jsaddle-0.9.6.0/docs/Language-Javascript-JSaddle.html#v:-33-"><code>!</code></a> is for property access</li>
<li><a href="http://hackage.haskell.org/package/jsaddle-0.9.6.0/docs/Language-Javascript-JSaddle.html#v:-60--35-"><code>&lt;#</code></a> is a setter</li>
</ul>
<p>Note also that all callables take a list of <code>JSVal</code>s as arguments, since JSaddle doesn’t know how many arguments we intend to pass in advance.</p>
<p>This is an improvement, but we can do even better using the lensy API (after adding <code>lens</code> to our dependencies):</p>
<details>
<p><summary style="cursor: pointer"><code>Viz.hs</code></summary></p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">module</span> <span class="dt">Viz</span> <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2"></a></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="kw">import</span> <span class="dt">Language.Javascript.JSaddle</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="kw">import</span> <span class="dt">Control.Lens</span> ((^.))</span>
<span id="cb15-5"><a href="#cb15-5"></a></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="ot">viz ::</span> <span class="dt">JSVal</span> <span class="ot">-&gt;</span> <span class="dt">JSVal</span> <span class="ot">-&gt;</span> <span class="dt">JSM</span> ()</span>
<span id="cb15-7"><a href="#cb15-7"></a>viz element string <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-8"><a href="#cb15-8"></a>  viz <span class="ot">&lt;-</span> new (jsg <span class="st">&quot;Viz&quot;</span>) ()</span>
<span id="cb15-9"><a href="#cb15-9"></a>  render <span class="ot">&lt;-</span> viz <span class="op">^.</span> js1 <span class="st">&quot;renderSVGElement&quot;</span> string</span>
<span id="cb15-10"><a href="#cb15-10"></a>  result <span class="ot">&lt;-</span> render <span class="op">^.</span> js1 <span class="st">&quot;then&quot;</span> (fun <span class="op">$</span> \_ _ [e] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb15-11"><a href="#cb15-11"></a>    outer <span class="ot">&lt;-</span> e <span class="op">!</span> <span class="st">&quot;outerHTML&quot;</span></span>
<span id="cb15-12"><a href="#cb15-12"></a>    element <span class="op">^.</span> jss <span class="st">&quot;innerHTML&quot;</span> outer)</span>
<span id="cb15-13"><a href="#cb15-13"></a>  result <span class="op">^.</span> js1 <span class="st">&quot;catch&quot;</span> (fun <span class="op">$</span> \_ _ [err] <span class="ot">-&gt;</span></span>
<span id="cb15-14"><a href="#cb15-14"></a>    element <span class="op">^.</span> jss <span class="st">&quot;innerHTML&quot;</span> err)</span>
<span id="cb15-15"><a href="#cb15-15"></a>  <span class="fu">pure</span> ()</span></code></pre></div>
</details>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/2ede687d9969666897fb1ca944ed83d239b4386b#file-viz-hs">revision</a>)</em></p>
<p>Again, not much has changed except that we can use convenience functions like <a href="http://hackage.haskell.org/package/jsaddle-0.9.6.0/docs/Language-Javascript-JSaddle.html#v:js1"><code>js1</code></a> and <a href="http://hackage.haskell.org/package/jsaddle-0.9.6.0/docs/Language-Javascript-JSaddle.html#v:jss"><code>jss</code></a>.</p>
<p>I’m told that there is some overhead to using JSaddle which it’s possible to get rid of by using a library like <a href="https://hackage.haskell.org/package/ghcjs-dom"><code>ghcjs-dom</code></a>, but I haven’t explored this approach and I will leave this as an exercise for the reader. If you learn how to do this, please teach me!</p>
<p>Now we are able to run Haskell on the frontend without having to write any JavaScript ourselves. The final step is to put this on the internet somewhere!</p>
<h3 id="deploying-our-app">Deploying our app</h3>
<p>Building with GHCJS is straightforward:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1"></a>$ <span class="ex">nix-build</span> -A ghcjs.small-viz</span></code></pre></div>
<p>I’m enamoured of the idea of deploying this to <a href="https://glitch.com/">Glitch</a>, so let’s look into doing that. The <code>index.html</code> created by the default GHCJS build is unnecessary, and we can simplify it:</p>
<details>
<p><summary style="cursor: pointer"><code>index.html</code></summary></p>
<div class="sourceCode" id="cb17"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb17-1"><a href="#cb17-1"></a><span class="dt">&lt;!DOCTYPE </span>html<span class="dt">&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">&lt;html&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>  <span class="kw">&lt;head&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="kw">&lt;script</span><span class="ot"> language=</span><span class="st">&quot;javascript&quot;</span><span class="ot"> src=</span><span class="st">&quot;all.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>  <span class="kw">&lt;/head&gt;</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>  <span class="kw">&lt;body&gt;</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>  <span class="kw">&lt;/body&gt;</span></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="kw">&lt;/html&gt;</span></span></code></pre></div>
</details>
<p>The only JavaScript file that needs to be copied over is then <code>all.js</code>. We can write a <code>glitch.nix</code> file to simplify this process:</p>
<details>
<p><summary style="cursor: pointer"><code>glitch.nix</code></summary></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1"></a><span class="bu">let</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>  <span class="co"># ./updater versions.json reflex-platform</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>  <span class="ex">fetcher</span> = { owner, repo, rev, sha256, ... }: <span class="ex">builtins.fetchTarball</span> {</span>
<span id="cb18-4"><a href="#cb18-4"></a>    <span class="ex">inherit</span> sha256<span class="kw">;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="ex">url</span> = <span class="st">&quot;https://github.com/</span><span class="va">${owner}</span><span class="st">/</span><span class="va">${repo}</span><span class="st">/tarball/</span><span class="va">${rev}</span><span class="st">&quot;</span><span class="kw">;</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>  };</span>
<span id="cb18-7"><a href="#cb18-7"></a>  <span class="ex">reflex-platform</span> = fetcher (builtins.fromJSON (builtins.readFile ./versions.json))<span class="ex">.reflex-platform</span><span class="kw">;</span></span>
<span id="cb18-8"><a href="#cb18-8"></a>  <span class="ex">pkgs</span> = (import reflex-platform {})<span class="ex">.nixpkgs</span><span class="kw">;</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>  <span class="ex">project</span> = import ./default.nix<span class="kw">;</span></span>
<span id="cb18-10"><a href="#cb18-10"></a>  <span class="ex">html</span> = pkgs.writeText <span class="st">&quot;index.html&quot;</span> <span class="st">&#39;&#39;</span></span>
<span id="cb18-11"><a href="#cb18-11"></a>    <span class="op">&lt;</span>!<span class="ex">DOCTYPE</span> html<span class="op">&gt;</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>    <span class="op">&lt;</span><span class="ex">html</span><span class="op">&gt;</span></span>
<span id="cb18-13"><a href="#cb18-13"></a>      <span class="op">&lt;</span><span class="fu">head</span><span class="op">&gt;</span></span>
<span id="cb18-14"><a href="#cb18-14"></a>        <span class="op">&lt;</span><span class="ex">script</span> language=<span class="st">&quot;javascript&quot;</span> src=<span class="st">&quot;all.js&quot;</span><span class="op">&gt;&lt;</span>/script<span class="op">&gt;</span></span>
<span id="cb18-15"><a href="#cb18-15"></a>      <span class="op">&lt;</span>/<span class="ex">head</span><span class="op">&gt;</span></span>
<span id="cb18-16"><a href="#cb18-16"></a>      <span class="op">&lt;</span><span class="ex">body</span><span class="op">&gt;</span></span>
<span id="cb18-17"><a href="#cb18-17"></a>      <span class="op">&lt;</span>/<span class="ex">body</span><span class="op">&gt;</span></span>
<span id="cb18-18"><a href="#cb18-18"></a>    <span class="op">&lt;</span>/<span class="ex">html</span><span class="op">&gt;</span></span>
<span id="cb18-19"><a href="#cb18-19"></a>  <span class="st">&#39;&#39;</span>;</span>
<span id="cb18-20"><a href="#cb18-20"></a><span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;glitch&quot;</span> {} <span class="st">&#39;&#39;</span></span>
<span id="cb18-21"><a href="#cb18-21"></a>  <span class="fu">mkdir</span> -p <span class="va">$out</span></span>
<span id="cb18-22"><a href="#cb18-22"></a>  <span class="fu">cp</span> <span class="va">${html}</span> <span class="va">$out</span>/index.html</span>
<span id="cb18-23"><a href="#cb18-23"></a>  <span class="fu">cp</span> <span class="va">${project</span><span class="er">.ghcjs.small</span><span class="va">-</span>viz<span class="va">}</span>/bin/small-viz.jsexe/all.js <span class="va">$out</span>/all.js</span>
<span id="cb18-24"><a href="#cb18-24"></a><span class="st">&#39;&#39;</span></span></code></pre></div>
</details>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/a0127badaee44f316156121153c0e4bc41af9460#file-glitch-nix">revision</a>)</em></p>
<p>And then produce the files we need to copy over with:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1"></a>$ <span class="ex">nix-build</span> glitch.nix</span></code></pre></div>
<p>I’ve gone ahead and done this, and it’s up on <a href="https://small-viz.glitch.me/">small-viz.glitch.me/</a>.</p>
<p>Now that everything’s working, it would be nice to reduce the size of <code>all.js</code>, which is currently over 5MB. Obelisk uses the <a href="https://developers.google.com/closure/compiler">Closure Compiler</a> to minify JavaScript, and we can adapt <a href="https://github.com/obsidiansystems/obelisk/blob/071e2edb92e623b4415fb6deedc4219ad1f829f0/default.nix#L147">what it does</a> and <a href="https://github.com/tomsmalley/marking/blob/a522b8c75a96146883a7e32acf5b17bb5f4abf1b/makefile#L5-L10">another example by Tom Smalley</a> that I found when I was looking into this to update <code>glitch.nix</code>:</p>
<details>
<p><summary style="cursor: pointer"><code>glitch.nix</code></summary></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1"></a><span class="bu">let</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>  <span class="co"># ./updater versions.json reflex-platform</span></span>
<span id="cb20-3"><a href="#cb20-3"></a>  <span class="ex">fetcher</span> = { owner, repo, rev, sha256, ... }: <span class="ex">builtins.fetchTarball</span> {</span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="ex">inherit</span> sha256<span class="kw">;</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>    <span class="ex">url</span> = <span class="st">&quot;https://github.com/</span><span class="va">${owner}</span><span class="st">/</span><span class="va">${repo}</span><span class="st">/tarball/</span><span class="va">${rev}</span><span class="st">&quot;</span><span class="kw">;</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>  };</span>
<span id="cb20-7"><a href="#cb20-7"></a>  <span class="ex">reflex-platform</span> = fetcher (builtins.fromJSON (builtins.readFile ./versions.json))<span class="ex">.reflex-platform</span><span class="kw">;</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>  <span class="ex">pkgs</span> = (import reflex-platform {})<span class="ex">.nixpkgs</span><span class="kw">;</span></span>
<span id="cb20-9"><a href="#cb20-9"></a>  <span class="ex">project</span> = import ./default.nix<span class="kw">;</span></span>
<span id="cb20-10"><a href="#cb20-10"></a>  <span class="ex">html</span> = pkgs.writeText <span class="st">&quot;index.html&quot;</span> <span class="st">&#39;&#39;</span></span>
<span id="cb20-11"><a href="#cb20-11"></a>    <span class="op">&lt;</span>!<span class="ex">DOCTYPE</span> html<span class="op">&gt;</span></span>
<span id="cb20-12"><a href="#cb20-12"></a>    <span class="op">&lt;</span><span class="ex">html</span><span class="op">&gt;</span></span>
<span id="cb20-13"><a href="#cb20-13"></a>      <span class="op">&lt;</span><span class="fu">head</span><span class="op">&gt;</span></span>
<span id="cb20-14"><a href="#cb20-14"></a>        <span class="op">&lt;</span><span class="ex">script</span> language=<span class="st">&quot;javascript&quot;</span> src=<span class="st">&quot;all.js&quot;</span><span class="op">&gt;&lt;</span>/script<span class="op">&gt;</span></span>
<span id="cb20-15"><a href="#cb20-15"></a>      <span class="op">&lt;</span>/<span class="ex">head</span><span class="op">&gt;</span></span>
<span id="cb20-16"><a href="#cb20-16"></a>      <span class="op">&lt;</span><span class="ex">body</span><span class="op">&gt;</span></span>
<span id="cb20-17"><a href="#cb20-17"></a>      <span class="op">&lt;</span>/<span class="ex">body</span><span class="op">&gt;</span></span>
<span id="cb20-18"><a href="#cb20-18"></a>    <span class="op">&lt;</span>/<span class="ex">html</span><span class="op">&gt;</span></span>
<span id="cb20-19"><a href="#cb20-19"></a>  <span class="st">&#39;&#39;</span>;</span>
<span id="cb20-20"><a href="#cb20-20"></a><span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;glitch&quot;</span> {} <span class="st">&#39;&#39;</span></span>
<span id="cb20-21"><a href="#cb20-21"></a>  <span class="fu">mkdir</span> -p <span class="va">$out</span></span>
<span id="cb20-22"><a href="#cb20-22"></a>  <span class="fu">cp</span> <span class="va">${html}</span> <span class="va">$out</span>/index.html</span>
<span id="cb20-23"><a href="#cb20-23"></a>  <span class="va">${pkgs</span><span class="er">.closurecompiler</span><span class="va">}</span><span class="ex">/bin/closure-compiler</span> \</span>
<span id="cb20-24"><a href="#cb20-24"></a>    --externs=<span class="va">${project</span><span class="er">.ghcjs.small</span><span class="va">-</span>viz<span class="va">}</span>/bin/small-viz.jsexe/all.js.externs \</span>
<span id="cb20-25"><a href="#cb20-25"></a>    --jscomp_off=checkVars \</span>
<span id="cb20-26"><a href="#cb20-26"></a>    --js_output_file=<span class="st">&quot;</span><span class="va">$out</span><span class="st">/all.js&quot;</span> \</span>
<span id="cb20-27"><a href="#cb20-27"></a>    -O ADVANCED \</span>
<span id="cb20-28"><a href="#cb20-28"></a>    -W QUIET \</span>
<span id="cb20-29"><a href="#cb20-29"></a>    <span class="va">${project</span><span class="er">.ghcjs.small</span><span class="va">-</span>viz<span class="va">}</span>/bin/small-viz.jsexe/all.js</span>
<span id="cb20-30"><a href="#cb20-30"></a><span class="st">&#39;&#39;</span></span></code></pre></div>
</details>
<p><em>(<a href="https://gist.github.com/vaibhavsagar/24b1754b8a269fd8c54a89cb73e64fa8/aac5fe1258ccfc8c9b8ca685b9db1a4f538ae183#file-glitch-nix">revision</a>)</em></p>
<p>And this brings the size down to under 2MB.</p>
<p>I think this is a good stopping point. We’ve:</p>
<ol type="1">
<li>Built a frontend-only Reflex app</li>
<li>Integrated with a JavaScript library</li>
<li>Used the JSaddle FFI idiomatically</li>
<li>Deployed to Glitch</li>
</ol>
<p>and I hope I’ve convinced you to take a closer look at Haskell the next time you want to write something that runs in the browser.</p>
<p><em>Thanks to <a href="https://github.com/ali-abrar">Ali Abrar</a> and <a href="https://twitter.com/itsfarseen">Farseen Abdul Salam</a> for comments and feedback.</em></p>
</summary>
</entry>
<entry>
    <title>You Won’t Believe This One Weird CPU Instruction!</title>
    <link href="https://vaibhavsagar.com/blog/2019/09/08/popcount/" />
    <id>https://vaibhavsagar.com/blog/2019/09/08/popcount/index.html</id>
    <published>2019-09-08</published>
    <updated>2019-09-08T00:00:00Z</updated>
    <summary type="html"><div class="info">
    Posted on  8 September 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p><em>This is a pseudo-transcript of <a href="https://www.youtube.com/watch?v=bLFqLfz2Fmc">a presentation I did at !!Con 2019</a>.</em></p>
<p>Most CPU architectures in use today have an instruction called <code>popcount</code>, short for “population count”. Here’s what it does: it counts the number of set bits in a machine word. For example (assuming 8-bit words for simplicity), <code>popcount(00100110)</code> is <code>3</code> and <code>popcount(01100000)</code> is <code>2</code>.</p>
<p>You might be wondering, like I was, if there’s more to this instruction, but that’s all it does! This doesn’t seem very useful, right?</p>
<p>I thought this might be a recent addition for some hyperspecialised use case, but it has in fact been present in CPU architectures since at least 1961:</p>
<ul>
<li>1961: <a href="https://en.wikipedia.org/wiki/IBM_7030_Stretch">IBM Stretch</a></li>
<li>1964: <a href="https://en.wikipedia.org/wiki/CDC_6000_series">CDC 6000</a></li>
<li>1975: <a href="https://en.wikipedia.org/wiki/Cray-1">Cray-1</a></li>
<li>2005: <a href="https://en.wikipedia.org/wiki/SPARC">SPARC</a></li>
<li>2005: <a href="https://en.wikipedia.org/wiki/ARM_architecture#Advanced_SIMD_(NEON)">ARM NEON</a></li>
<li>2007: <a href="https://en.wikipedia.org/wiki/AMD_10h">AMD K10</a></li>
<li>2008: <a href="https://en.wikipedia.org/wiki/Nehalem_(microarchitecture)">Intel Nehalem</a></li>
</ul>
<p>So what’s going on?</p>
<h4 id="the-nsa-instruction">The NSA Instruction</h4>
<p><code>popcount</code> is also known as “The NSA Instruction”, and a <a href="https://groups.google.com/forum/#!msg/comp.arch/UXEi7G6WHuU/Z2z7fC7Xhr8J">very entertaining thread on <code>comp.arch</code></a> discusses its uses inside and outside cryptography. It is rumoured that it was originally added to CPU instructions at the behest of the NSA. As <a href="http://cryptome.org/jya/sadd.htm">this archived email thread</a> puts it:</p>
<blockquote>
<p>It was almost a tradition that one of the first of any new faster CDC machine was delivered to a “good customer” - picked up at the factory by an anonymous truck, and never heard from again.</p>
</blockquote>
<p>This makes for a great story, but what were they using it for?</p>
<p>One measure of information content is the <a href="https://en.wikipedia.org/wiki/Hamming_weight">Hamming weight</a>, which is the number of symbols in a string that are different from the zero-symbol of the alphabet. For a binary string, this is exactly <code>popcount</code>!</p>
<p><a href="http://www.talkchess.com/forum3/viewtopic.php?t=38521">As explained here</a>, the NSA wanted to do cryptanalysis on intercepted messages, and since the CDC 6000 had 60-bit words, one word was enough to store most alphabets they were interested in. They were able to:</p>
<ol type="1">
<li>Split a message into lines</li>
<li>Set a bit for each unique character they encountered per line</li>
<li>Use <code>popcount</code> to count the distinct characters</li>
<li>Use the count as a hash for further cryptanalysis</li>
</ol>
<p>Curiously, <code>popcount</code> seems to have disappeared from instruction sets between the mid-1970s and the mid-2000s, so there has to be more to it than cryptographic applications to explain its return. What else can it be used for?</p>
<h4 id="error-correction">Error Correction</h4>
<p>Related to the concept of Hamming weight is <a href="https://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a>, which is the number of differing positions between two strings of identical length. For two binary strings <code>x</code> and <code>y</code>, this is just the <code>popcount</code> of them XORed together. For example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1"></a>00100110</span>
<span id="cb1-2"><a href="#cb1-2"></a>01100000 ^</span>
<span id="cb1-3"><a href="#cb1-3"></a>--------</span>
<span id="cb1-4"><a href="#cb1-4"></a>01000110</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a>popcount(01000110) = 3</span></code></pre></div>
<p>For telecommunications applications, this helps us calculate the signal distance, where a known word is sent over the wire and the number of flipped bits are counted to provide an estimate of the error introduced by transmission.</p>
<p>We can then design an <a href="https://en.wikipedia.org/wiki/Hamming_distance#Error_detection_and_error_correction">error-correcting code</a> accordingly, e.g. if we want to be robust against up to 2 flipped bits, our code words need to differ in Hamming distance by at least 5.</p>
<h4 id="binary-convolutional-neural-networks">Binary Convolutional Neural Networks</h4>
<p>And now for something completely different: binary convolutional neural networks! But first, what are they?</p>
<ul>
<li>Binary means that we’re using matrices consisting of only the values +1 (coded as <code>1</code>) and -1 (coded as <code>0</code>), as opposed to 32-bit floating-point values.</li>
<li>Convolutional means matrix multiplication is involved?</li>
<li>Neural networks are systems inspired by animal brains (I’m a bit hazy on this part).</li>
</ul>
<p>In summary, we have to do binary matrix multiplication. But what’s special about binary matrices?</p>
<p>Ordinary matrix multiplication on 32-bit values is a good fit on desktop computers with powerful CPUs and GPUs, but increasingly we also want to do useful work on smaller and simpler devices, such as smartphones, routers, smartwatches, etc. We can decompose these more complex matrices into layers of binary matrices, and these resulting matrices are so much easier to store and operate on that we are better off even though there are more layers.</p>
<p>Where does <code>popcount</code> come into play? It’s used to calculate the dot product of two binary matrices:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb2-1"><a href="#cb2-1"></a>a = xnor(x, y)</span>
<span id="cb2-2"><a href="#cb2-2"></a>b = popcount(a)</span>
<span id="cb2-3"><a href="#cb2-3"></a>c = len(a)</span>
<span id="cb2-4"><a href="#cb2-4"></a>dot(x, y) = 2 × b − c</span></code></pre></div>
<p>More details are available <a href="https://sushscience.wordpress.com/2017/10/01/understanding-binary-neural-networks/">here</a> and <a href="https://developer.apple.com/documentation/metalperformanceshaders/mpscnnbinaryconvolution">here</a>.</p>
<h4 id="chess-programming">Chess Programming</h4>
<p>Many chess programs store data using a <a href="https://www.chessprogramming.org/Bitboards">bitboard</a> representation, which conveniently fits into a 64-bit word. <a href="https://www.chessprogramming.org/Population_Count">Population Count</a> has been used to perform meaningful operations with this representation, such as calculating the <a href="https://www.chessprogramming.org/Mobility#Mobility_with_Bitboards">mobility</a> of a piece.</p>
<h4 id="molecular-fingerprinting">Molecular Fingerprinting</h4>
<p>This is related to the notion of Hamming distance above: molecules are hashed in some way and compared (with <code>popcount</code>) to determine how similar they are. More details on that <a href="http://www.dalkescientific.com/writings/diary/archive/2008/06/26/fingerprint_background.html">here</a>.</p>
<h4 id="hash-array-mapped-tries">Hash Array Mapped Tries</h4>
<p>This is where I first learned about <code>popcount</code>! The HAMT is a data structure (<a href="https://lampwww.epfl.ch/papers/idealhashtrees.pdf">pioneered by Phil Bagwell</a>) that can store a very large number of values (usually 32 or 64) in an array at each node of the trie. However, allocating memory for a 32 or 64-element array every time can be incredibly wasteful, especially if the array only actually contains a handful of elements. The solution is to add a bitmask in which the number of bits that are set corresponds to the number of elements in the array, which allows the array to grow and shrink as required. Calculating the index for a given element efficiently can then be done using <code>popcount</code>. You can learn more about how they work from <a href="/blog/2018/07/29/hamts-from-scratch/">this blog post</a>, where I implement them myself.</p>
<h4 id="succinct-data-structures">Succinct Data Structures</h4>
<p>This is an exciting new area of research that focuses on how to store data in as little space as possible, without having to decompress it in order to do useful work. One technique is to think in terms of arrays of bits (bitvectors), which can be queried using two operations:</p>
<ul>
<li><code>rank(i)</code> counts the number of bits set upto the <code>i</code>th index in the bitvector</li>
<li><code>select(i)</code> finds the index where the <code>i</code>th ranked bit is set</li>
</ul>
<p>Making these operations efficient on large bitvectors requires constructing an index and using it effectively, both involving <code>popcount</code>. There’s <a href="https://alexbowe.com/rrr/">a good overview of the RRR index here</a>, and as far as I can tell the current state-of-the-art approach is described in <a href="http://www.cs.cmu.edu/~./dga/papers/zhou-sea2013.pdf">Space-Efficient, High-Performance Rank &amp; Select Structures on Uncompressed Bit Sequences</a>.</p>
<h4 id="compiler-optimisations">Compiler Optimisations</h4>
<p><code>popcount</code> has become so pervasive that both <a href="https://godbolt.org/z/JUzmD8">GCC</a> and <a href="https://godbolt.org/z/AVqMGl">Clang</a> will detect an implementation of <code>popcount</code> and replace it with the built-in instruction. Imagine Clippy going “I see you are trying to implement <code>popcount</code>, let me go ahead and fix that for you”! The relevant LLVM code is <a href="https://github.com/llvm-mirror/llvm/blob/f36485f7ac2a8d72ad0e0f2134c17fd365272285/lib/Transforms/Scalar/LoopIdiomRecognize.cpp#L960">here</a>. Daniel Lemire points to this as an example of <a href="https://lemire.me/blog/2016/05/23/the-surprising-cleverness-of-modern-compilers/">the surprising cleverness of modern compilers</a>.</p>
<h4 id="conclusion">Conclusion</h4>
<p>From beginnings shrouded in mystery, <code>popcount</code> has emerged as a generally useful, if slightly unusual, CPU instruction. I love how it ties together such different fields of computing, and I wonder how many other similarly weird instructions are out there. If you have a favourite, I’d love to hear about it!</p>
</summary>
</entry>
<entry>
    <title>Industrial-strength Deployments in Three Commands</title>
    <link href="https://vaibhavsagar.com/blog/2019/08/22/industrial-strength-deployments/" />
    <id>https://vaibhavsagar.com/blog/2019/08/22/industrial-strength-deployments/index.html</id>
    <published>2019-08-22</published>
    <updated>2019-08-22T00:00:00Z</updated>
    <summary type="html"><div class="info">
    Posted on 22 August 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/nix/index.html">nix</a>, <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/devops/index.html">devops</a>
    
</div>

<p>If your deployment target is running NixOS, a full-system deployment is only three commands:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a>$ <span class="ex">nix-copy-closure</span> --to --use-substitutes <span class="op">&lt;</span>target<span class="op">&gt;</span> <span class="op">&lt;</span>path<span class="op">&gt;</span>                                <span class="co">#1</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>$ <span class="fu">ssh</span> <span class="op">&lt;</span>target<span class="op">&gt;</span> -- <span class="st">&quot;sudo nix-env --profile /nix/var/nix/profiles/system --set &lt;path&gt;&quot;</span>     <span class="co">#2</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>$ <span class="fu">ssh</span> <span class="op">&lt;</span>target<span class="op">&gt;</span> -- <span class="st">&quot;sudo /nix/var/nix/profiles/system/bin/switch-to-configuration switch&quot;</span> <span class="co">#3</span></span></code></pre></div>
<p>Here’s what each command does:</p>
<ol type="1">
<li>Copies the transitive closure of the new system configuration to the target, using binary caches (<code>--use-substitutes</code>) where possible.</li>
<li>Sets the current system profile to the new system configuration. This isn’t strictly necessary, but allows us to roll back to this configuration later.</li>
<li>Switches to the new system configuration.</li>
</ol>
<p>This workflow has been described before <a href="https://typeclasses.com/nixos-on-aws">in Typeclasses</a> and <a href="http://www.haskellforall.com/2018/08/nixos-in-production.html">by Gabriel Gonzalez</a>, but I thought one more post demonstrating how to use these commands wouldn’t hurt. Since the AWS use case has been covered so thoroughly by Typeclasses, I’m going to use the <a href="https://www.packet.com/">packet.net</a> cloud instead.</p>
<h4 id="provisioning">Provisioning</h4>
<p>I logged on to the Packet console and launched a <code>t1.small.x86</code> instance running NixOS 19.03 (the latest as of this writing). It was assigned the IP address <code>147.75.38.113</code>. Since I added my SSH keys when I first created my Packet account, I was able to SSH into this instance at <code>root@147.75.38.113</code> without any further configuration.</p>
<h4 id="copying-the-existing-configuration">Copying the existing configuration</h4>
<p>The next step is to copy the existing configuration, especially instance-specific hardware configuration:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a>$ <span class="fu">scp</span> -r root@147.75.38.113:/etc/nixos/* .</span></code></pre></div>
<p>There’s probably a better way to do this, but for a quick one-off demonstration this is fine. <a href="https://github.com/vaibhavsagar/nixos-config/commit/e49e9a980f2d547684bcab3a34a34dba4521b991">Here’s the commit adding those files</a>.</p>
<p>We’ll only be making changes to <code>configuration.nix</code>, which for me looks like this (after all commented-out lines have been removed):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">{</span> <span class="ex">config</span>, pkgs, ... <span class="kw">}</span>:</span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">{</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="ex">imports</span> =</span>
<span id="cb3-5"><a href="#cb3-5"></a>    [</span>
<span id="cb3-6"><a href="#cb3-6"></a>      <span class="ex">./packet.nix</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    ];</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a>  <span class="ex">boot.loader.grub.enable</span> = true<span class="kw">;</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>  <span class="ex">boot.loader.grub.version</span> = 2<span class="kw">;</span></span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a>  <span class="ex">system.stateVersion</span> = <span class="st">&quot;19.03&quot;</span><span class="kw">;</span></span>
<span id="cb3-13"><a href="#cb3-13"></a></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="kw">}</span></span></code></pre></div>
<h4 id="building-a-system-closure">Building a system closure</h4>
<p>The Nix expression to build a whole system is pretty straightforward (as described in the Typeclasses article):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a><span class="bu">let</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="ex">nixos</span> = import <span class="op">&lt;</span>nixpkgs/nixos<span class="op">&gt;</span> {</span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="ex">configuration</span> = import ./configuration.nix<span class="kw">;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  };</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">in</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="ex">nixos.system</span></span></code></pre></div>
<p>but this doesn’t provide any way of pinning <code>nixpkgs</code>. Another way (<a href="http://www.haskellforall.com/2018/08/nixos-in-production.html#pinning-nixpkgs">as described by Gabriel Gonzalez</a>), is to explicitly depend on a particular revision of <code>nixpkgs</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1"></a><span class="bu">let</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="ex">nixpkgs</span> = builtins.fetchTarball {</span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="ex">url</span> = <span class="st">&quot;https://github.com/NixOS/nixpkgs/archive/b74b1cdb2fecc31ff7a127c5bc89771f887c93bb.tar.gz&quot;</span><span class="kw">;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="ex">sha256</span> = <span class="st">&quot;0ncr4g29220amqm4riaa1xf4jz55v2nmh9fi16f1gzhww1gplk8h&quot;</span><span class="kw">;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  };</span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="kw">in</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>  <span class="ex">import</span> <span class="st">&quot;</span><span class="va">${nixpkgs}</span><span class="st">/nixos&quot;</span> {</span>
<span id="cb5-9"><a href="#cb5-9"></a>    <span class="ex">configuration</span> = {</span>
<span id="cb5-10"><a href="#cb5-10"></a>      <span class="ex">imports</span> = [</span>
<span id="cb5-11"><a href="#cb5-11"></a>        <span class="ex">/etc/nixos/configuration.nix</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>      ];</span>
<span id="cb5-13"><a href="#cb5-13"></a>    };</span>
<span id="cb5-14"><a href="#cb5-14"></a></span>
<span id="cb5-15"><a href="#cb5-15"></a>    <span class="ex">system</span> = <span class="st">&quot;x86_64-linux&quot;</span><span class="kw">;</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>  }</span></code></pre></div>
<p>but the downside there is that there’s no automated way to update the revision of <code>nixpkgs</code>. I have <a href="/blog/2018/05/27/quick-easy-nixpkgs-pinning/">my own approach to pinning <code>nixpkgs</code></a>, where I have a <code>versions.json</code> that stores version information:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb6-1"><a href="#cb6-1"></a><span class="fu">{</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="dt">&quot;nixpkgs&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="dt">&quot;owner&quot;</span><span class="fu">:</span> <span class="st">&quot;NixOS&quot;</span><span class="fu">,</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="dt">&quot;repo&quot;</span><span class="fu">:</span> <span class="st">&quot;nixpkgs-channels&quot;</span><span class="fu">,</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="dt">&quot;branch&quot;</span><span class="fu">:</span> <span class="st">&quot;nixos-19.03&quot;</span><span class="fu">,</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="dt">&quot;rev&quot;</span><span class="fu">:</span> <span class="st">&quot;77295b0bd26555c39a1ba9c1da72dbdb651fd280&quot;</span><span class="fu">,</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>    <span class="dt">&quot;sha256&quot;</span><span class="fu">:</span> <span class="st">&quot;18v866h12xk6l1s37nk1vns869pvzphmnnlhrnm2b1zklg2hd1nq&quot;</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>  <span class="fu">}</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="fu">}</span></span></code></pre></div>
<p>and a script that uses <code>jq</code> to update this file. My (slightly more complex) expression then looks like this:</p>
<p><em>default.nix</em></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1"></a><span class="bu">let</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  <span class="ex">fetcher</span> = { owner, repo, rev, sha256, ... }: <span class="ex">builtins.fetchTarball</span> {</span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="ex">inherit</span> sha256<span class="kw">;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="ex">url</span> = <span class="st">&quot;https://github.com/</span><span class="va">${owner}</span><span class="st">/</span><span class="va">${repo}</span><span class="st">/tarball/</span><span class="va">${rev}</span><span class="st">&quot;</span><span class="kw">;</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>  };</span>
<span id="cb7-6"><a href="#cb7-6"></a>  <span class="ex">nixpkgs</span> = fetcher (builtins.fromJSON (builtins.readFile ./versions.json))<span class="ex">.nixpkgs</span><span class="kw">;</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>  <span class="ex">nixos</span> = import <span class="st">&quot;</span><span class="va">${nixpkgs}</span><span class="st">/nixos&quot;</span> {</span>
<span id="cb7-8"><a href="#cb7-8"></a>    <span class="ex">configuration</span> = import ./configuration.nix<span class="kw">;</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>  };</span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw">in</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>  <span class="ex">nixos.system</span></span></code></pre></div>
<p>and this allows me to both be explicit about <code>nixpkgs</code> as well as easily update it when necessary. <a href="https://github.com/vaibhavsagar/nixos-config/commit/5126d9dba971d6480aeec43c4263c5a7f7b1f1b5">Here’s the commit that adds those files</a>.</p>
<p>Building the closure locally is also straightforward (as described <a href="https://typeclasses.com/nixos-on-aws#building-nixos-locally">here</a>):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1"></a>$ <span class="ex">nix-build</span> --no-out-link default.nix</span></code></pre></div>
<h4 id="deploying-the-system-closure">Deploying the system closure</h4>
<p>With all of our prerequisites taken care of, deploying the system closure is straightforward:</p>
<p><em>deploy.sh</em></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">#!/usr/bin/env bash</span></span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">set</span> <span class="ex">-euxo</span> pipefail</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="va">TARGET=</span><span class="st">&quot;root@147.75.38.113&quot;</span></span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="va">PROFILE_PATH=</span><span class="st">&quot;</span><span class="va">$(</span><span class="ex">nix-build</span> --no-out-link default.nix<span class="va">)</span><span class="st">&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="ex">nix-copy-closure</span> --to --use-substitutes <span class="va">$TARGET</span> <span class="va">$PROFILE_PATH</span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="fu">ssh</span> <span class="va">$TARGET</span> -- <span class="st">&quot;nix-env --profile /nix/var/nix/profiles/system --set </span><span class="va">$PROFILE_PATH</span><span class="st"> &amp;&amp; /nix/var/nix/profiles/system/bin/switch-to-configuration switch&quot;</span></span></code></pre></div>
<p>This takes care of both building the new system closure and deploying it.</p>
<p><a href="https://github.com/vaibhavsagar/nixos-config/commit/be6aaa026c8ebf1efd7c44743a8770b921111a2e">Here’s the commit that adds <code>deploy.sh</code></a>.</p>
<h4 id="adding-a-service">Adding a service</h4>
<p>Let’s deploy the final version of the small Haskell web service from my <a href="/blog/2019/07/04/functional-devops/">Functional DevOps</a> post. The application consists of two files:</p>
<p><em>Main.hs</em></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a> <span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">import</span> <span class="dt">Web.Scotty</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span> (mconcat)</span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a>main <span class="ot">=</span> getArgs <span class="op">&gt;&gt;=</span> \(port<span class="op">:</span>_) <span class="ot">-&gt;</span> scotty (<span class="fu">read</span> port) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>    get <span class="st">&quot;/:word&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>        beam <span class="ot">&lt;-</span> param <span class="st">&quot;word&quot;</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>        html <span class="op">$</span> <span class="fu">mconcat</span> [<span class="st">&quot;&lt;h1&gt;Scotty, &quot;</span>, beam, <span class="st">&quot; me up!&lt;/h1&gt;&quot;</span>]</span></code></pre></div>
<p><em>blank-me-up.cabal</em></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb11-1"><a href="#cb11-1"></a>name:                blank-me-up</span>
<span id="cb11-2"><a href="#cb11-2"></a>version:             0.1.0.0</span>
<span id="cb11-3"><a href="#cb11-3"></a>license:             BSD3</span>
<span id="cb11-4"><a href="#cb11-4"></a>build-type:          Simple</span>
<span id="cb11-5"><a href="#cb11-5"></a>cabal-version:       &gt;=1.10</span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a>executable blank-me-up</span>
<span id="cb11-8"><a href="#cb11-8"></a>  main-is:             Main.hs</span>
<span id="cb11-9"><a href="#cb11-9"></a>  build-depends:       base &gt;=4.9 &amp;&amp; &lt;5</span>
<span id="cb11-10"><a href="#cb11-10"></a>                     , scotty</span>
<span id="cb11-11"><a href="#cb11-11"></a>  default-language:    Haskell2010</span></code></pre></div>
<p>and the Nix service is one file:</p>
<p><em>service.nix</em></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">{</span> <span class="ex">config</span>, lib, pkgs, ... <span class="kw">}</span>:</span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="bu">let</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>  <span class="ex">blank-me-up</span> = pkgs.haskellPackages.callCabal2nix <span class="st">&quot;blank-me-up&quot;</span> ../app {};</span>
<span id="cb12-5"><a href="#cb12-5"></a>  <span class="ex">cfg</span> = config.services.blank-me-up<span class="kw">;</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="kw">in</span> <span class="kw">{</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>  <span class="ex">options.services.blank-me-up.enable</span> = lib.mkEnableOption <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>  <span class="ex">options.services.blank-me-up.port</span> = lib.mkOption {</span>
<span id="cb12-9"><a href="#cb12-9"></a>    <span class="ex">default</span> = 3000<span class="kw">;</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>    <span class="bu">type</span> = lib.types.int<span class="kw">;</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>  <span class="kw">}</span>;</span>
<span id="cb12-12"><a href="#cb12-12"></a></span>
<span id="cb12-13"><a href="#cb12-13"></a>  <span class="ex">config</span> = lib.mkIf cfg.enable {</span>
<span id="cb12-14"><a href="#cb12-14"></a>    <span class="ex">networking.firewall.allowedTCPPorts</span> = [ cfg.port ]<span class="kw">;</span></span>
<span id="cb12-15"><a href="#cb12-15"></a></span>
<span id="cb12-16"><a href="#cb12-16"></a>    <span class="ex">systemd.services.blank-me-up</span> = {</span>
<span id="cb12-17"><a href="#cb12-17"></a>      <span class="ex">description</span> = <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span></span>
<span id="cb12-18"><a href="#cb12-18"></a>      <span class="ex">after</span> = [ <span class="st">&quot;network.target&quot;</span> ]<span class="kw">;</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>      <span class="ex">wantedBy</span> = [ <span class="st">&quot;multi-user.target&quot;</span> ]<span class="kw">;</span></span>
<span id="cb12-20"><a href="#cb12-20"></a>      <span class="ex">serviceConfig</span> = {</span>
<span id="cb12-21"><a href="#cb12-21"></a>        <span class="ex">ExecStart</span> = <span class="st">&quot;</span><span class="va">${blank-</span>me-up<span class="va">}</span><span class="st">/bin/blank-me-up </span><span class="va">${toString</span><span class="er"> cfg.port</span><span class="va">}</span><span class="st">&quot;</span><span class="kw">;</span></span>
<span id="cb12-22"><a href="#cb12-22"></a>        <span class="ex">Restart</span> = <span class="st">&quot;always&quot;</span><span class="kw">;</span></span>
<span id="cb12-23"><a href="#cb12-23"></a>        <span class="ex">KillMode</span> = <span class="st">&quot;process&quot;</span><span class="kw">;</span></span>
<span id="cb12-24"><a href="#cb12-24"></a>      };</span>
<span id="cb12-25"><a href="#cb12-25"></a>    };</span>
<span id="cb12-26"><a href="#cb12-26"></a>  };</span>
<span id="cb12-27"><a href="#cb12-27"></a>}</span></code></pre></div>
<p>For more information about what’s happening in <code>service.nix</code>, see <a href="/blog/2019/07/04/functional-devops/#service-configuration">the relevant section of my Functional DevOps post</a>.</p>
<p><a href="https://github.com/vaibhavsagar/nixos-config/commit/466e0e1867e47346ed8cc706b812a8cb21c76c19">Here’s the commit that adds these files</a>.</p>
<p>Enabling the service is as easy as adding two lines to <code>configuration.nix</code>:</p>
<p><em>configuration.nix</em></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">{</span> <span class="ex">config</span>, pkgs, ... <span class="kw">}</span>:</span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">{</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>  <span class="ex">imports</span> =</span>
<span id="cb13-5"><a href="#cb13-5"></a>    [</span>
<span id="cb13-6"><a href="#cb13-6"></a>      <span class="ex">./packet.nix</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>      <span class="ex">./deploy/nix/service.nix</span>        <span class="co">#1</span></span>
<span id="cb13-8"><a href="#cb13-8"></a>    ];</span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a>  <span class="ex">boot.loader.grub.enable</span> = true<span class="kw">;</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>  <span class="ex">boot.loader.grub.version</span> = 2<span class="kw">;</span></span>
<span id="cb13-12"><a href="#cb13-12"></a></span>
<span id="cb13-13"><a href="#cb13-13"></a>  <span class="ex">services.blank-me-up.enable</span> = true<span class="kw">;</span> <span class="co">#2</span></span>
<span id="cb13-14"><a href="#cb13-14"></a></span>
<span id="cb13-15"><a href="#cb13-15"></a>  <span class="ex">system.stateVersion</span> = <span class="st">&quot;19.03&quot;</span><span class="kw">;</span></span>
<span id="cb13-16"><a href="#cb13-16"></a></span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="kw">}</span></span></code></pre></div>
<p><a href="https://github.com/vaibhavsagar/nixos-config/commit/07b163f3c0fe728078bb357841e57c7020bdd4d3">Here’s the commit that makes that change</a>.</p>
<h4 id="deploying-the-service">Deploying the service</h4>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1"></a>$ <span class="ex">./deploy.sh</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="ex">+</span> TARGET=root@147.75.38.113</span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="ex">++</span> nix-build --no-out-link default.nix</span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="ex">+</span> PROFILE_PATH=/nix/store/<span class="op">&lt;</span>hash<span class="op">&gt;</span>-nixos-system-nixos-19.03pre-git</span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="ex">+</span> nix-copy-closure --to --use-substitutes root@147.75.38.113 /nix/store/<span class="op">&lt;</span>hash<span class="op">&gt;</span>-nixos-system-nixos-19.03pre-git</span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="ex">+</span> ssh root@147.75.38.113 -- <span class="st">&#39;nix-env --profile /nix/var/nix/profiles/system --set /nix/store/&lt;hash&gt;-nixos-system-nixos-19.03pre-git &amp;&amp; /nix/var/nix/profiles/system/bin/switch-to-configuration switch&#39;</span></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="ex">updating</span> GRUB 2 menu...</span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="ex">activating</span> the configuration...</span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="ex">setting</span> up /etc...</span>
<span id="cb14-11"><a href="#cb14-11"></a><span class="ex">reloading</span> user units for root...</span>
<span id="cb14-12"><a href="#cb14-12"></a><span class="ex">setting</span> up tmpfiles</span>
<span id="cb14-13"><a href="#cb14-13"></a></span>
<span id="cb14-14"><a href="#cb14-14"></a>$ <span class="ex">curl</span> http://147.75.38.113:3000/beam</span>
<span id="cb14-15"><a href="#cb14-15"></a><span class="op">&lt;</span><span class="ex">h1</span><span class="op">&gt;</span>Scotty, beam me up!<span class="op">&lt;</span>/h1<span class="op">&gt;</span></span></code></pre></div>
<h4 id="but-this-is-just-a-janky-bash-script">But this is just a janky bash script!!???</h4>
<p>It’s definitely the case that <code>deploy.sh</code> is short and unsophisticated, but the three commands it invokes are what’s really important here. Once you begin looking for them, you will find them everywhere, since they’re the best way of deploying to NixOS! They’re used in <a href="https://github.com/NixOS/nixops/blob/c8d3a3ff5fb20e8e4d494de972ebb2a1a1ec1e08/nixops/backends/__init__.py#L339-L367">NixOps</a>, <a href="https://github.com/awakesecurity/nix-deploy/blob/68217cea7ba6746c9a262ddccb11178909841988/src/Main.hs#L159-L229">nix-deploy</a>, and <a href="https://github.com/obsidiansystems/obelisk/blob/1f9f466fc38a37a72afb316cee4f3317af204220/lib/command/src/Obelisk/Command/Deploy.hs#L136-L158">obelisk</a>, and a quick GitHub search for <a href="https://github.com/search?q=switch-to-configuration&amp;type=Code">“switch-to-configuration”</a> turns up many more examples. At a previous job, our deployment platform used these three commands as well, and we routinely deployed to hundreds of servers without any deployment-related issues, so I’m comfortable saying that this is an industrial-grade deployment solution.</p>
<h4 id="what-about-provisioning">What about provisioning?</h4>
<p>These tools don’t care how you provision your servers, as long as you end up with NixOS targets you can SSH into. For quick demonstrations and small deployments, manual provisioning is fine, but for anything beyond that, I’d recommend using a tool like <a href="https://www.terraform.io/">Terraform</a>. You can even specify your Terraform configuration with Nix using something like <a href="https://github.com/mrVanDalo/terranix">terranix</a>, and this is in fact what we did at the previous job I mentioned earlier, since Nix makes a great templating language and comes with excellent support for producing JSON which can then be fed into Terraform. It’s also possible to output YAML from Nix, which means it’s easy to interoperate with most infrastructure tooling.</p>
<h4 id="should-i-use-this-instead-of-my-current-deployment-solution">Should I use this instead of my current deployment solution?</h4>
<p>My aim with this post is not to convince you to drop whatever you’re currently using in favour of a hand-rolled bash script and NixOS, especially if your current solution works well for you. I do, however, want to encourage you to think about how the process I’ve outlined here compares. In which ways is it better or worse?</p>
<p>Since this is the workflow I’ve had the most experience with, it was a rude shock to start working with container-based deployments where even tiny changes require a full (slow) rebuild, and the actual deployment lifecycle is more complex and error-prone. I think it’s important to point out that things don’t have to be this way.</p>
<p>In my <a href="/blog/2019/07/04/functional-devops/">Functional DevOps</a> post, I outlined some characteristics of an ideal DevOps workflow, and I think the process I’ve outlined here meets them all:</p>
<ul>
<li><strong>Automatic</strong>: The process is completely scriptable.</li>
<li><strong>Repeatable</strong>: I can leverage NixOS to get the same results every time.</li>
<li><strong>Idempotent</strong>: Deploying the same thing a second time is a no-op.</li>
<li><strong>Reversible</strong>: Rolling back is very easy.</li>
<li><strong>Atomic</strong>: A deploy either fails or succeeds, there’s no weird in-between<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</li>
</ul>
<p>I think this is pretty great for three commands. I hope this blog post can help move us towards better systems by making this corner of NixOS more approachable!</p>
<p><em>Thanks to <a href="https://www.brianthicks.com/">Brian Hicks</a> for comments and feedback!</em></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>As <a href="https://www.reddit.com/r/NixOS/comments/ctx8ii/industrialstrength_deployments_in_three_commands/expfqpv">ElvishJerricco points out on Reddit</a>, this isn’t quite true in the case of broken services.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</summary>
</entry>
<entry>
    <title>Easy IHaskell Docker Images with Nix</title>
    <link href="https://vaibhavsagar.com/blog/2019/08/11/ihaskell-nix-docker/" />
    <id>https://vaibhavsagar.com/blog/2019/08/11/ihaskell-nix-docker/index.html</id>
    <published>2019-08-11</published>
    <updated>2019-08-11T00:00:00Z</updated>
    <summary type="html"><div class="info">
    Posted on 11 August 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/nix/index.html">nix</a>
    
</div>

<p>Today I learned how to turn an IHaskell Nix expression into a Docker image. Here is an example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># default.nix</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="bu">let</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="ex">pkgs</span> = {</span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="ex">ihaskell</span> = builtins.fetchTarball {</span>
<span id="cb1-5"><a href="#cb1-5"></a>      <span class="ex">url</span> = <span class="st">&quot;https://github.com/gibiansky/IHaskell/tarball/93bfa3a7a434c1dfe6873c2105c43856c282e183&quot;</span><span class="kw">;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>      <span class="ex">sha256</span> = <span class="st">&quot;1cvqqmpvz7s3d7zclmkm5igx36clrbdiafs47i9rik3rdzw0gr3d&quot;</span><span class="kw">;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>    };</span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="ex">nixpkgs</span> = builtins.fetchTarball {</span>
<span id="cb1-9"><a href="#cb1-9"></a>      <span class="ex">url</span> = <span class="st">&quot;https://github.com/NixOS/nixpkgs-channels/tarball/9ca57dc9171ca4547abf076a8987ed73c46f2e15&quot;</span><span class="kw">;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>      <span class="ex">sha256</span> = <span class="st">&quot;18d01cw6s6k9fnac3vq0k6inybqalkz4ak88pw67q4wqzq9rc07l&quot;</span><span class="kw">;</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>    };</span>
<span id="cb1-12"><a href="#cb1-12"></a>  };</span>
<span id="cb1-13"><a href="#cb1-13"></a>  <span class="ex">nixpkgs</span> = import pkgs.nixpkgs {};</span>
<span id="cb1-14"><a href="#cb1-14"></a>  <span class="ex">NB_USER</span> = <span class="st">&quot;jovyan&quot;</span><span class="kw">;</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>  <span class="ex">NB_UID</span> = <span class="st">&quot;1000&quot;</span><span class="kw">;</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>  <span class="ex">dockerEtc</span> = nixpkgs.runCommand <span class="st">&quot;docker-etc&quot;</span> {} <span class="st">&#39;&#39;</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    <span class="fu">mkdir</span> -p <span class="va">$out</span>/etc/pam.d</span>
<span id="cb1-18"><a href="#cb1-18"></a></span>
<span id="cb1-19"><a href="#cb1-19"></a>    <span class="bu">echo</span> <span class="st">&quot;root:x:0:0::/root:/bin/sh&quot;</span> <span class="op">&gt;</span> <span class="va">$out</span>/etc/passwd</span>
<span id="cb1-20"><a href="#cb1-20"></a>    <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">${NB_USER}</span><span class="st">:x:1000:1000::/home/</span><span class="va">${NB_USER}</span><span class="st">:&quot;</span> <span class="op">&gt;&gt;</span> <span class="va">$out</span>/etc/passwd</span>
<span id="cb1-21"><a href="#cb1-21"></a>    <span class="bu">echo</span> <span class="st">&quot;root:!x:::::::&quot;</span> <span class="op">&gt;</span> <span class="va">$out</span>/etc/shadow</span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">${NB_USER}</span><span class="st">:!:::::::&quot;</span> <span class="op">&gt;&gt;</span> <span class="va">$out</span>/etc/shadow</span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a>    <span class="bu">echo</span> <span class="st">&quot;root:x:0:&quot;</span> <span class="op">&gt;</span> <span class="va">$out</span>/etc/group</span>
<span id="cb1-25"><a href="#cb1-25"></a>    <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">${NB_USER}</span><span class="st">:x:1000:&quot;</span> <span class="op">&gt;&gt;</span> <span class="va">$out</span>/etc/group</span>
<span id="cb1-26"><a href="#cb1-26"></a>    <span class="bu">echo</span> <span class="st">&quot;root:x::&quot;</span> <span class="op">&gt;</span> <span class="va">$out</span>/etc/gshadow</span>
<span id="cb1-27"><a href="#cb1-27"></a>    <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">${NB_USER}</span><span class="st">:!::&quot;</span> <span class="op">&gt;&gt;</span> <span class="va">$out</span>/etc/gshadow</span>
<span id="cb1-28"><a href="#cb1-28"></a>  <span class="st">&#39;&#39;</span>;</span>
<span id="cb1-29"><a href="#cb1-29"></a>  <span class="ex">ihaskell</span> = import <span class="st">&quot;</span><span class="va">${pkgs</span><span class="er">.ihaskell</span><span class="va">}</span><span class="st">/release.nix&quot;</span> {</span>
<span id="cb1-30"><a href="#cb1-30"></a>    <span class="ex">inherit</span> nixpkgs<span class="kw">;</span></span>
<span id="cb1-31"><a href="#cb1-31"></a>    <span class="ex">compiler</span> = <span class="st">&quot;ghc864&quot;</span><span class="kw">;</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>    <span class="ex">packages</span> = self: with self<span class="kw">;</span> [];</span>
<span id="cb1-33"><a href="#cb1-33"></a>  };</span>
<span id="cb1-34"><a href="#cb1-34"></a><span class="kw">in</span> <span class="ex">nixpkgs.dockerTools.buildLayeredImage</span> {</span>
<span id="cb1-35"><a href="#cb1-35"></a>    <span class="ex">name</span> = <span class="st">&quot;ihaskell-nix&quot;</span><span class="kw">;</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>    <span class="ex">tag</span> = <span class="st">&quot;latest&quot;</span><span class="kw">;</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>    <span class="ex">contents</span> =  [</span>
<span id="cb1-38"><a href="#cb1-38"></a>      <span class="ex">dockerEtc</span></span>
<span id="cb1-39"><a href="#cb1-39"></a>      <span class="ex">ihaskell</span></span>
<span id="cb1-40"><a href="#cb1-40"></a>      <span class="ex">nixpkgs.bashInteractive</span></span>
<span id="cb1-41"><a href="#cb1-41"></a>    ];</span>
<span id="cb1-42"><a href="#cb1-42"></a>    <span class="ex">config</span> = {</span>
<span id="cb1-43"><a href="#cb1-43"></a>      <span class="ex">Cmd</span> = [<span class="st">&quot;ihaskell-notebook&quot;</span> <span class="st">&quot;--ip&quot;</span> <span class="st">&quot;0.0.0.0&quot;</span>]<span class="kw">;</span></span>
<span id="cb1-44"><a href="#cb1-44"></a>      <span class="ex">User</span> = NB_USER<span class="kw">;</span></span>
<span id="cb1-45"><a href="#cb1-45"></a>      <span class="ex">WorkingDir</span> = <span class="st">&quot;/home/</span><span class="va">${NB_USER}</span><span class="st">&quot;</span><span class="kw">;</span></span>
<span id="cb1-46"><a href="#cb1-46"></a>    };</span>
<span id="cb1-47"><a href="#cb1-47"></a>    <span class="ex">extraCommands</span> = <span class="st">&#39;&#39;</span></span>
<span id="cb1-48"><a href="#cb1-48"></a>      <span class="fu">mkdir</span> -m 1777 ./tmp</span>
<span id="cb1-49"><a href="#cb1-49"></a>      <span class="fu">mkdir</span> -m 777 -p ./home/<span class="va">${NB_USER}</span></span>
<span id="cb1-50"><a href="#cb1-50"></a>    <span class="st">&#39;&#39;</span>;</span>
<span id="cb1-51"><a href="#cb1-51"></a>    <span class="ex">maxLayers</span> = 100<span class="kw">;</span></span>
<span id="cb1-52"><a href="#cb1-52"></a>};</span></code></pre></div>
<p>This is how to use it:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a>$ <span class="ex">docker</span> load <span class="op">&lt;</span> <span class="va">$(</span><span class="ex">nix-build</span> default.nix<span class="va">)</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>$ <span class="ex">docker</span> run -p8888:8888 -it ihaskell-nix:latest</span></code></pre></div>
<p>This uses IHaskell’s <a href="https://github.com/gibiansky/IHaskell/blob/93bfa3a7a434c1dfe6873c2105c43856c282e183/release.nix">built-in <code>release.nix</code></a> to do most of the heavy lifting for IHaskell itself, and does a couple of other things:</p>
<ol type="1">
<li>Creates the <code>/tmp</code> directory</li>
<li>Sets up a <code>jovyan</code> user, because Jupyter complains when run as <code>root</code></li>
<li>Includes <code>bash</code>, which is not strictly necessary but is useful for poking around in the image and for using <code>:!</code> from within a notebook</li>
</ol>
<p>Building the image and loading it into Docker are both very slow compared to using Nix directly (even though I’m using the Nix support for layered images), so I wouldn’t recommend using this approach for local development. I’m primarily interested in doing this to:</p>
<ol type="1">
<li>Share IHaskell notebooks with people who are less comfortable with Nix</li>
<li>Deploy to platforms such as Amazon’s Elastic Container Service and Google’s App Engine, which offer excellent support for Docker and no support for Nix</li>
</ol>
<p>Unfortunately this isn’t quite ready to deploy yet, especially because Jupyter uses token-based authentication by default and the console output will not necessarily be available after deployment. It’s possible to set a password instead, so I expect that copying the output of <code>jupyter notebook --generate-config</code> and changing the relevant settings will be enough. I hope to post instructions when I get around to trying this myself.</p>
<p>In the meantime, I hope this is useful as a way of making IHaskell even more widely available, and as a demonstration of using <code>dockerTools</code> to bridge the gap between Nix and Docker!</p>
<p><em>Thanks to <a href="https://grahamc.com">Graham Christensen</a> for improving the Nix expression to use <code>buildLayeredImage</code>.</em></p>
</summary>
</entry>
<entry>
    <title>Functional DevOps in a Dysfunctional World</title>
    <link href="https://vaibhavsagar.com/blog/2019/07/04/functional-devops/" />
    <id>https://vaibhavsagar.com/blog/2019/07/04/functional-devops/index.html</id>
    <published>2019-07-04</published>
    <updated>2019-07-04T00:00:00Z</updated>
    <summary type="html"><div class="info">
    Posted on  4 July 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/nix/index.html">nix</a>, <a href="/blog/tags/devops/index.html">devops</a>
    
</div>

<p><em>This is a pseudo-transcript of <a href="https://www.youtube.com/watch?v=RsSNEkBGmj0">a presentation I gave at the linux.conf.au 2018 Real World Functional Programming Miniconf</a>.</em></p>
<p>What is DevOps about? For me it’s about my relationship to the phrase</p>
<blockquote>
<p>It works on my machine.</p>
</blockquote>
<p>I’ve been guilty of saying this in the past, and quite frankly, it isn’t good enough. After the development team has written their last line of code, some amount of work still needs to happen in order for the software to deliver value.</p>
<p>A few jobs ago I was at a small web development shop, and my deployment workflow was as follows:</p>
<ol type="1">
<li>Log on to the development server and take careful notes on how it had diverged from the production server.</li>
<li>Carefully set aside some time to ‘do the deploy’.</li>
<li>Log on to the production server and do a <code>git pull</code> to get the latest code changes.</li>
<li>Perform database migrations according to the notes you made earlier.</li>
<li>Manually make any other required changes.</li>
</ol>
<p>Despite my best efforts, I would inevitably run into issues whenever I did this, resulting in site outages and frustrated clients. This was far from ideal, but I wasn’t able to articulate why at the time.</p>
<p>I posit that a better deployment process has the following properties:</p>
<ul>
<li><p><strong>Automatic</strong>: instead of a manual multi-step process, it has a single step, which can be performed automatically.</p></li>
<li><p><strong>Repeatable</strong>: instead of only being able to deploy to one lovingly hand-maintained server, it can deploy reliably multiple times to multiple servers.</p></li>
<li><p><strong>Idempotent</strong>: if the target is already in the desired state, no extra work needs to be done.</p></li>
<li><p><strong>Reversible</strong>: if it turns out I made a mistake, I can go back to the previous state.</p></li>
<li><p><strong>Atomic</strong>: an external observer can only see the new state or the old state, not any intermediate state.</p></li>
</ul>
<p>I hope to demonstrate how the Nix suite of tools (Nix, NixOS, and NixOps) fulfill these properties and provide a better DevOps experience.</p>
<p>To make things easier, I’m not assuming that you already run NixOS. Any Linux distro should do, as long as you’ve <a href="https://nixos.org/nix/download.html">installed Nix</a>. macOS users will be able to follow along until I get to the NixOps section.</p>
<h2 id="shipping-it">Shipping it</h2>
<h3 id="packaging">Packaging</h3>
<p>Suppose we have been given a small Haskell app to get up and running:</p>
<p><em>Main.hs</em></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span> <span class="dt">Web.Scotty</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span> (mconcat)</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>main <span class="ot">=</span> scotty <span class="dv">3000</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    get <span class="st">&quot;/:word&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>        beam <span class="ot">&lt;-</span> param <span class="st">&quot;word&quot;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>        html <span class="op">$</span> <span class="fu">mconcat</span> [<span class="st">&quot;&lt;h1&gt;Scotty, &quot;</span>, beam, <span class="st">&quot; me up!&lt;/h1&gt;&quot;</span>]</span></code></pre></div>
<p><em>blank-me-up.cabal</em></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a>name<span class="op">:</span>                blank<span class="op">-</span>me<span class="op">-</span>up</span>
<span id="cb2-2"><a href="#cb2-2"></a>version<span class="op">:</span>             <span class="fl">0.1</span><span class="op">.</span><span class="fl">0.0</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>license<span class="op">:</span>             <span class="dt">BSD3</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>build<span class="op">-</span><span class="kw">type</span><span class="op">:</span>          <span class="dt">Simple</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>cabal<span class="op">-</span>version<span class="op">:</span>       <span class="op">&gt;=</span><span class="fl">1.10</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a>executable blank<span class="op">-</span>me<span class="op">-</span>up</span>
<span id="cb2-8"><a href="#cb2-8"></a>  main<span class="op">-</span>is<span class="op">:</span>             Main.hs</span>
<span id="cb2-9"><a href="#cb2-9"></a>  build<span class="op">-</span>depends<span class="op">:</span>       base <span class="op">&gt;=</span><span class="fl">4.9</span> <span class="op">&amp;&amp;</span> <span class="op">&lt;</span><span class="dv">5</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>                     , scotty</span>
<span id="cb2-11"><a href="#cb2-11"></a>  default<span class="op">-</span>language<span class="op">:</span>    <span class="dt">Haskell2010</span></span></code></pre></div>
<p>(This example is taken straight from <a href="https://github.com/scotty-web/scotty/blob/306fee7121dc41a55bd4e9b785f8366198de7e3c/README.md#scotty-">Scotty’s README</a>.)</p>
<p>Our first step is to build this app and quickly check that it works. We’ll need Nix and <code>cabal2nix</code>, which turns <code>.cabal</code> files into configuration for the Nix package manager. Assuming we’ve installed <code>cabal2nix</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1"></a>$ <span class="ex">nix-env</span> -i cabal2nix</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="op">&lt;</span><span class="ex">a</span> lot of output<span class="op">&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="ex">created</span> <span class="op">&lt;</span>number<span class="op">&gt;</span> symlinks in user environment</span></code></pre></div>
<p>How do we know it worked? Try <code>nix-env -q</code> (short for <code>--query</code>):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a>$ <span class="ex">nix-env</span> -q</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ex">cabal2nix</span></span></code></pre></div>
<p>Okay, assuming the app is in the <code>app</code> subdirectory, let’s create a directory called <code>nix</code> to store our <code>.nix</code> files and begin:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1"></a>$ <span class="bu">cd</span> nix</span>
<span id="cb5-2"><a href="#cb5-2"></a>$ <span class="ex">cabal2nix</span> ../app/ --shell <span class="op">&gt;</span> default.nix</span></code></pre></div>
<p><code>default.nix</code> might look something like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">{</span> <span class="ex">nixpkgs</span> ? import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {<span class="kw">}</span>, <span class="ex">compiler</span> ? <span class="st">&quot;default&quot;</span> }:</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="bu">let</span></span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a>  <span class="ex">inherit</span> (nixpkgs) <span class="ex">pkgs</span><span class="kw">;</span></span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a>  <span class="ex">f</span> = { mkDerivation, base, scotty, stdenv }:</span>
<span id="cb6-8"><a href="#cb6-8"></a>      <span class="ex">mkDerivation</span> {</span>
<span id="cb6-9"><a href="#cb6-9"></a>        <span class="ex">pname</span> = <span class="st">&quot;blank-me-up&quot;</span><span class="kw">;</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>        <span class="ex">version</span> = <span class="st">&quot;0.1.0.0&quot;</span><span class="kw">;</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>        <span class="ex">src</span> = ../app<span class="kw">;</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>        <span class="ex">isLibrary</span> = false<span class="kw">;</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>        <span class="ex">isExecutable</span> = true<span class="kw">;</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>        <span class="ex">executableHaskellDepends</span> = [ base scotty ]<span class="kw">;</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>        <span class="ex">license</span> = stdenv.lib.licenses.bsd3<span class="kw">;</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>      };</span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a>  <span class="ex">haskellPackages</span> = if compiler == <span class="st">&quot;default&quot;</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>                       <span class="kw">then</span> <span class="ex">pkgs.haskellPackages</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>                       <span class="kw">else</span> <span class="ex">pkgs.haskell.packages.</span><span class="va">${compiler}</span><span class="kw">;</span></span>
<span id="cb6-21"><a href="#cb6-21"></a></span>
<span id="cb6-22"><a href="#cb6-22"></a>  <span class="ex">drv</span> = haskellPackages.callPackage f {};</span>
<span id="cb6-23"><a href="#cb6-23"></a></span>
<span id="cb6-24"><a href="#cb6-24"></a><span class="kw">in</span></span>
<span id="cb6-25"><a href="#cb6-25"></a></span>
<span id="cb6-26"><a href="#cb6-26"></a>  <span class="kw">if</span> <span class="ex">pkgs.lib.inNixShell</span> then drv.env else drv</span></code></pre></div>
<p>Now we can build our project by running <code>nix-build</code>, which tries to build <code>default.nix</code> in the current directory if no arguments are provided:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1"></a>$ <span class="ex">nix-build</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="op">&lt;</span><span class="ex">lots</span> of output<span class="op">&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ex">/nix/store</span>/<span class="op">&lt;</span><span class="bu">hash</span><span class="op">&gt;</span>-blank-me-up-0.1.0.0</span></code></pre></div>
<p>There should also be a new <code>result</code> symlink in the current directory, which points to the path above:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1"></a>$ <span class="fu">readlink</span> result</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ex">/nix/store</span>/<span class="op">&lt;</span><span class="bu">hash</span><span class="op">&gt;</span>-blank-me-up-0.1.0.0</span></code></pre></div>
<p>Notice that we’ve built a Haskell executable without having to directly deal with any Haskell-specific tooling (unless you count <code>cabal2nix</code>). Nix works best if you allow it full control over builds, as we do here.</p>
<p>What happens if we run <code>nix-build</code> again without changing anything?</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1"></a>$ <span class="ex">nix-build</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ex">/nix/store</span>/<span class="op">&lt;</span><span class="bu">hash</span><span class="op">&gt;</span>-blank-me-up-0.1.0.0</span></code></pre></div>
<p>It should be nearly instantaneous and not require rebuilding anything. Nix tries to think of build outputs as a pure function of its inputs, and since our inputs are unchanged, it is able to give us back the same path that it did before. This is what I mean when I say Nix is declarative.</p>
<p>What if we break our app:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">--- a/functional-devops/app/Main.hs</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="dt">+++ b/functional-devops/app/Main.hs</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="dt">@@ -4,6 +4,8 @@ import Web.Scotty</span></span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a> import Data.Monoid (mconcat)</span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="va">+broken</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="va">+</span></span>
<span id="cb10-9"><a href="#cb10-9"></a> main = scotty 3000 $ do</span>
<span id="cb10-10"><a href="#cb10-10"></a>     get &quot;/:word&quot; $ do</span>
<span id="cb10-11"><a href="#cb10-11"></a>         beam &lt;- param &quot;word&quot;</span></code></pre></div>
<p>and try to build again?</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1"></a>$ <span class="ex">nix-build</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="ex">Building</span> executable <span class="st">&#39;blank-me-up&#39;</span> for blank-me-up-0.1.0.0..</span>
<span id="cb11-4"><a href="#cb11-4"></a>[<span class="ex">1</span> of 1] Compiling Main             ( Main.hs, dist/build/blank-me-up/blank-me-up-tmp/Main.o )</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="ex">Main.hs</span>:7:1: error:</span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="ex">Parse</span> error: module header, import declaration</span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="ex">or</span> top-level declaration expected.</span>
<span id="cb11-9"><a href="#cb11-9"></a>  <span class="kw">|</span></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="ex">7</span> <span class="kw">|</span> <span class="ex">broken</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>  <span class="kw">|</span> ^^^^^^</span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="ex">builder</span> for <span class="st">&#39;/nix/store/&lt;hash&gt;-blank-me-up-0.1.0.0.drv&#39;</span> failed with exit code 1</span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="ex">error</span>: build of <span class="st">&#39;/nix/store/&lt;hash&gt;-blank-me-up-0.1.0.0.drv&#39;</span> failed</span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></span></code></pre></div>
<p>It fails, as one would hope, but more importantly the previous symlink at <code>result</code> is still available! This is because <code>nix-build</code> completes the build before atomically updating the symlink at <code>result</code> to point to the new artifact. This way, we can move from one known working state to another, without exposing our users to any intermediate brokenness.</p>
<h3 id="service-configuration">Service Configuration</h3>
<p>Okay, now that we’re able to successfully build the app, let’s configure a service file so that <code>systemd</code> can manage our app. I don’t know of any tools that automatically generate this so I always find myself copying and pasting from an existing service file. Here’s one I prepared earlier.</p>
<p><em>nix/service.nix</em></p>
<div class="sourceCode" id="cb12"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">{</span> <span class="ex">config</span>, lib, pkgs, ... <span class="kw">}</span>:                                               <span class="co">#1</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="bu">let</span>                                                                       <span class="co">#2</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>  <span class="ex">blank-me-up</span> = pkgs.callPackage ./default.nix {};                        <span class="co">#3</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="kw">in</span> <span class="kw">{</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>  <span class="ex">options.services.blank-me-up.enable</span> = lib.mkEnableOption <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span> <span class="co">#4</span></span>
<span id="cb12-7"><a href="#cb12-7"></a></span>
<span id="cb12-8"><a href="#cb12-8"></a>  <span class="ex">config</span> = lib.mkIf config.services.blank-me-up.enable {                  <span class="co">#5</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>    <span class="ex">networking.firewall.allowedTCPPorts</span> = [ 3000 ]<span class="kw">;</span>                       <span class="co">#6</span></span>
<span id="cb12-10"><a href="#cb12-10"></a></span>
<span id="cb12-11"><a href="#cb12-11"></a>    <span class="ex">systemd.services.blank-me-up</span> = {                                      <span class="co">#7</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>      <span class="ex">description</span> = <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>      <span class="ex">after</span> = [ <span class="st">&quot;network.target&quot;</span> ]<span class="kw">;</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>      <span class="ex">wantedBy</span> = [ <span class="st">&quot;multi-user.target&quot;</span> ]<span class="kw">;</span></span>
<span id="cb12-15"><a href="#cb12-15"></a>      <span class="ex">serviceConfig</span> = {</span>
<span id="cb12-16"><a href="#cb12-16"></a>        <span class="ex">ExecStart</span> = <span class="st">&quot;</span><span class="va">${blank-</span>me-up<span class="va">}</span><span class="st">/bin/blank-me-up&quot;</span><span class="kw">;</span></span>
<span id="cb12-17"><a href="#cb12-17"></a>        <span class="ex">Restart</span> = <span class="st">&quot;always&quot;</span><span class="kw">;</span></span>
<span id="cb12-18"><a href="#cb12-18"></a>        <span class="ex">KillMode</span> = <span class="st">&quot;process&quot;</span><span class="kw">;</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>      <span class="kw">}</span>;</span>
<span id="cb12-20"><a href="#cb12-20"></a>    };</span>
<span id="cb12-21"><a href="#cb12-21"></a>  };</span>
<span id="cb12-22"><a href="#cb12-22"></a>}</span></code></pre></div>
<p>This isn’t intended to be a Nix language tutorial, but there are a few interesting things that I want to point out. For a more comprehensive overview of the language, see <a href="https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55">here</a> or <a href="https://nixos.org/nix/manual/#ch-expression-language">here</a>.</p>
<ol type="1">
<li>These are the arguments to this expression that the caller will pass. Another way to think of this is as a form of dependency injection.</li>
<li><code>let</code> expressions work similarly to Haskell.</li>
<li>This is the equivalent of our <code>nix-build</code> from before.</li>
<li>We define a single option that enables our service.</li>
<li>The <code>config</code> attribute contains service configuration.</li>
<li>We expose port 3000.</li>
<li>If you squint this looks a lot like a regular unit file. More on this below.</li>
</ol>
<p>It would be useful to look at the systemd service file that gets generated from this configuraation. To do this, we’ll need one more file:</p>
<p><em>ops/webserver.nix</em></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">{</span> <span class="ex">...</span> <span class="kw">}</span>: <span class="kw">{</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="ex">imports</span> = [ ../nix/service.nix ]<span class="kw">;</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="ex">services.blank-me-up.enable</span> = true<span class="kw">;</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="kw">}</span></span></code></pre></div>
<p>This is a function that imports the above configuration and enables the <code>blank-me-up</code> service. With this in place, we can do</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1"></a>$ <span class="ex">nix-instantiate</span> --eval -E <span class="st">&#39;(import &lt;nixpkgs/nixos/lib/eval-config.nix&gt; { modules = [./ops/webserver.nix]; }).config.systemd.units.&quot;blank-me-up.service&quot;.text&#39;</span></span></code></pre></div>
<p>We’re using <code>nix-instantiate</code> to evaluate (<code>--eval</code>) an expression (<code>-E</code>) that uses <code>eval-config.nix</code> from the library to import the file we created and output the text of the final unit file. The output of this is pretty messy, but we can use <code>jq</code> to clean it up:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1"></a>$ <span class="ex">nix-instantiate</span> --eval -E <span class="st">&#39;(import &lt;nixpkgs/nixos/lib/eval-config.nix&gt; { modules = [./ops/webserver.nix]; }).config.systemd.units.&quot;blank-me-up.service&quot;.text&#39;</span> <span class="kw">|</span> <span class="ex">jq</span> -r</span></code></pre></div>
<p>Here’s what that looks like on my machine:</p>
<details>
<p><summary style="cursor: pointer;">Generated <code>systemd</code> service</summary></p>
<div class="sourceCode" id="cb16"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1"></a>[Unit]</span>
<span id="cb16-2"><a href="#cb16-2"></a>After=network.target</span>
<span id="cb16-3"><a href="#cb16-3"></a>Description=Blank Me Up</span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a>[Service]</span>
<span id="cb16-6"><a href="#cb16-6"></a>Environment=&quot;LOCALE_ARCHIVE=/nix/store/&lt;hash&gt;-glibc-locales-2.27/lib/locale/locale-archive&quot;</span>
<span id="cb16-7"><a href="#cb16-7"></a>Environment=&quot;PATH=/nix/store/&lt;hash&gt;-coreutils-8.30/bin:/nix/store/&lt;hash&gt;-findutils-4.6.0/bin:/nix/store/&lt;hash&gt;-gnugrep-3.3/bin:/nix/store/&lt;hash&gt;-gnused-4.7/bin:/nix/store/&lt;hash&gt;-systemd-239.20190219/bin:/nix/store/&lt;hash&gt;-coreutils-8.30/sbin:/nix/store/&lt;hash&gt;-findutils-4.6.0/sbin:/nix/store/&lt;hash&gt;-gnugrep-3.3/sbin:/nix/store/&lt;hash&gt;-gnused-4.7/sbin:/nix/store/&lt;hash&gt;-systemd-239.20190219/sbin&quot;</span>
<span id="cb16-8"><a href="#cb16-8"></a>Environment=&quot;TZDIR=/nix/store/&lt;hash&gt;-tzdata-2019a/share/zoneinfo&quot;</span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a></span>
<span id="cb16-12"><a href="#cb16-12"></a>ExecStart=/nix/store/&lt;hash&gt;-blank-me-up-0.1.0.0/bin/blank-me-up</span>
<span id="cb16-13"><a href="#cb16-13"></a>KillMode=process</span>
<span id="cb16-14"><a href="#cb16-14"></a>Restart=always</span></code></pre></div>
</details>
<p>Hopefully at this point you’re convinced that Nix can take some quasi-JSON and turn it into a binary and a <code>systemd</code> service file. Let’s deploy this!</p>
<h3 id="deploying">Deploying</h3>
<p>First, we install NixOps:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1"></a>$ <span class="ex">nix-env</span> -i nixops</span></code></pre></div>
<p>We also have to set up VirtualBox, which I’ll be using as my deploy target. If you’re using NixOS this is as simple as adding the following line to <code>configuration.nix</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1"></a><span class="ex">virtualisation.virtualbox.host.enable</span> = true<span class="kw">;</span></span></code></pre></div>
<p>and running <code>sudo nixos-rebuild switch</code>. If you’re using another Linux distro, install VirtualBox and set up a host-only network called <code>vboxnet0</code>.</p>
<p>We’ll be using the <a href="https://nixos.org/nixops/manual/#idm140737318606176">instructions from the manual</a> as our starting point. Create two files:</p>
<p><em>ops/trivial.nix</em></p>
<div class="sourceCode" id="cb19"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">{</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>  <span class="ex">network.description</span> = <span class="st">&quot;Web server&quot;</span><span class="kw">;</span></span>
<span id="cb19-3"><a href="#cb19-3"></a>  <span class="ex">network.enableRollback</span> = true<span class="kw">;</span></span>
<span id="cb19-4"><a href="#cb19-4"></a></span>
<span id="cb19-5"><a href="#cb19-5"></a>  <span class="ex">webserver</span> = import ./webserver.nix<span class="kw">;</span></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="kw">}</span></span></code></pre></div>
<p><em>ops/trivial-vbox.nix</em></p>
<div class="sourceCode" id="cb20"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">{</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>  <span class="ex">webserver</span> =</span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="kw">{</span> <span class="ex">config</span>, pkgs, ... <span class="kw">}</span>:</span>
<span id="cb20-4"><a href="#cb20-4"></a>    <span class="kw">{</span> <span class="ex">deployment.targetEnv</span> = <span class="st">&quot;virtualbox&quot;</span><span class="kw">;</span></span>
<span id="cb20-5"><a href="#cb20-5"></a>      <span class="ex">deployment.virtualbox.headless</span> = true<span class="kw">;</span> <span class="co"># don&#39;t show a display</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>      <span class="ex">deployment.virtualbox.memorySize</span> = 1024<span class="kw">;</span> <span class="co"># megabytes</span></span>
<span id="cb20-7"><a href="#cb20-7"></a>      <span class="ex">deployment.virtualbox.vcpu</span> = 2<span class="kw">;</span> <span class="co"># number of cpus</span></span>
<span id="cb20-8"><a href="#cb20-8"></a>    <span class="kw">}</span>;</span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="kw">}</span></span></code></pre></div>
<p>We should now be able to create a new deployment:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1"></a>$ <span class="bu">cd</span> ops</span>
<span id="cb21-2"><a href="#cb21-2"></a>$ <span class="ex">nixops</span> create trivial.nix trivial-vbox.nix -d trivial</span></code></pre></div>
<p>and deploy it:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1"></a>$ <span class="ex">nixops</span> deploy -d trivial</span></code></pre></div>
<p>and assuming that everything goes well, we should see a lot of terminal output and at least one mention of <code>ssh://root@&lt;ip&gt;</code>, which is the IP of our target.</p>
<p>We should then be able to go to <code>http://&lt;ip&gt;:3000</code> and see our web app in action!</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1"></a>$ <span class="ex">curl</span> http://<span class="op">&lt;</span>ip<span class="op">&gt;</span>:3000/help</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="op">&lt;</span><span class="ex">h1</span><span class="op">&gt;</span>Scotty, help me up!<span class="op">&lt;</span>/h1<span class="op">&gt;</span></span></code></pre></div>
<p>NixOps also allows us to SSH in for troubleshooting purposes or to view logs:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1"></a>$ <span class="ex">nixops</span> ssh -d trivial webserver</span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>[<span class="ex">root@webserver</span>:~]# systemctl status blank-me-up</span></code></pre></div>
<h2 id="responding-to-change">Responding to change</h2>
<p>This is fantastic, but deployments are rarely fire-and-forget. What happens when our requirements change? In fact, there’s a serious issue with our application, which is that it hardcodes the port that it listens on. If we wanted it to listen on a different port, or to run more than one instance of it on the same machine, we’d need to do something differently.</p>
<p>The correct solution would be to talk to the developers and have them implement support, but in the meantime, how should we proceed?</p>
<h3 id="patching">Patching</h3>
<p>Nix gives us full control over each part of the build and deployment process, and we can patch the software as a stopgap measure. Although this scenario is somewhat contrived, I have in fact had to take matters into my own hands like this in the past when the development team hasn’t been able to prioritise fixing a production issue.</p>
<p>Our new expression looks like this:</p>
<p><em>nix/patched.nix</em></p>
<div class="sourceCode" id="cb25"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1"></a><span class="ex">args@</span>{ nixpkgs ? import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> {}, <span class="ex">compiler</span> ? <span class="st">&quot;default&quot;</span> }:</span>
<span id="cb25-2"><a href="#cb25-2"></a></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="kw">(</span><span class="ex">import</span> ./default.nix args<span class="kw">)</span><span class="ex">.overrideAttrs</span> (old: {</span>
<span id="cb25-4"><a href="#cb25-4"></a>  <span class="ex">postPatch</span> = let</span>
<span id="cb25-5"><a href="#cb25-5"></a>    <span class="ex">oldImport</span> = <span class="st">&#39;&#39;</span></span>
<span id="cb25-6"><a href="#cb25-6"></a>      <span class="ex">import</span> Web.Scotty</span>
<span id="cb25-7"><a href="#cb25-7"></a>    <span class="st">&#39;&#39;</span>;</span>
<span id="cb25-8"><a href="#cb25-8"></a>    <span class="ex">newImport</span> = <span class="st">&#39;&#39;</span></span>
<span id="cb25-9"><a href="#cb25-9"></a>      <span class="ex">import</span> Web.Scotty</span>
<span id="cb25-10"><a href="#cb25-10"></a>      <span class="ex">import</span> System.Environment (getArgs)</span>
<span id="cb25-11"><a href="#cb25-11"></a>    <span class="st">&#39;&#39;</span>;</span>
<span id="cb25-12"><a href="#cb25-12"></a>    <span class="ex">oldMain</span> = <span class="st">&#39;&#39;</span></span>
<span id="cb25-13"><a href="#cb25-13"></a>      <span class="ex">main</span> = scotty 3000 $ do</span>
<span id="cb25-14"><a href="#cb25-14"></a>    <span class="st">&#39;&#39;</span>;</span>
<span id="cb25-15"><a href="#cb25-15"></a>    <span class="ex">newMain</span> = <span class="st">&#39;&#39;</span></span>
<span id="cb25-16"><a href="#cb25-16"></a>      <span class="ex">main</span> = getArgs <span class="op">&gt;&gt;</span>= <span class="dt">\(</span>port:_) <span class="ex">-</span><span class="op">&gt;</span> scotty (read port) $ <span class="kw">do</span></span>
<span id="cb25-17"><a href="#cb25-17"></a>    <span class="st">&#39;&#39;</span>;</span>
<span id="cb25-18"><a href="#cb25-18"></a>  <span class="kw">in</span> <span class="st">&#39;&#39;</span></span>
<span id="cb25-19"><a href="#cb25-19"></a>    <span class="ex">substituteInPlace</span> Main.hs --replace <span class="st">&#39;${oldImport}&#39;</span> <span class="st">&#39;${newImport}&#39;</span></span>
<span id="cb25-20"><a href="#cb25-20"></a>    <span class="ex">substituteInPlace</span> Main.hs --replace <span class="st">&#39;${oldMain}&#39;</span>   <span class="st">&#39;${newMain}&#39;</span></span>
<span id="cb25-21"><a href="#cb25-21"></a>    <span class="fu">cat</span> Main.hs</span>
<span id="cb25-22"><a href="#cb25-22"></a>  <span class="st">&#39;&#39;</span>;</span>
<span id="cb25-23"><a href="#cb25-23"></a>})</span></code></pre></div>
<p>I’ve added that <code>cat Main.hs</code> at the end to</p>
<ul>
<li>confirm that the file was correctly patched</li>
<li>emphasise that arbitrary shell commands can be executed</li>
</ul>
<p>We can create a new service definition to use this expression:</p>
<p><em>nix/service-patched.nix</em></p>
<div class="sourceCode" id="cb26"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">{</span> <span class="ex">config</span>, lib, pkgs, ... <span class="kw">}</span>:</span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="bu">let</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>  <span class="ex">blank-me-up</span> = pkgs.callPackage ./patched.nix { nixpkgs = pkgs<span class="kw">;</span> };</span>
<span id="cb26-5"><a href="#cb26-5"></a>  <span class="ex">cfg</span> = config.services.blank-me-up<span class="kw">;</span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="kw">in</span> <span class="kw">{</span></span>
<span id="cb26-7"><a href="#cb26-7"></a>  <span class="ex">options.services.blank-me-up.enable</span> = lib.mkEnableOption <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span></span>
<span id="cb26-8"><a href="#cb26-8"></a>  <span class="ex">options.services.blank-me-up.port</span> = lib.mkOption {</span>
<span id="cb26-9"><a href="#cb26-9"></a>    <span class="ex">default</span> = 3000<span class="kw">;</span></span>
<span id="cb26-10"><a href="#cb26-10"></a>    <span class="bu">type</span> = lib.types.int<span class="kw">;</span></span>
<span id="cb26-11"><a href="#cb26-11"></a>  <span class="kw">}</span>;</span>
<span id="cb26-12"><a href="#cb26-12"></a></span>
<span id="cb26-13"><a href="#cb26-13"></a>  <span class="ex">config</span> = lib.mkIf cfg.enable {</span>
<span id="cb26-14"><a href="#cb26-14"></a>    <span class="ex">networking.firewall.allowedTCPPorts</span> = [ cfg.port ]<span class="kw">;</span></span>
<span id="cb26-15"><a href="#cb26-15"></a></span>
<span id="cb26-16"><a href="#cb26-16"></a>    <span class="ex">systemd.services.blank-me-up</span> = {</span>
<span id="cb26-17"><a href="#cb26-17"></a>      <span class="ex">description</span> = <span class="st">&quot;Blank Me Up&quot;</span><span class="kw">;</span></span>
<span id="cb26-18"><a href="#cb26-18"></a>      <span class="ex">after</span> = [ <span class="st">&quot;network.target&quot;</span> ]<span class="kw">;</span></span>
<span id="cb26-19"><a href="#cb26-19"></a>      <span class="ex">wantedBy</span> = [ <span class="st">&quot;multi-user.target&quot;</span> ]<span class="kw">;</span></span>
<span id="cb26-20"><a href="#cb26-20"></a>      <span class="ex">serviceConfig</span> = {</span>
<span id="cb26-21"><a href="#cb26-21"></a>        <span class="ex">ExecStart</span> = <span class="st">&quot;</span><span class="va">${blank-</span>me-up<span class="va">}</span><span class="st">/bin/blank-me-up </span><span class="va">${toString</span><span class="er"> cfg.port</span><span class="va">}</span><span class="st">&quot;</span><span class="kw">;</span></span>
<span id="cb26-22"><a href="#cb26-22"></a>        <span class="ex">Restart</span> = <span class="st">&quot;always&quot;</span><span class="kw">;</span></span>
<span id="cb26-23"><a href="#cb26-23"></a>        <span class="ex">KillMode</span> = <span class="st">&quot;process&quot;</span><span class="kw">;</span></span>
<span id="cb26-24"><a href="#cb26-24"></a>      };</span>
<span id="cb26-25"><a href="#cb26-25"></a>    };</span>
<span id="cb26-26"><a href="#cb26-26"></a>  };</span>
<span id="cb26-27"><a href="#cb26-27"></a>}</span></code></pre></div>
<p>We make sure to pass the configured port in on startup and open the firewall appropriately.</p>
<h3 id="deploying-again">Deploying (Again)</h3>
<p>We update <code>webserver.nix</code> to use the patched service and specify a different port:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode nix"><code class="sourceCode bash"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">{</span> <span class="ex">...</span> <span class="kw">}</span>: <span class="kw">{</span></span>
<span id="cb27-2"><a href="#cb27-2"></a>  <span class="ex">imports</span> = [ ../nix/service-patched.nix ]<span class="kw">;</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>  <span class="ex">services.blank-me-up.enable</span> = true<span class="kw">;</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>  <span class="ex">services.blank-me-up.port</span> = 3001<span class="kw">;</span></span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="kw">}</span></span></code></pre></div>
<p>And we can deploy again!</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1"></a>$ <span class="ex">nixops</span> deploy -d trivial</span></code></pre></div>
<p>The service should now be running on <code>http://&lt;ip&gt;:3001</code> instead of <code>http://&lt;ip&gt;:3000</code>.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1"></a>$ <span class="ex">curl</span> http://<span class="op">&lt;</span>ip<span class="op">&gt;</span>:3001/pull</span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="op">&lt;</span><span class="ex">h1</span><span class="op">&gt;</span>Scotty, pull me up!<span class="op">&lt;</span>/h1<span class="op">&gt;</span></span></code></pre></div>
<p>If we made a mistake, rolling back is easy:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1"></a>$ <span class="ex">nixops</span> list-generations -d trivial</span>
<span id="cb30-2"><a href="#cb30-2"></a>   <span class="ex">1</span>   <span class="op">&lt;</span>timestamp<span class="op">&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>   <span class="ex">2</span>   <span class="op">&lt;</span>timestamp<span class="op">&gt;</span>   (current)</span>
<span id="cb30-4"><a href="#cb30-4"></a></span>
<span id="cb30-5"><a href="#cb30-5"></a>$ <span class="ex">nixops</span> rollback -d trivial 1</span>
<span id="cb30-6"><a href="#cb30-6"></a><span class="ex">switching</span> from generation 2 to 1</span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="ex">webserver</span><span class="op">&gt;</span> copying closure...</span>
<span id="cb30-8"><a href="#cb30-8"></a><span class="ex">trivial</span><span class="op">&gt;</span> closures copied successfully</span>
<span id="cb30-9"><a href="#cb30-9"></a><span class="op">&lt;</span><span class="fu">more</span> output<span class="op">&gt;</span></span></code></pre></div>
<p>and in fact nothing needs to be copied to the target, because the previous deployment is still there.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As demonstrated, the Nix ecosystem allows us to impose order on the usually messy and ad-hoc practice of packaging and deploying software at scale. I’m satisfied that this is the way forward and hope that you will consider using these tools to tackle problems of your own!</p>
</summary>
</entry>
<entry>
    <title>Hacking on GHC Has Never Been Easier!</title>
    <link href="https://vaibhavsagar.com/blog/2019/06/22/easy-ghc-hacking/" />
    <id>https://vaibhavsagar.com/blog/2019/06/22/easy-ghc-hacking/index.html</id>
    <published>2019-06-22</published>
    <updated>2019-06-22T00:00:00Z</updated>
    <summary type="html"><div class="info">
    Posted on 22 June 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/nix/index.html">nix</a>, <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p>At ZuriHac 2019 <a href="https://github.com/mpickering">Matthew Pickering</a> talked about <a href="https://www.youtube.com/watch?v=Q2ZDovqIxCw">tools for working on GHC</a>. There’s <a href="https://mpickering.github.io/posts/2019-06-11-ghc-tools.html">an associated blog post</a> which is also well worth reading.</p>
<p>I wanted to focus on a small part of his presentation, which is about loading <a href="https://gitlab.haskell.org/ghc/ghc/wikis/building/in-ghci">GHC into GHCi</a> and using <a href="https://github.com/ndmitchell/ghcid"><code>ghcid</code></a> to automatically reload GHC on changes. This has been possible for almost a year now, <a href="https://mgsloan.com/posts/ghcinception/">as described in this blog post by Michael Sloan</a>. It has since been improved to be even easier to use!</p>
<p>Putting this together with <a href="https://github.com/alpmestan/ghc.nix">Alp Mestanogullari’s <code>ghc.nix</code></a>, it’s now possible to provision a GHC development environment from scratch with just a few commands, assuming that you have <code>nix-shell</code>, <code>cabal-install</code>, and <code>ghcid</code> installed. Here they are:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a>$ <span class="fu">git</span> clone --recursive https://gitlab.haskell.org/ghc/ghc/</span>
<span id="cb1-2"><a href="#cb1-2"></a>$ <span class="bu">cd</span> ghc</span>
<span id="cb1-3"><a href="#cb1-3"></a>$ <span class="fu">git</span> clone https://github.com/alpmestan/ghc.nix</span>
<span id="cb1-4"><a href="#cb1-4"></a>$ <span class="ex">cabal</span> update</span>
<span id="cb1-5"><a href="#cb1-5"></a>$ <span class="ex">nix-shell</span> ghc.nix/ --run <span class="st">&#39;./boot &amp;&amp; ./configure &amp;&amp; ghcid&#39;</span></span></code></pre></div>
<p>This will take a while the first time, but <code>ghcid</code> will cache generated artifacts under <code>./hadrian_ghci</code> so even quitting and reloading will be significantly faster.</p>
<p>Congratulations, you are now a GHC developer!</p>
</summary>
</entry>
<entry>
    <title>Refactoring Haskell: A Case Study</title>
    <link href="https://vaibhavsagar.com/blog/2019/02/12/refactoring-haskell/" />
    <id>https://vaibhavsagar.com/blog/2019/02/12/refactoring-haskell/index.html</id>
    <published>2019-02-12</published>
    <updated>2019-02-12T00:00:00Z</updated>
    <summary type="html"><div class="info">
    Posted on 12 February 2019
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>
    
</div>

<p>Many people claim that <a href="https://twitter.com/search?q=haskell%20refactoring">refactoring Haskell is a joy</a>. I’ve certainly found this to be the case, but what does that mean in practice? I thought it might be useful to demonstrate by refactoring some of my own code.</p>
<p>The code we’re looking at today is an implementation of <a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Tarjan’s Strongly Connected Components algorithm</a> used to determine whether a given <a href="https://en.wikipedia.org/wiki/2-satisfiability">2-SAT problem</a> is satisfiable or not, and was written to complete <a href="https://online.stanford.edu/course/algorithms-design-and-analysis-part-1">an online course</a> that is now offered in a different form. I’ve <a href="/blog/2017/06/10/dag-toolkit/">written about Tarjan’s algorithm previously</a> and it can be used to determine the satisfiability of a 2-SAT problem by checking if any SCC contains both a variable and its negation. If it does, we have a contradiction and the problem is unsatisfiable, otherwise the problem is satisfiable.</p>
<p>This code isn’t particularly elegant or easy to follow, and it’s lousy with mutable state. Despite these drawbacks, it is still relatively straightforward to refactor.</p>
<p>If you’d like to follow along, I have the code (and some test data) available <a href="https://gist.github.com/vaibhavsagar/2418c9dd79da431065ad0d80e690b12f">at this gist</a> with each revision representing a refactoring step.</p>
<p>The initial version of the code is as follows:</p>
<details>
<p><summary style="cursor: pointer">Initial 2SAT.hs</summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span>      <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span>        <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span>      <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>         <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_, when)</span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span> (isJust, isNothing, fromJust)</span>
<span id="cb1-15"><a href="#cb1-15"></a></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>]</span>
<span id="cb1-17"><a href="#cb1-17"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>    stack    <span class="ot">&lt;-</span> newSTRef []</span>
<span id="cb1-20"><a href="#cb1-20"></a>    stackSet <span class="ot">&lt;-</span> newSTRef S.empty</span>
<span id="cb1-21"><a href="#cb1-21"></a>    indices  <span class="ot">&lt;-</span> newSTRef M.empty</span>
<span id="cb1-22"><a href="#cb1-22"></a>    lowlinks <span class="ot">&lt;-</span> newSTRef M.empty</span>
<span id="cb1-23"><a href="#cb1-23"></a>    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1-26"><a href="#cb1-26"></a>        vIndex <span class="ot">&lt;-</span> M.lookup v <span class="op">&lt;$&gt;</span> readSTRef indices</span>
<span id="cb1-27"><a href="#cb1-27"></a>        when (isNothing vIndex) <span class="op">$</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb1-29"><a href="#cb1-29"></a></span>
<span id="cb1-30"><a href="#cb1-30"></a>    readSTRef output</span>
<span id="cb1-31"><a href="#cb1-31"></a></span>
<span id="cb1-32"><a href="#cb1-32"></a>strongConnect</span>
<span id="cb1-33"><a href="#cb1-33"></a><span class="ot">    ::</span> <span class="dt">Int</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>    <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-35"><a href="#cb1-35"></a>    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb1-38"><a href="#cb1-38"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>)</span>
<span id="cb1-39"><a href="#cb1-39"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)</span>
<span id="cb1-40"><a href="#cb1-40"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)</span>
<span id="cb1-41"><a href="#cb1-41"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>])</span>
<span id="cb1-42"><a href="#cb1-42"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</span>
<span id="cb1-43"><a href="#cb1-43"></a>strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-44"><a href="#cb1-44"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb1-45"><a href="#cb1-45"></a>    insert v i indices</span>
<span id="cb1-46"><a href="#cb1-46"></a>    insert v i lowlinks</span>
<span id="cb1-47"><a href="#cb1-47"></a>    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb1-48"><a href="#cb1-48"></a>    push stack stackSet v</span>
<span id="cb1-49"><a href="#cb1-49"></a></span>
<span id="cb1-50"><a href="#cb1-50"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">lookup</span> w indices <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb1-51"><a href="#cb1-51"></a>        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1-52"><a href="#cb1-52"></a>            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb1-53"><a href="#cb1-53"></a>            vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</span>
<span id="cb1-54"><a href="#cb1-54"></a>            wLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> w lowlinks</span>
<span id="cb1-55"><a href="#cb1-55"></a>            insert v (<span class="fu">min</span> vLowLink wLowLink) lowlinks</span>
<span id="cb1-56"><a href="#cb1-56"></a>        <span class="dt">Just</span> wIndex <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1-57"><a href="#cb1-57"></a>            wOnStack <span class="ot">&lt;-</span> S.member w <span class="op">&lt;$&gt;</span> readSTRef stackSet</span>
<span id="cb1-58"><a href="#cb1-58"></a>            when wOnStack <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb1-59"><a href="#cb1-59"></a>                vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</span>
<span id="cb1-60"><a href="#cb1-60"></a>                insert v (<span class="fu">min</span> vLowLink wIndex) lowlinks</span>
<span id="cb1-61"><a href="#cb1-61"></a></span>
<span id="cb1-62"><a href="#cb1-62"></a>    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v lowlinks</span>
<span id="cb1-63"><a href="#cb1-63"></a>    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> v indices</span>
<span id="cb1-64"><a href="#cb1-64"></a>    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb1-65"><a href="#cb1-65"></a>        scc <span class="ot">&lt;-</span> addSCC n v S.empty stack stackSet</span>
<span id="cb1-66"><a href="#cb1-66"></a>        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb1-67"><a href="#cb1-67"></a>    <span class="kw">where</span></span>
<span id="cb1-68"><a href="#cb1-68"></a>        <span class="fu">lookup</span> value hashMap     <span class="ot">=</span> M.lookup value <span class="op">&lt;$&gt;</span> readSTRef hashMap</span>
<span id="cb1-69"><a href="#cb1-69"></a>        insert key value hashMap <span class="ot">=</span> modifySTRef&#39; hashMap (M.insert key value)</span>
<span id="cb1-70"><a href="#cb1-70"></a></span>
<span id="cb1-71"><a href="#cb1-71"></a><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> (<span class="dt">S.Set</span> <span class="dt">Int</span>))</span>
<span id="cb1-72"><a href="#cb1-72"></a>addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`S.member`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb1-73"><a href="#cb1-73"></a>    <span class="kw">let</span> scc&#39; <span class="ot">=</span> S.insert w scc</span>
<span id="cb1-74"><a href="#cb1-74"></a>    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</span>
<span id="cb1-75"><a href="#cb1-75"></a></span>
<span id="cb1-76"><a href="#cb1-76"></a><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb1-77"><a href="#cb1-77"></a>push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-78"><a href="#cb1-78"></a>    modifySTRef&#39; stack    (e<span class="op">:</span>)</span>
<span id="cb1-79"><a href="#cb1-79"></a>    modifySTRef&#39; stackSet (S.insert e)</span>
<span id="cb1-80"><a href="#cb1-80"></a></span>
<span id="cb1-81"><a href="#cb1-81"></a><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb1-82"><a href="#cb1-82"></a>pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-83"><a href="#cb1-83"></a>    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb1-84"><a href="#cb1-84"></a>    modifySTRef&#39; stack <span class="fu">tail</span></span>
<span id="cb1-85"><a href="#cb1-85"></a>    modifySTRef&#39; stackSet (S.delete e)</span>
<span id="cb1-86"><a href="#cb1-86"></a>    <span class="fu">return</span> e</span>
<span id="cb1-87"><a href="#cb1-87"></a></span>
<span id="cb1-88"><a href="#cb1-88"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb1-89"><a href="#cb1-89"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb1-90"><a href="#cb1-90"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb1-91"><a href="#cb1-91"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb1-92"><a href="#cb1-92"></a></span>
<span id="cb1-93"><a href="#cb1-93"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb1-94"><a href="#cb1-94"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-95"><a href="#cb1-95"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb1-96"><a href="#cb1-96"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb1-97"><a href="#cb1-97"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb1-98"><a href="#cb1-98"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb1-99"><a href="#cb1-99"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>I’ve included 2SAT-specific functionality for completeness, but I’ll only be changing the <code>tarjan</code> function and the functions it depends on (<code>strongConnect</code>, <code>addSCC</code>, <code>push</code>, and <code>pop</code>).</p>
<p>The first change is using more suitable data structures. Tarjan’s algorithm is only linear in the size of the graph when operations, such as checking if <code>w</code> is on the stack and looking up indices, happen in constant time (<span class="math inline"><em>O</em>(1)</span>). I’m currently using <code>Data.Map</code> and <code>Data.Set</code> which are both implemented with trees and are <span class="math inline"><em>O</em>(log <em>n</em>)</span> in these operations. A better choice would be <a href="http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html"><code>Data.Vector.Mutable</code></a> from the <code>vector</code> package, which does have constant-time operations.</p>
<p>This refactoring mostly consists of initialising vectors with a known length and replacing calls to <code>lookup</code> and <code>insert</code> with calls to <code>read</code> and <code>write</code>.</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>vector</code></summary></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb2-11"><a href="#cb2-11"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_, when)</span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span>          (isJust, isNothing, fromJust)</span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb2-14"><a href="#cb2-14"></a></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb2-16"><a href="#cb2-16"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>    stack    <span class="ot">&lt;-</span> newSTRef []</span>
<span id="cb2-19"><a href="#cb2-19"></a>    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb2-23"><a href="#cb2-23"></a></span>
<span id="cb2-24"><a href="#cb2-24"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-25"><a href="#cb2-25"></a>        vIndex <span class="ot">&lt;-</span> <span class="fu">read</span> indices v</span>
<span id="cb2-26"><a href="#cb2-26"></a>        when (isNothing vIndex) <span class="op">$</span></span>
<span id="cb2-27"><a href="#cb2-27"></a>            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb2-28"><a href="#cb2-28"></a></span>
<span id="cb2-29"><a href="#cb2-29"></a>    readSTRef output</span>
<span id="cb2-30"><a href="#cb2-30"></a>    <span class="kw">where</span></span>
<span id="cb2-31"><a href="#cb2-31"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb2-32"><a href="#cb2-32"></a></span>
<span id="cb2-33"><a href="#cb2-33"></a>strongConnect</span>
<span id="cb2-34"><a href="#cb2-34"></a><span class="ot">    ::</span> <span class="dt">Int</span></span>
<span id="cb2-35"><a href="#cb2-35"></a>    <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-36"><a href="#cb2-36"></a>    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></span>
<span id="cb2-37"><a href="#cb2-37"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb2-38"><a href="#cb2-38"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb2-39"><a href="#cb2-39"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb2-40"><a href="#cb2-40"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb2-41"><a href="#cb2-41"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb2-42"><a href="#cb2-42"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb2-43"><a href="#cb2-43"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</span>
<span id="cb2-44"><a href="#cb2-44"></a>strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-45"><a href="#cb2-45"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb2-46"><a href="#cb2-46"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb2-47"><a href="#cb2-47"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb2-48"><a href="#cb2-48"></a>    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb2-49"><a href="#cb2-49"></a>    push stack stackSet v</span>
<span id="cb2-50"><a href="#cb2-50"></a></span>
<span id="cb2-51"><a href="#cb2-51"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb2-52"><a href="#cb2-52"></a>        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-53"><a href="#cb2-53"></a>            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb2-54"><a href="#cb2-54"></a>            vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</span>
<span id="cb2-55"><a href="#cb2-55"></a>            wLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks w</span>
<span id="cb2-56"><a href="#cb2-56"></a>            write lowlinks v (<span class="dt">Just</span> (<span class="fu">min</span> vLowLink wLowLink))</span>
<span id="cb2-57"><a href="#cb2-57"></a>        <span class="dt">Just</span> wIndex <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-58"><a href="#cb2-58"></a>            wOnStack <span class="ot">&lt;-</span> <span class="fu">read</span> stackSet w</span>
<span id="cb2-59"><a href="#cb2-59"></a>            when wOnStack <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-60"><a href="#cb2-60"></a>                vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</span>
<span id="cb2-61"><a href="#cb2-61"></a>                write lowlinks v (<span class="dt">Just</span> (<span class="fu">min</span> vLowLink wIndex))</span>
<span id="cb2-62"><a href="#cb2-62"></a></span>
<span id="cb2-63"><a href="#cb2-63"></a>    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</span>
<span id="cb2-64"><a href="#cb2-64"></a>    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices  v</span>
<span id="cb2-65"><a href="#cb2-65"></a>    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-66"><a href="#cb2-66"></a>        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</span>
<span id="cb2-67"><a href="#cb2-67"></a>        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb2-68"><a href="#cb2-68"></a></span>
<span id="cb2-69"><a href="#cb2-69"></a><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb2-70"><a href="#cb2-70"></a>addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb2-71"><a href="#cb2-71"></a>    <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb2-72"><a href="#cb2-72"></a>    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</span>
<span id="cb2-73"><a href="#cb2-73"></a></span>
<span id="cb2-74"><a href="#cb2-74"></a><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb2-75"><a href="#cb2-75"></a>push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-76"><a href="#cb2-76"></a>    modifySTRef&#39; stack (e<span class="op">:</span>)</span>
<span id="cb2-77"><a href="#cb2-77"></a>    write stackSet e <span class="dt">True</span></span>
<span id="cb2-78"><a href="#cb2-78"></a></span>
<span id="cb2-79"><a href="#cb2-79"></a><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb2-80"><a href="#cb2-80"></a>pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-81"><a href="#cb2-81"></a>    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb2-82"><a href="#cb2-82"></a>    modifySTRef&#39; stack <span class="fu">tail</span></span>
<span id="cb2-83"><a href="#cb2-83"></a>    write stackSet e <span class="dt">False</span></span>
<span id="cb2-84"><a href="#cb2-84"></a>    <span class="fu">return</span> e</span>
<span id="cb2-85"><a href="#cb2-85"></a></span>
<span id="cb2-86"><a href="#cb2-86"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb2-87"><a href="#cb2-87"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb2-88"><a href="#cb2-88"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb2-89"><a href="#cb2-89"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb2-90"><a href="#cb2-90"></a></span>
<span id="cb2-91"><a href="#cb2-91"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb2-92"><a href="#cb2-92"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-93"><a href="#cb2-93"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb2-94"><a href="#cb2-94"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb2-95"><a href="#cb2-95"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb2-96"><a href="#cb2-96"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb2-97"><a href="#cb2-97"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>I didn’t notice a significant difference in speed on my inputs, but it’s good to know that the algorithm has been implemented with the correct asymptotics now!</p>
<p><em>Sidenote: A <code>Vector</code> of <code>Bool</code>s can be much more compactly represented as a sequence of 0s and 1s, which are just machine words. For implementations of this in Haskell, see the <a href="https://hackage.haskell.org/package/bv">bv</a> or <a href="https://hackage.haskell.org/package/bv-little">bv-little</a> packages. Using these could be another possible refactoring.</em></p>
<p>Looking at the code again, I notice some repetition of the form</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a>x <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorX i</span>
<span id="cb3-2"><a href="#cb3-2"></a>y <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorY j</span>
<span id="cb3-3"><a href="#cb3-3"></a>write vectorZ k (<span class="dt">Just</span> (operation x y))</span></code></pre></div>
<p>and with the judicious use of <code>(=&lt;&lt;)</code> and <code>(&lt;*&gt;)</code> this can instead be</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>write vectorZ k <span class="op">=&lt;&lt;</span> (operation <span class="op">&lt;$&gt;</span> <span class="fu">lookup</span> vectorX i <span class="op">&lt;*&gt;</span> <span class="fu">lookup</span> vectorY j)</span></code></pre></div>
<p>There are a couple of other places we could use <code>(&lt;*&gt;)</code>:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>(&lt;*&gt;)</code></summary></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_, when)</span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span>          (isJust, isNothing, fromJust)</span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb5-14"><a href="#cb5-14"></a></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb5-16"><a href="#cb5-16"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-17"><a href="#cb5-17"></a>    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb5-18"><a href="#cb5-18"></a>    stack    <span class="ot">&lt;-</span> newSTRef []</span>
<span id="cb5-19"><a href="#cb5-19"></a>    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb5-20"><a href="#cb5-20"></a>    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb5-21"><a href="#cb5-21"></a>    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb5-22"><a href="#cb5-22"></a>    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb5-23"><a href="#cb5-23"></a></span>
<span id="cb5-24"><a href="#cb5-24"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-25"><a href="#cb5-25"></a>        vIndex <span class="ot">&lt;-</span> <span class="fu">read</span> indices v</span>
<span id="cb5-26"><a href="#cb5-26"></a>        when (isNothing vIndex) <span class="op">$</span></span>
<span id="cb5-27"><a href="#cb5-27"></a>            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb5-28"><a href="#cb5-28"></a></span>
<span id="cb5-29"><a href="#cb5-29"></a>    readSTRef output</span>
<span id="cb5-30"><a href="#cb5-30"></a>    <span class="kw">where</span></span>
<span id="cb5-31"><a href="#cb5-31"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-32"><a href="#cb5-32"></a></span>
<span id="cb5-33"><a href="#cb5-33"></a>strongConnect</span>
<span id="cb5-34"><a href="#cb5-34"></a><span class="ot">    ::</span> <span class="dt">Int</span></span>
<span id="cb5-35"><a href="#cb5-35"></a>    <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-36"><a href="#cb5-36"></a>    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></span>
<span id="cb5-37"><a href="#cb5-37"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb5-38"><a href="#cb5-38"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb5-39"><a href="#cb5-39"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb5-40"><a href="#cb5-40"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb5-41"><a href="#cb5-41"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb5-42"><a href="#cb5-42"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb5-43"><a href="#cb5-43"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</span>
<span id="cb5-44"><a href="#cb5-44"></a>strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-45"><a href="#cb5-45"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb5-46"><a href="#cb5-46"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb5-47"><a href="#cb5-47"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb5-48"><a href="#cb5-48"></a>    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb5-49"><a href="#cb5-49"></a>    push stack stackSet v</span>
<span id="cb5-50"><a href="#cb5-50"></a></span>
<span id="cb5-51"><a href="#cb5-51"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb5-52"><a href="#cb5-52"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-53"><a href="#cb5-53"></a>            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb5-54"><a href="#cb5-54"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</span>
<span id="cb5-55"><a href="#cb5-55"></a>        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-56"><a href="#cb5-56"></a>            wOnStack <span class="ot">&lt;-</span> <span class="fu">read</span> stackSet w</span>
<span id="cb5-57"><a href="#cb5-57"></a>            when wOnStack <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-58"><a href="#cb5-58"></a>                write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices w)</span>
<span id="cb5-59"><a href="#cb5-59"></a></span>
<span id="cb5-60"><a href="#cb5-60"></a>    vLowLink <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v</span>
<span id="cb5-61"><a href="#cb5-61"></a>    vIndex   <span class="ot">&lt;-</span> fromJust <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices  v</span>
<span id="cb5-62"><a href="#cb5-62"></a>    when (vLowLink <span class="op">==</span> vIndex) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-63"><a href="#cb5-63"></a>        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</span>
<span id="cb5-64"><a href="#cb5-64"></a>        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb5-65"><a href="#cb5-65"></a></span>
<span id="cb5-66"><a href="#cb5-66"></a><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb5-67"><a href="#cb5-67"></a>addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb5-68"><a href="#cb5-68"></a>    <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb5-69"><a href="#cb5-69"></a>    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</span>
<span id="cb5-70"><a href="#cb5-70"></a></span>
<span id="cb5-71"><a href="#cb5-71"></a><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb5-72"><a href="#cb5-72"></a>push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-73"><a href="#cb5-73"></a>    modifySTRef&#39; stack (e<span class="op">:</span>)</span>
<span id="cb5-74"><a href="#cb5-74"></a>    write stackSet e <span class="dt">True</span></span>
<span id="cb5-75"><a href="#cb5-75"></a></span>
<span id="cb5-76"><a href="#cb5-76"></a><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb5-77"><a href="#cb5-77"></a>pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-78"><a href="#cb5-78"></a>    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb5-79"><a href="#cb5-79"></a>    modifySTRef&#39; stack <span class="fu">tail</span></span>
<span id="cb5-80"><a href="#cb5-80"></a>    write stackSet e <span class="dt">False</span></span>
<span id="cb5-81"><a href="#cb5-81"></a>    <span class="fu">return</span> e</span>
<span id="cb5-82"><a href="#cb5-82"></a></span>
<span id="cb5-83"><a href="#cb5-83"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb5-84"><a href="#cb5-84"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb5-85"><a href="#cb5-85"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb5-86"><a href="#cb5-86"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb5-87"><a href="#cb5-87"></a></span>
<span id="cb5-88"><a href="#cb5-88"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb5-89"><a href="#cb5-89"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-90"><a href="#cb5-90"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb5-91"><a href="#cb5-91"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb5-92"><a href="#cb5-92"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb5-93"><a href="#cb5-93"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb5-94"><a href="#cb5-94"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>This is much nicer with the applicative combinators.</p>
<p>I would like to clean up that <code>when</code> as well, and for that I’d need a function like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>which is <a href="hackage.haskell.org/package/extra/docs/Control-Monad-Extra.html#v:whenM">available in Neil Mitchell’s <code>extra</code> package</a>.</p>
<p>I don’t think it’s worth pulling in that dependency though, so I’ll just copy that definition:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>whenM</code></summary></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</span>
<span id="cb7-15"><a href="#cb7-15"></a>whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</span>
<span id="cb7-16"><a href="#cb7-16"></a></span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb7-18"><a href="#cb7-18"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>    stack    <span class="ot">&lt;-</span> newSTRef []</span>
<span id="cb7-21"><a href="#cb7-21"></a>    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb7-22"><a href="#cb7-22"></a>    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb7-23"><a href="#cb7-23"></a>    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb7-24"><a href="#cb7-24"></a>    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb7-25"><a href="#cb7-25"></a></span>
<span id="cb7-26"><a href="#cb7-26"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></span>
<span id="cb7-27"><a href="#cb7-27"></a>        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span></span>
<span id="cb7-28"><a href="#cb7-28"></a>            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb7-29"><a href="#cb7-29"></a></span>
<span id="cb7-30"><a href="#cb7-30"></a>    readSTRef output</span>
<span id="cb7-31"><a href="#cb7-31"></a>    <span class="kw">where</span></span>
<span id="cb7-32"><a href="#cb7-32"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-33"><a href="#cb7-33"></a></span>
<span id="cb7-34"><a href="#cb7-34"></a>strongConnect</span>
<span id="cb7-35"><a href="#cb7-35"></a><span class="ot">    ::</span> <span class="dt">Int</span></span>
<span id="cb7-36"><a href="#cb7-36"></a>    <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb7-37"><a href="#cb7-37"></a>    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></span>
<span id="cb7-38"><a href="#cb7-38"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb7-39"><a href="#cb7-39"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb7-40"><a href="#cb7-40"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb7-41"><a href="#cb7-41"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb7-42"><a href="#cb7-42"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb7-43"><a href="#cb7-43"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb7-44"><a href="#cb7-44"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</span>
<span id="cb7-45"><a href="#cb7-45"></a>strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-46"><a href="#cb7-46"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb7-47"><a href="#cb7-47"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb7-48"><a href="#cb7-48"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb7-49"><a href="#cb7-49"></a>    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb7-50"><a href="#cb7-50"></a>    push stack stackSet v</span>
<span id="cb7-51"><a href="#cb7-51"></a></span>
<span id="cb7-52"><a href="#cb7-52"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb7-53"><a href="#cb7-53"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-54"><a href="#cb7-54"></a>            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb7-55"><a href="#cb7-55"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</span>
<span id="cb7-56"><a href="#cb7-56"></a>        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></span>
<span id="cb7-57"><a href="#cb7-57"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</span>
<span id="cb7-58"><a href="#cb7-58"></a></span>
<span id="cb7-59"><a href="#cb7-59"></a>    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-60"><a href="#cb7-60"></a>        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</span>
<span id="cb7-61"><a href="#cb7-61"></a>        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb7-62"><a href="#cb7-62"></a></span>
<span id="cb7-63"><a href="#cb7-63"></a><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb7-64"><a href="#cb7-64"></a>addSCC n v scc stack stackSet <span class="ot">=</span> pop stack stackSet <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb7-65"><a href="#cb7-65"></a>    <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb7-66"><a href="#cb7-66"></a>    <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39; stack stackSet</span>
<span id="cb7-67"><a href="#cb7-67"></a></span>
<span id="cb7-68"><a href="#cb7-68"></a><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb7-69"><a href="#cb7-69"></a>push stack stackSet e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-70"><a href="#cb7-70"></a>    modifySTRef&#39; stack (e<span class="op">:</span>)</span>
<span id="cb7-71"><a href="#cb7-71"></a>    write stackSet e <span class="dt">True</span></span>
<span id="cb7-72"><a href="#cb7-72"></a></span>
<span id="cb7-73"><a href="#cb7-73"></a><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb7-74"><a href="#cb7-74"></a>pop stack stackSet <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-75"><a href="#cb7-75"></a>    e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb7-76"><a href="#cb7-76"></a>    modifySTRef&#39; stack <span class="fu">tail</span></span>
<span id="cb7-77"><a href="#cb7-77"></a>    write stackSet e <span class="dt">False</span></span>
<span id="cb7-78"><a href="#cb7-78"></a>    <span class="fu">return</span> e</span>
<span id="cb7-79"><a href="#cb7-79"></a></span>
<span id="cb7-80"><a href="#cb7-80"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb7-81"><a href="#cb7-81"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb7-82"><a href="#cb7-82"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb7-83"><a href="#cb7-83"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb7-84"><a href="#cb7-84"></a></span>
<span id="cb7-85"><a href="#cb7-85"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb7-86"><a href="#cb7-86"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-87"><a href="#cb7-87"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb7-88"><a href="#cb7-88"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb7-89"><a href="#cb7-89"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb7-90"><a href="#cb7-90"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb7-91"><a href="#cb7-91"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>Now I don’t actually even need <code>when</code> anymore!</p>
<p>Since most of the auxiliary functions aren’t used outside <code>strongConnect</code>, it might make sense to put them under a <code>where</code> clause. This would also make the parameters passed to <code>strongConnect</code> available to these functions. This is one place that the <code>ScopedTypeVariables</code> language extension is necessary, otherwise GHC can’t tell that the <code>s</code> in the type signature of <code>strongConnect</code> is the same <code>s</code> as the one in each type signature under the <code>where</code> clause.</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>where</code></summary></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb8-3"><a href="#cb8-3"></a></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb8-14"><a href="#cb8-14"></a></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</span>
<span id="cb8-16"><a href="#cb8-16"></a>whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb8-19"><a href="#cb8-19"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-20"><a href="#cb8-20"></a>    <span class="fu">index</span>    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb8-21"><a href="#cb8-21"></a>    stack    <span class="ot">&lt;-</span> newSTRef []</span>
<span id="cb8-22"><a href="#cb8-22"></a>    stackSet <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb8-23"><a href="#cb8-23"></a>    indices  <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb8-24"><a href="#cb8-24"></a>    lowlinks <span class="ot">&lt;-</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb8-26"><a href="#cb8-26"></a></span>
<span id="cb8-27"><a href="#cb8-27"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></span>
<span id="cb8-28"><a href="#cb8-28"></a>        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span></span>
<span id="cb8-29"><a href="#cb8-29"></a>            strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb8-30"><a href="#cb8-30"></a></span>
<span id="cb8-31"><a href="#cb8-31"></a>    readSTRef output</span>
<span id="cb8-32"><a href="#cb8-32"></a>    <span class="kw">where</span></span>
<span id="cb8-33"><a href="#cb8-33"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb8-34"><a href="#cb8-34"></a></span>
<span id="cb8-35"><a href="#cb8-35"></a>strongConnect</span>
<span id="cb8-36"><a href="#cb8-36"></a><span class="ot">    ::</span> <span class="kw">forall</span> s</span>
<span id="cb8-37"><a href="#cb8-37"></a>    <span class="op">.</span>  <span class="dt">Int</span></span>
<span id="cb8-38"><a href="#cb8-38"></a>    <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb8-39"><a href="#cb8-39"></a>    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></span>
<span id="cb8-40"><a href="#cb8-40"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb8-41"><a href="#cb8-41"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb8-42"><a href="#cb8-42"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb8-43"><a href="#cb8-43"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb8-44"><a href="#cb8-44"></a>    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb8-45"><a href="#cb8-45"></a>    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb8-46"><a href="#cb8-46"></a>    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</span>
<span id="cb8-47"><a href="#cb8-47"></a>strongConnect n v graph <span class="fu">index</span> stack stackSet indices lowlinks output <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-48"><a href="#cb8-48"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb8-49"><a href="#cb8-49"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb8-50"><a href="#cb8-50"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb8-51"><a href="#cb8-51"></a>    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb8-52"><a href="#cb8-52"></a>    push v</span>
<span id="cb8-53"><a href="#cb8-53"></a></span>
<span id="cb8-54"><a href="#cb8-54"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb8-55"><a href="#cb8-55"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb8-56"><a href="#cb8-56"></a>            strongConnect n w graph <span class="fu">index</span> stack stackSet indices lowlinks output</span>
<span id="cb8-57"><a href="#cb8-57"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</span>
<span id="cb8-58"><a href="#cb8-58"></a>        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></span>
<span id="cb8-59"><a href="#cb8-59"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</span>
<span id="cb8-60"><a href="#cb8-60"></a></span>
<span id="cb8-61"><a href="#cb8-61"></a>    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-62"><a href="#cb8-62"></a>        scc <span class="ot">&lt;-</span> addSCC n v []</span>
<span id="cb8-63"><a href="#cb8-63"></a>        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb8-64"><a href="#cb8-64"></a>    <span class="kw">where</span></span>
<span id="cb8-65"><a href="#cb8-65"></a><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb8-66"><a href="#cb8-66"></a>        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb8-67"><a href="#cb8-67"></a>            <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb8-68"><a href="#cb8-68"></a>            <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39;</span>
<span id="cb8-69"><a href="#cb8-69"></a><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb8-70"><a href="#cb8-70"></a>        push e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-71"><a href="#cb8-71"></a>            modifySTRef&#39; stack (e<span class="op">:</span>)</span>
<span id="cb8-72"><a href="#cb8-72"></a>            write stackSet e <span class="dt">True</span></span>
<span id="cb8-73"><a href="#cb8-73"></a><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb8-74"><a href="#cb8-74"></a>        pop <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-75"><a href="#cb8-75"></a>            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb8-76"><a href="#cb8-76"></a>            modifySTRef&#39; stack <span class="fu">tail</span></span>
<span id="cb8-77"><a href="#cb8-77"></a>            write stackSet e <span class="dt">False</span></span>
<span id="cb8-78"><a href="#cb8-78"></a>            <span class="fu">return</span> e</span>
<span id="cb8-79"><a href="#cb8-79"></a></span>
<span id="cb8-80"><a href="#cb8-80"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb8-81"><a href="#cb8-81"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb8-82"><a href="#cb8-82"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb8-83"><a href="#cb8-83"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb8-84"><a href="#cb8-84"></a></span>
<span id="cb8-85"><a href="#cb8-85"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb8-86"><a href="#cb8-86"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-87"><a href="#cb8-87"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb8-88"><a href="#cb8-88"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb8-89"><a href="#cb8-89"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb8-90"><a href="#cb8-90"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb8-91"><a href="#cb8-91"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>I think the logic is clearer now that the auxiliary functions take fewer arguments.</p>
<p>Instead of a large number of implictly related variables, it might be nice to define a single product type containing our entire environment and pass just one value around. With <code>NamedFieldPuns</code> only minimal code changes are required:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>NamedFieldPuns</code></summary></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb9-10"><a href="#cb9-10"></a></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb9-15"><a href="#cb9-15"></a></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="kw">data</span> <span class="dt">TarjanEnv</span> s <span class="ot">=</span> <span class="dt">TarjanEnv</span></span>
<span id="cb9-17"><a href="#cb9-17"></a>    {<span class="ot"> index    ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb9-18"><a href="#cb9-18"></a>    ,<span class="ot"> stack    ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb9-19"><a href="#cb9-19"></a>    ,<span class="ot"> stackSet ::</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb9-20"><a href="#cb9-20"></a>    ,<span class="ot"> indices  ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb9-21"><a href="#cb9-21"></a>    ,<span class="ot"> lowlinks ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb9-22"><a href="#cb9-22"></a>    ,<span class="ot"> output   ::</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb9-23"><a href="#cb9-23"></a>    }</span>
<span id="cb9-24"><a href="#cb9-24"></a></span>
<span id="cb9-25"><a href="#cb9-25"></a><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</span>
<span id="cb9-26"><a href="#cb9-26"></a>whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</span>
<span id="cb9-27"><a href="#cb9-27"></a></span>
<span id="cb9-28"><a href="#cb9-28"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb9-29"><a href="#cb9-29"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-30"><a href="#cb9-30"></a>    tarjanEnv <span class="ot">&lt;-</span> <span class="dt">TarjanEnv</span></span>
<span id="cb9-31"><a href="#cb9-31"></a>        <span class="op">&lt;$&gt;</span> newSTRef <span class="dv">0</span></span>
<span id="cb9-32"><a href="#cb9-32"></a>        <span class="op">&lt;*&gt;</span> newSTRef []</span>
<span id="cb9-33"><a href="#cb9-33"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb9-34"><a href="#cb9-34"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb9-35"><a href="#cb9-35"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb9-36"><a href="#cb9-36"></a>        <span class="op">&lt;*&gt;</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb9-37"><a href="#cb9-37"></a></span>
<span id="cb9-38"><a href="#cb9-38"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></span>
<span id="cb9-39"><a href="#cb9-39"></a>        whenM ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> (indices tarjanEnv) v) <span class="op">$</span></span>
<span id="cb9-40"><a href="#cb9-40"></a>            strongConnect n v graph tarjanEnv</span>
<span id="cb9-41"><a href="#cb9-41"></a></span>
<span id="cb9-42"><a href="#cb9-42"></a>    readSTRef (output tarjanEnv)</span>
<span id="cb9-43"><a href="#cb9-43"></a>    <span class="kw">where</span></span>
<span id="cb9-44"><a href="#cb9-44"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb9-45"><a href="#cb9-45"></a></span>
<span id="cb9-46"><a href="#cb9-46"></a><span class="ot">strongConnect ::</span> <span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">TarjanEnv</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb9-47"><a href="#cb9-47"></a>strongConnect n v graph tarjanEnv<span class="op">@</span><span class="dt">TarjanEnv</span>{ <span class="fu">index</span>, stack, stackSet, indices, lowlinks, output } <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-48"><a href="#cb9-48"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb9-49"><a href="#cb9-49"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb9-50"><a href="#cb9-50"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb9-51"><a href="#cb9-51"></a>    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb9-52"><a href="#cb9-52"></a>    push v</span>
<span id="cb9-53"><a href="#cb9-53"></a></span>
<span id="cb9-54"><a href="#cb9-54"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb9-55"><a href="#cb9-55"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb9-56"><a href="#cb9-56"></a>            strongConnect n w graph tarjanEnv</span>
<span id="cb9-57"><a href="#cb9-57"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</span>
<span id="cb9-58"><a href="#cb9-58"></a>        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></span>
<span id="cb9-59"><a href="#cb9-59"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</span>
<span id="cb9-60"><a href="#cb9-60"></a></span>
<span id="cb9-61"><a href="#cb9-61"></a>    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-62"><a href="#cb9-62"></a>        scc <span class="ot">&lt;-</span> addSCC n v []</span>
<span id="cb9-63"><a href="#cb9-63"></a>        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb9-64"><a href="#cb9-64"></a>    <span class="kw">where</span></span>
<span id="cb9-65"><a href="#cb9-65"></a><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb9-66"><a href="#cb9-66"></a>        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span> <span class="kw">else</span></span>
<span id="cb9-67"><a href="#cb9-67"></a>            <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb9-68"><a href="#cb9-68"></a>            <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39;</span>
<span id="cb9-69"><a href="#cb9-69"></a><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb9-70"><a href="#cb9-70"></a>        push e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-71"><a href="#cb9-71"></a>            modifySTRef&#39; stack (e<span class="op">:</span>)</span>
<span id="cb9-72"><a href="#cb9-72"></a>            write stackSet e <span class="dt">True</span></span>
<span id="cb9-73"><a href="#cb9-73"></a><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb9-74"><a href="#cb9-74"></a>        pop <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-75"><a href="#cb9-75"></a>            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb9-76"><a href="#cb9-76"></a>            modifySTRef&#39; stack <span class="fu">tail</span></span>
<span id="cb9-77"><a href="#cb9-77"></a>            write stackSet e <span class="dt">False</span></span>
<span id="cb9-78"><a href="#cb9-78"></a>            <span class="fu">return</span> e</span>
<span id="cb9-79"><a href="#cb9-79"></a></span>
<span id="cb9-80"><a href="#cb9-80"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb9-81"><a href="#cb9-81"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb9-82"><a href="#cb9-82"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb9-83"><a href="#cb9-83"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb9-84"><a href="#cb9-84"></a></span>
<span id="cb9-85"><a href="#cb9-85"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb9-86"><a href="#cb9-86"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-87"><a href="#cb9-87"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb9-88"><a href="#cb9-88"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb9-89"><a href="#cb9-89"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb9-90"><a href="#cb9-90"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb9-91"><a href="#cb9-91"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>Let’s pause here. Although more refactoring is certainly possible, my last two steps did not reduce the line count and may have in fact made the code harder to understand.</p>
<p>How have we benefited from this refactoring? Aside from the code being shorter and better structured, it’s now easier to make meaningful improvements. For example, this implementation is more inefficient than it needs to be, because it doesn’t short-circuit when it finds that the current problem is unsatisfiable. Instead it works through the rest of the problem, only to throw all that work away. A sophisticated solution to this problem might involve the use of the <a href="https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-Except.html"><code>ExceptT</code></a> monad transformer to throw an exception and exit early, but there is a simpler approach: we can store an extra boolean variable denoting whether or not the current problem is possibly satisfiable, and only continue working if it is. I’ll call this variable <code>possible</code>, update it in <code>addSCC</code>, and check for it before each call to <code>strongConnect</code> in <code>tarjan</code>. It takes more effort to reformat the code than to make this change:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs with short-circuiting</summary></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ot">{-# LANGUAGE NamedFieldPuns #-}</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</span>
<span id="cb10-10"><a href="#cb10-10"></a></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</span>
<span id="cb10-14"><a href="#cb10-14"></a><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</span>
<span id="cb10-15"><a href="#cb10-15"></a></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="kw">data</span> <span class="dt">TarjanEnv</span> s <span class="ot">=</span> <span class="dt">TarjanEnv</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>    {<span class="ot"> index    ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>    ,<span class="ot"> stack    ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</span>
<span id="cb10-19"><a href="#cb10-19"></a>    ,<span class="ot"> stackSet ::</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></span>
<span id="cb10-20"><a href="#cb10-20"></a>    ,<span class="ot"> indices  ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb10-21"><a href="#cb10-21"></a>    ,<span class="ot"> lowlinks ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb10-22"><a href="#cb10-22"></a>    ,<span class="ot"> output   ::</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</span>
<span id="cb10-23"><a href="#cb10-23"></a>    ,<span class="ot"> possible ::</span> <span class="dt">STRef</span> s <span class="dt">Bool</span></span>
<span id="cb10-24"><a href="#cb10-24"></a>    }</span>
<span id="cb10-25"><a href="#cb10-25"></a></span>
<span id="cb10-26"><a href="#cb10-26"></a><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</span>
<span id="cb10-27"><a href="#cb10-27"></a>whenM condM block <span class="ot">=</span> condM <span class="op">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> <span class="fu">return</span> ()</span>
<span id="cb10-28"><a href="#cb10-28"></a></span>
<span id="cb10-29"><a href="#cb10-29"></a><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</span>
<span id="cb10-30"><a href="#cb10-30"></a>tarjan n graph <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-31"><a href="#cb10-31"></a>    tarjanEnv <span class="ot">&lt;-</span> <span class="dt">TarjanEnv</span></span>
<span id="cb10-32"><a href="#cb10-32"></a>        <span class="op">&lt;$&gt;</span> newSTRef <span class="dv">0</span></span>
<span id="cb10-33"><a href="#cb10-33"></a>        <span class="op">&lt;*&gt;</span> newSTRef []</span>
<span id="cb10-34"><a href="#cb10-34"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">False</span></span>
<span id="cb10-35"><a href="#cb10-35"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb10-36"><a href="#cb10-36"></a>        <span class="op">&lt;*&gt;</span> <span class="fu">replicate</span> size <span class="dt">Nothing</span></span>
<span id="cb10-37"><a href="#cb10-37"></a>        <span class="op">&lt;*&gt;</span> newSTRef (<span class="dt">Just</span> [])</span>
<span id="cb10-38"><a href="#cb10-38"></a>        <span class="op">&lt;*&gt;</span> newSTRef <span class="dt">True</span></span>
<span id="cb10-39"><a href="#cb10-39"></a></span>
<span id="cb10-40"><a href="#cb10-40"></a>    forM_ (G.vertices graph) <span class="op">$</span> \v <span class="ot">-&gt;</span></span>
<span id="cb10-41"><a href="#cb10-41"></a>        whenM ((<span class="op">&amp;&amp;</span>)</span>
<span id="cb10-42"><a href="#cb10-42"></a>            <span class="op">&lt;$&gt;</span> ((<span class="op">==</span>) <span class="dt">Nothing</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> (indices tarjanEnv) v)</span>
<span id="cb10-43"><a href="#cb10-43"></a>            <span class="op">&lt;*&gt;</span> readSTRef (possible tarjanEnv)) <span class="op">$</span></span>
<span id="cb10-44"><a href="#cb10-44"></a>                strongConnect n v graph tarjanEnv</span>
<span id="cb10-45"><a href="#cb10-45"></a></span>
<span id="cb10-46"><a href="#cb10-46"></a>    readSTRef (output tarjanEnv)</span>
<span id="cb10-47"><a href="#cb10-47"></a>    <span class="kw">where</span></span>
<span id="cb10-48"><a href="#cb10-48"></a>        size <span class="ot">=</span> <span class="fu">snd</span> (A.bounds graph) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-49"><a href="#cb10-49"></a></span>
<span id="cb10-50"><a href="#cb10-50"></a><span class="ot">strongConnect ::</span> <span class="kw">forall</span> s<span class="op">.</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">TarjanEnv</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb10-51"><a href="#cb10-51"></a>strongConnect n v graph tarjanEnv<span class="op">@</span><span class="dt">TarjanEnv</span>{ <span class="fu">index</span>, stack, stackSet, indices, lowlinks, output, possible } <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-52"><a href="#cb10-52"></a>    i <span class="ot">&lt;-</span> readSTRef <span class="fu">index</span></span>
<span id="cb10-53"><a href="#cb10-53"></a>    write indices  v (<span class="dt">Just</span> i)</span>
<span id="cb10-54"><a href="#cb10-54"></a>    write lowlinks v (<span class="dt">Just</span> i)</span>
<span id="cb10-55"><a href="#cb10-55"></a>    modifySTRef&#39; <span class="fu">index</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb10-56"><a href="#cb10-56"></a>    push v</span>
<span id="cb10-57"><a href="#cb10-57"></a></span>
<span id="cb10-58"><a href="#cb10-58"></a>    forM_ (graph <span class="op">A.!</span> v) <span class="op">$</span> \w <span class="ot">-&gt;</span> <span class="fu">read</span> indices w <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb10-59"><a href="#cb10-59"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb10-60"><a href="#cb10-60"></a>            strongConnect n w graph tarjanEnv</span>
<span id="cb10-61"><a href="#cb10-61"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> lowlinks w)</span>
<span id="cb10-62"><a href="#cb10-62"></a>        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (<span class="fu">read</span> stackSet w) <span class="op">$</span></span>
<span id="cb10-63"><a href="#cb10-63"></a>            write lowlinks v <span class="op">=&lt;&lt;</span> (<span class="fu">min</span> <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices  w)</span>
<span id="cb10-64"><a href="#cb10-64"></a></span>
<span id="cb10-65"><a href="#cb10-65"></a>    whenM ((<span class="op">==</span>) <span class="op">&lt;$&gt;</span> <span class="fu">read</span> lowlinks v <span class="op">&lt;*&gt;</span> <span class="fu">read</span> indices v) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-66"><a href="#cb10-66"></a>        scc <span class="ot">&lt;-</span> addSCC n v []</span>
<span id="cb10-67"><a href="#cb10-67"></a>        modifySTRef&#39; output <span class="op">$</span> \sccs <span class="ot">-&gt;</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> scc <span class="op">&lt;*&gt;</span> sccs</span>
<span id="cb10-68"><a href="#cb10-68"></a>    <span class="kw">where</span></span>
<span id="cb10-69"><a href="#cb10-69"></a><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</span>
<span id="cb10-70"><a href="#cb10-70"></a>        addSCC n v scc <span class="ot">=</span> pop <span class="op">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc)</span>
<span id="cb10-71"><a href="#cb10-71"></a>            <span class="kw">then</span> writeSTRef possible <span class="dt">False</span> <span class="op">&gt;&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span></span>
<span id="cb10-72"><a href="#cb10-72"></a>            <span class="kw">else</span></span>
<span id="cb10-73"><a href="#cb10-73"></a>                <span class="kw">let</span> scc&#39; <span class="ot">=</span> w<span class="op">:</span>scc</span>
<span id="cb10-74"><a href="#cb10-74"></a>                <span class="kw">in</span> <span class="kw">if</span> w <span class="op">==</span> v <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> scc&#39;) <span class="kw">else</span> addSCC n v scc&#39;</span>
<span id="cb10-75"><a href="#cb10-75"></a><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb10-76"><a href="#cb10-76"></a>        push e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-77"><a href="#cb10-77"></a>            modifySTRef&#39; stack (e<span class="op">:</span>)</span>
<span id="cb10-78"><a href="#cb10-78"></a>            write stackSet e <span class="dt">True</span></span>
<span id="cb10-79"><a href="#cb10-79"></a><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></span>
<span id="cb10-80"><a href="#cb10-80"></a>        pop <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-81"><a href="#cb10-81"></a>            e <span class="ot">&lt;-</span> <span class="fu">head</span> <span class="op">&lt;$&gt;</span> readSTRef stack</span>
<span id="cb10-82"><a href="#cb10-82"></a>            modifySTRef&#39; stack <span class="fu">tail</span></span>
<span id="cb10-83"><a href="#cb10-83"></a>            write stackSet e <span class="dt">False</span></span>
<span id="cb10-84"><a href="#cb10-84"></a>            <span class="fu">return</span> e</span>
<span id="cb10-85"><a href="#cb10-85"></a></span>
<span id="cb10-86"><a href="#cb10-86"></a>denormalise     <span class="ot">=</span> <span class="fu">subtract</span></span>
<span id="cb10-87"><a href="#cb10-87"></a>normalise       <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb10-88"><a href="#cb10-88"></a>other n v       <span class="ot">=</span> <span class="dv">2</span><span class="op">*</span>n <span class="op">-</span> v</span>
<span id="cb10-89"><a href="#cb10-89"></a>clauses n [u,v] <span class="ot">=</span> [(other n u, v), (other n v, u)]</span>
<span id="cb10-90"><a href="#cb10-90"></a></span>
<span id="cb10-91"><a href="#cb10-91"></a><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb10-92"><a href="#cb10-92"></a>checkSat name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-93"><a href="#cb10-93"></a>    p <span class="ot">&lt;-</span> <span class="fu">map</span> (<span class="fu">map</span> P.read <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span> <span class="op">&lt;$&gt;</span> <span class="fu">readFile</span> name</span>
<span id="cb10-94"><a href="#cb10-94"></a>    <span class="kw">let</span> pNo    <span class="ot">=</span> <span class="fu">head</span> <span class="op">$</span> <span class="fu">head</span> p</span>
<span id="cb10-95"><a href="#cb10-95"></a>        pn     <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (normalise pNo)) <span class="op">$</span> <span class="fu">tail</span> p</span>
<span id="cb10-96"><a href="#cb10-96"></a>        pGraph <span class="ot">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="op">*</span>pNo) <span class="op">$</span> <span class="fu">concatMap</span> (clauses pNo) pn</span>
<span id="cb10-97"><a href="#cb10-97"></a>    <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Nothing</span> <span class="op">/=</span>) <span class="op">$</span> tarjan pNo pGraph</span></code></pre></div>
</details>
<p>This change does seem to make a significant difference, and it’s good to know we’re not doing useless work.</p>
<p>I think this is a good place to stop, and I hope I’ve been able to demonstrate some of Haskell’s strengths when it comes to refactoring. In my experience, it’s not usually necessary to deeply understand Haskell code in order to attempt a refactoring, especially if it’s backed by well-chosen types and a good test suite. I also find that I’m able to be more daring when writing new code, because bad up-front design is less costly and even the jankiest working code can be gently massaged into something presentable.</p>
<p><em>Thanks to <a href="https://joelburget.com/">Joel Burget</a>, <a href="http://www.matfournier.com/">Mat Fournier</a>, <a href="https://eskimor.gonimo.com/">Robert Klotzner</a>, <a href="https://github.com/L8D">Tenor</a>, <a href="http://www.tomharding.me/">Tom Harding</a>, and <a href="http://www.tylerweir.com/">Tyler Weir</a> for suggestions and feedback.</em></p>
</summary>
</entry>
<entry>
    <title>Moving Towards Dialogue</title>
    <link href="https://vaibhavsagar.com/blog/2018/11/03/moving-towards-dialogue/" />
    <id>https://vaibhavsagar.com/blog/2018/11/03/moving-towards-dialogue/index.html</id>
    <published>2018-11-03</published>
    <updated>2018-11-03T00:00:00Z</updated>
    <summary type="html"><div class="info">
    Posted on  3 November 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/idris/index.html">idris</a>
    
</div>

<p><em>This blog post is essentially a transcript of <a href="https://www.youtube.com/watch?v=0oo8wIi2qBE">a 10-minute talk I gave at !!Con</a>, the slides for which are available <a href="/presentations/typed-holes/">here</a>.</em></p>
<p>Let’s talk about typed holes. What’s a typed hole? A definition I like is <em>“a placeholder for an expression with a known type and an unknown value”</em>.</p>
<p>Why are typed holes useful? Because they allow the language to help us write programs! To demonstrate, let’s look at some code in Python, a language that lacks this feature.</p>
<p>Suppose I want to write a function that takes another function and a list and applies the function to each element of that list. A first stab might look like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): <span class="cf">return</span> []</span></code></pre></div>
<p>This is obviously wrong: this function ignores its arguments and gives us an empty list each time. This is no good, but what’s worse is that Python will accept this definition without complaint. It doesn’t seem to know (or care).</p>
<p>Let’s try again. I hear the way to do things with lists in Python is to use a list comprehension, so I make sure to use one of those this time:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): [f(e) <span class="cf">for</span> e <span class="kw">in</span> ls]</span>
<span id="cb2-2"><a href="#cb2-2"></a>...</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="op">&gt;&gt;&gt;</span> plusOne <span class="op">=</span> <span class="kw">lambda</span> i: i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(<span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]))</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="va">None</span></span></code></pre></div>
<p>But this definition is still wrong, because I forgot to put a <code>return</code> statement in! Again, Python will happily accept this.</p>
<p>I’m getting a bit frustrated at this point, so I look at how <code>map</code> is actually implemented. It uses a generator comprehension instead of a list comprehension, which makes it more general somehow, so I make sure to use that, and I remember to put a <code>return</code> statement in this time:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls): <span class="cf">return</span> (f(e) <span class="cf">for</span> e <span class="kw">in</span> ls)</span>
<span id="cb3-2"><a href="#cb3-2"></a>...</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(<span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]))</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="op">&lt;</span>generator <span class="bu">object</span> <span class="bu">map</span>.<span class="op">&lt;</span><span class="bu">locals</span><span class="op">&gt;</span>.<span class="op">&lt;</span>genexpr<span class="op">&gt;</span> at <span class="bn">0x7ffb92103ca8</span><span class="op">&gt;</span></span></code></pre></div>
<p>And now instead of giving me something useful, this function gives me an address in memory, which seems especially pointless.</p>
<p>I give up. This example seems contrived, but over the course of my relationship with Python, which is more than a decade long now, I’ve seen the same dynamic play out embarrassingly many times. How do I write programs that work? Surely this is a simple question with a straightforward answer.</p>
<p>Indeed, the most common response I get when I ask this question is to write tests. That sounds reasonable, so let’s do that:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> <span class="bu">map</span>(f, ls):</span>
<span id="cb4-2"><a href="#cb4-2"></a>...     <span class="bu">print</span>(<span class="st">&quot;Where are your tests now?&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3"></a>...     <span class="cf">return</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb4-4"><a href="#cb4-4"></a>...</span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="op">&gt;&gt;&gt;</span> <span class="bu">map</span>(plusOne, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb4-6"><a href="#cb4-6"></a>Where are your tests now?</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="va">True</span></span></code></pre></div>
<p>Okay, my test passes, so everything must be good, right?</p>
<p>I contend that tests are necessary, but not sufficient. They are problematic for at least two reasons:</p>
<ol type="1">
<li>They are only as good as the specification they imply for how a program should behave. If that specification is incomplete or wrong, no amount of tests will guarantee software that works.</li>
<li>The language doesn’t understand tests, by which I mean that it’s extremely difficult to automatically go from a failing test to the part of the code where the error lives. The programmer has to do the legwork of tracking down the bug based on essentially one bit of information in many cases.</li>
</ol>
<p>Fortunately, tests aren’t the only specification of how a program should behave. Types can also serve as specifications, and they have the advantage that they are extremely well integrated into the language in a way tests usually are not.</p>
<p>What does this mean in practice? Let’s look at Haskell. Haskell is statically typed, which means it expects to know the types of all the expressions in your program at compile time. This is nothing special though, lots of other languages also claim to be statically typed. What is special about Haskell though is that it has type inference, which means that you don’t have to annotate expressions with their types most of the time because the compiler can figure it out. If you put these two features together, you get typed holes!</p>
<p>Let’s try to write that same program in Haskell with typed holes. To start, let’s create a file called <code>Main.hs</code> with the following contents:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="fu">map</span> f ls <span class="ot">=</span> _</span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-10"><a href="#cb5-10"></a>main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span></code></pre></div>
<p>To automate the cycle of loading this file into GHCi every time we make a change, we’re going to use <a href="https://github.com/ndmitchell/ghcid"><code>ghcid</code></a>, which does essentially that and not much else. This is the result of running <code>ghcid Main.hs</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1"></a>Main.hs:4:12: error:</span>
<span id="cb6-2"><a href="#cb6-2"></a>    • Found hole: _ :: [b]</span>
<span id="cb6-3"><a href="#cb6-3"></a>      Where: ‘b’ is a rigid type variable bound by</span>
<span id="cb6-4"><a href="#cb6-4"></a>               the type signature for:</span>
<span id="cb6-5"><a href="#cb6-5"></a>                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span>
<span id="cb6-6"><a href="#cb6-6"></a>               at Main.hs:3:1-29</span>
<span id="cb6-7"><a href="#cb6-7"></a>    • In the expression: _</span>
<span id="cb6-8"><a href="#cb6-8"></a>      In an equation for ‘map’: map f ls = _</span>
<span id="cb6-9"><a href="#cb6-9"></a>    • Relevant bindings include</span>
<span id="cb6-10"><a href="#cb6-10"></a>        ls :: [a] (bound at Main.hs:4:7)</span>
<span id="cb6-11"><a href="#cb6-11"></a>        f :: a -&gt; b (bound at Main.hs:4:5)</span>
<span id="cb6-12"><a href="#cb6-12"></a>        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</span>
<span id="cb6-13"><a href="#cb6-13"></a>  |</span>
<span id="cb6-14"><a href="#cb6-14"></a>4 | map f ls = _</span>
<span id="cb6-15"><a href="#cb6-15"></a>  |            ^</span></code></pre></div>
<p>I’d suggest ignoring the middle and instead focusing on the top, which tells us the type of the hole, and the bottom, which tells us which bindings are in scope that we can use to fill in the hole.</p>
<p>In this case we aren’t learning anything new, and we already know that the hole is of type <code>[b]</code>, but it’s useful to know that our view of the world agrees with GHC’s. Of the bindings available to us, <code>ls</code> looks like the most promising, and we can split it into one of two cases: an empty list, or some element and the rest of the list. We can put a typed hole on the right hand side of each case alternative:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="fu">map</span> f ls <span class="ot">=</span> <span class="kw">case</span> ls <span class="kw">of</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    [] <span class="ot">-&gt;</span> _1</span>
<span id="cb7-6"><a href="#cb7-6"></a>    x<span class="op">:</span>xs <span class="ot">-&gt;</span> _2</span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-12"><a href="#cb7-12"></a>main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span></code></pre></div>
<p>And our <code>ghcid</code> output changes:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb8-1"><a href="#cb8-1"></a>Main.hs:5:11-12: error:</span>
<span id="cb8-2"><a href="#cb8-2"></a>    • Found hole: _1 :: [b]</span>
<span id="cb8-3"><a href="#cb8-3"></a>      Where: ‘b’ is a rigid type variable bound by</span>
<span id="cb8-4"><a href="#cb8-4"></a>               the type signature for:</span>
<span id="cb8-5"><a href="#cb8-5"></a>                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span>
<span id="cb8-6"><a href="#cb8-6"></a>               at Main.hs:3:1-29</span>
<span id="cb8-7"><a href="#cb8-7"></a>      Or perhaps ‘_1’ is mis-spelled, or not in scope</span>
<span id="cb8-8"><a href="#cb8-8"></a>    • In the expression: _1</span>
<span id="cb8-9"><a href="#cb8-9"></a>      In a case alternative: [] -&gt; _1</span>
<span id="cb8-10"><a href="#cb8-10"></a>      In the expression:</span>
<span id="cb8-11"><a href="#cb8-11"></a>        case ls of</span>
<span id="cb8-12"><a href="#cb8-12"></a>          [] -&gt; _1</span>
<span id="cb8-13"><a href="#cb8-13"></a>          x : xs -&gt; _2</span>
<span id="cb8-14"><a href="#cb8-14"></a>    • Relevant bindings include</span>
<span id="cb8-15"><a href="#cb8-15"></a>        ls :: [a] (bound at Main.hs:4:7)</span>
<span id="cb8-16"><a href="#cb8-16"></a>        f :: a -&gt; b (bound at Main.hs:4:5)</span>
<span id="cb8-17"><a href="#cb8-17"></a>        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</span>
<span id="cb8-18"><a href="#cb8-18"></a>  |</span>
<span id="cb8-19"><a href="#cb8-19"></a>5 |     [] -&gt; _1</span>
<span id="cb8-20"><a href="#cb8-20"></a>  |           ^^</span>
<span id="cb8-21"><a href="#cb8-21"></a>Main.hs:6:13-14: error:</span>
<span id="cb8-22"><a href="#cb8-22"></a>    • Found hole: _2 :: [b]</span>
<span id="cb8-23"><a href="#cb8-23"></a>      Where: ‘b’ is a rigid type variable bound by</span>
<span id="cb8-24"><a href="#cb8-24"></a>               the type signature for:</span>
<span id="cb8-25"><a href="#cb8-25"></a>                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span>
<span id="cb8-26"><a href="#cb8-26"></a>               at Main.hs:3:1-29</span>
<span id="cb8-27"><a href="#cb8-27"></a>      Or perhaps ‘_2’ is mis-spelled, or not in scope</span>
<span id="cb8-28"><a href="#cb8-28"></a>    • In the expression: _2</span>
<span id="cb8-29"><a href="#cb8-29"></a>      In a case alternative: x : xs -&gt; _2</span>
<span id="cb8-30"><a href="#cb8-30"></a>      In the expression:</span>
<span id="cb8-31"><a href="#cb8-31"></a>        case ls of</span>
<span id="cb8-32"><a href="#cb8-32"></a>          [] -&gt; _1</span>
<span id="cb8-33"><a href="#cb8-33"></a>          x : xs -&gt; _2</span>
<span id="cb8-34"><a href="#cb8-34"></a>    • Relevant bindings include</span>
<span id="cb8-35"><a href="#cb8-35"></a>        xs :: [a] (bound at Main.hs:6:7)</span>
<span id="cb8-36"><a href="#cb8-36"></a>        x :: a (bound at Main.hs:6:5)</span>
<span id="cb8-37"><a href="#cb8-37"></a>        ls :: [a] (bound at Main.hs:4:7)</span>
<span id="cb8-38"><a href="#cb8-38"></a>        f :: a -&gt; b (bound at Main.hs:4:5)</span>
<span id="cb8-39"><a href="#cb8-39"></a>        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</span>
<span id="cb8-40"><a href="#cb8-40"></a>  |</span>
<span id="cb8-41"><a href="#cb8-41"></a>6 |     x:xs -&gt; _2</span>
<span id="cb8-42"><a href="#cb8-42"></a>  |             ^^</span></code></pre></div>
<p>We haven’t learned anything new about the types, but we can make progress another way. The only sensible thing to put on the right hand side when given an empty list is another empty list, and after splitting a list apart the most reasonable thing to do is to combine two other things into a new list:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="fu">map</span> f ls <span class="ot">=</span> <span class="kw">case</span> ls <span class="kw">of</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>    [] <span class="ot">-&gt;</span> []</span>
<span id="cb9-6"><a href="#cb9-6"></a>    x<span class="op">:</span>xs <span class="ot">-&gt;</span> _1<span class="op">:</span>_2</span>
<span id="cb9-7"><a href="#cb9-7"></a></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb9-10"><a href="#cb9-10"></a></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-12"><a href="#cb9-12"></a>main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span></code></pre></div>
<p>Now the output gets a little more interesting:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1"></a>Main.hs:6:13-14: error:</span>
<span id="cb10-2"><a href="#cb10-2"></a>    • Found hole: _1 :: b</span>
<span id="cb10-3"><a href="#cb10-3"></a>      Where: ‘b’ is a rigid type variable bound by</span>
<span id="cb10-4"><a href="#cb10-4"></a>               the type signature for:</span>
<span id="cb10-5"><a href="#cb10-5"></a>                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span>
<span id="cb10-6"><a href="#cb10-6"></a>               at Main.hs:3:1-29</span>
<span id="cb10-7"><a href="#cb10-7"></a>      Or perhaps ‘_1’ is mis-spelled, or not in scope</span>
<span id="cb10-8"><a href="#cb10-8"></a>    • In the first argument of ‘(:)’, namely ‘_1’</span>
<span id="cb10-9"><a href="#cb10-9"></a>      In the expression: _1 : _2</span>
<span id="cb10-10"><a href="#cb10-10"></a>      In a case alternative: x : xs -&gt; _1 : _2</span>
<span id="cb10-11"><a href="#cb10-11"></a>    • Relevant bindings include</span>
<span id="cb10-12"><a href="#cb10-12"></a>        xs :: [a] (bound at Main.hs:6:7)</span>
<span id="cb10-13"><a href="#cb10-13"></a>        x :: a (bound at Main.hs:6:5)</span>
<span id="cb10-14"><a href="#cb10-14"></a>        ls :: [a] (bound at Main.hs:4:7)</span>
<span id="cb10-15"><a href="#cb10-15"></a>        f :: a -&gt; b (bound at Main.hs:4:5)</span>
<span id="cb10-16"><a href="#cb10-16"></a>        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</span>
<span id="cb10-17"><a href="#cb10-17"></a>  |</span>
<span id="cb10-18"><a href="#cb10-18"></a>6 |     x:xs -&gt; _1:_2</span>
<span id="cb10-19"><a href="#cb10-19"></a>  |             ^^</span>
<span id="cb10-20"><a href="#cb10-20"></a>Main.hs:6:16-17: error:</span>
<span id="cb10-21"><a href="#cb10-21"></a>    • Found hole: _2 :: [b]</span>
<span id="cb10-22"><a href="#cb10-22"></a>      Where: ‘b’ is a rigid type variable bound by</span>
<span id="cb10-23"><a href="#cb10-23"></a>               the type signature for:</span>
<span id="cb10-24"><a href="#cb10-24"></a>                 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]</span>
<span id="cb10-25"><a href="#cb10-25"></a>               at Main.hs:3:1-29</span>
<span id="cb10-26"><a href="#cb10-26"></a>      Or perhaps ‘_2’ is mis-spelled, or not in scope</span>
<span id="cb10-27"><a href="#cb10-27"></a>    • In the second argument of ‘(:)’, namely ‘_2’</span>
<span id="cb10-28"><a href="#cb10-28"></a>      In the expression: _1 : _2</span>
<span id="cb10-29"><a href="#cb10-29"></a>      In a case alternative: x : xs -&gt; _1 : _2</span>
<span id="cb10-30"><a href="#cb10-30"></a>    • Relevant bindings include</span>
<span id="cb10-31"><a href="#cb10-31"></a>        xs :: [a] (bound at Main.hs:6:7)</span>
<span id="cb10-32"><a href="#cb10-32"></a>        x :: a (bound at Main.hs:6:5)</span>
<span id="cb10-33"><a href="#cb10-33"></a>        ls :: [a] (bound at Main.hs:4:7)</span>
<span id="cb10-34"><a href="#cb10-34"></a>        f :: a -&gt; b (bound at Main.hs:4:5)</span>
<span id="cb10-35"><a href="#cb10-35"></a>        map :: (a -&gt; b) -&gt; [a] -&gt; [b] (bound at Main.hs:4:1)</span>
<span id="cb10-36"><a href="#cb10-36"></a>  |</span>
<span id="cb10-37"><a href="#cb10-37"></a>6 |     x:xs -&gt; _1:_2</span>
<span id="cb10-38"><a href="#cb10-38"></a>  |                ^^</span></code></pre></div>
<p>Our first hole is now of type <code>b</code>, and we see that it’s possible to get a value of this type by applying <code>f</code> to <code>x</code>. The second hole is still of type <code>[b]</code>, and we see that the most reasonable way to get a value of this type is to recurse, using <code>map</code> with <code>f</code> and <code>xs</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="fu">map</span> f ls <span class="ot">=</span> <span class="kw">case</span> ls <span class="kw">of</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>    [] <span class="ot">-&gt;</span> []</span>
<span id="cb11-6"><a href="#cb11-6"></a>    x<span class="op">:</span>xs <span class="ot">-&gt;</span> f x<span class="op">:</span> <span class="fu">map</span> f xs</span>
<span id="cb11-7"><a href="#cb11-7"></a></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb11-10"><a href="#cb11-10"></a></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-12"><a href="#cb11-12"></a>main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span></code></pre></div>
<p>And <code>ghcid</code> is satisfied:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb12-1"><a href="#cb12-1"></a>All good (1 module, at &lt;time&gt;)</span></code></pre></div>
<p>It compiles! But does it work?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1"></a>$ <span class="ex">runhaskell</span> Main.hs</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="ex">True</span></span></code></pre></div>
<p>Fantastic! We were able to ask the compiler for hints and get useful answers back. This is a gigantic improvement over anything I’m aware of in Python land.</p>
<p>Unfortunately, there is a catch: this program is too easy to break. Let me demonstrate my favourite way:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (map)</span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="fu">map</span> f ls <span class="ot">=</span> []</span>
<span id="cb14-5"><a href="#cb14-5"></a></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="ot">plusOne ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>plusOne i <span class="ot">=</span> i <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb14-10"><a href="#cb14-10"></a>main <span class="ot">=</span> <span class="fu">print</span> ((<span class="fu">map</span> plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="op">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span></code></pre></div>
<p>The astute reader will notice that this is the Haskell equivalent of the obviously broken Python program we started with. Here is what <code>ghcid</code> has to say:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1"></a>All good (1 module, at &lt;time&gt;)</span></code></pre></div>
<p>So what’s going on here? It turns out an empty list is a valid list of any type. Is it a list of Strings? Yup. Is it a list of Ints? Sure!</p>
<p>One way of avoiding this class of incorrect program is to specify that the input and the output lists should be of the same length. It’s possible to do this in Haskell, but it is a lot of work. Can we do better?</p>
<p>Enter Idris.</p>
<p>Idris is a functional programming language with a more sophisticated type system than Haskell’s. Unfortunately it trades off some type inference to achieve this, so it’s not strictly better than Haskell in every way. It has excellent built-in editor support, and therefore has fancier typed holes!</p>
<p>Let’s try to implement <code>map</code> again:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</span>
<span id="cb16-3"><a href="#cb16-3"></a>    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a>implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></span>
<span id="cb16-7"><a href="#cb16-7"></a>    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</span>
<span id="cb16-8"><a href="#cb16-8"></a></span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb16-12"><a href="#cb16-12"></a>plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></span>
<span id="cb16-13"><a href="#cb16-13"></a></span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</span>
<span id="cb16-15"><a href="#cb16-15"></a>main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span></code></pre></div>
<p>Instead of implementing <code>map</code> on lists, we’ll use a more interesting type called <code>Vect</code> which is essentially a list that knows about its length. A <code>Vect</code> can either be <code>Nil</code> of length <code>0</code> or an element on the front of another <code>Vect</code> of some length <code>length</code> giving us a new <code>Vect</code> of length <code>length + 1</code>. I’ve also gone ahead defined equality on these <code>Vect</code>s because I use it in <code>main</code>.</p>
<p>Loading the file into the Idris REPL gives us access to the editor integration:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1"></a>$ <span class="ex">idris</span> Main.idr</span>
<span id="cb17-2"><a href="#cb17-2"></a>     <span class="ex">____</span>    __     _</span>
<span id="cb17-3"><a href="#cb17-3"></a>    <span class="ex">/</span>  _/___/ /____(_)<span class="ex">____</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>    <span class="ex">/</span> // __  / ___/ / ___/     Version 1.3.0</span>
<span id="cb17-5"><a href="#cb17-5"></a>  <span class="ex">_/</span> // /_/ / /  / (__  )      <span class="ex">http</span>://www.idris-lang.org/</span>
<span id="cb17-6"><a href="#cb17-6"></a> <span class="ex">/___</span>/\<span class="ex">__</span>,_/_/  /_/____/       Type :? for help</span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="ex">Idris</span> is free software with ABSOLUTELY NO WARRANTY.</span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="ex">For</span> details type :warranty.</span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="ex">Type</span> checking ./Main.idr</span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="ex">Holes</span>: Main.map</span>
<span id="cb17-12"><a href="#cb17-12"></a><span class="ex">*Main</span><span class="op">&gt;</span></span></code></pre></div>
<p>In vim, I can use <code>&lt;localleader&gt;d</code> with the cursor on <code>map</code> to fill in a skeleton definition:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</span>
<span id="cb18-3"><a href="#cb18-3"></a>    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a>implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></span>
<span id="cb18-7"><a href="#cb18-7"></a>    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</span>
<span id="cb18-8"><a href="#cb18-8"></a></span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</span>
<span id="cb18-10"><a href="#cb18-10"></a>map f x <span class="fu">=</span> <span class="ot">?map_rhs</span></span>
<span id="cb18-11"><a href="#cb18-11"></a></span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-13"><a href="#cb18-13"></a>plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></span>
<span id="cb18-14"><a href="#cb18-14"></a></span>
<span id="cb18-15"><a href="#cb18-15"></a><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</span>
<span id="cb18-16"><a href="#cb18-16"></a>main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span></code></pre></div>
<p>Using <code>&lt;localleader&gt;t</code> with the cursor on the typed hole provides a type for us:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1"></a>  b : Type</span>
<span id="cb19-2"><a href="#cb19-2"></a>  a : Type</span>
<span id="cb19-3"><a href="#cb19-3"></a>  f : a -&gt; b</span>
<span id="cb19-4"><a href="#cb19-4"></a>  length : Nat</span>
<span id="cb19-5"><a href="#cb19-5"></a>  x : Vect length a</span>
<span id="cb19-6"><a href="#cb19-6"></a>--------------------------------------</span>
<span id="cb19-7"><a href="#cb19-7"></a>map_rhs : Vect length b</span></code></pre></div>
<p>But we don’t need to go down this route. We can make Idris do a case-split for us with <code>&lt;localleader&gt;c</code> with the cursor on <code>x</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</span>
<span id="cb20-3"><a href="#cb20-3"></a>    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</span>
<span id="cb20-4"><a href="#cb20-4"></a></span>
<span id="cb20-5"><a href="#cb20-5"></a>implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></span>
<span id="cb20-7"><a href="#cb20-7"></a>    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</span>
<span id="cb20-8"><a href="#cb20-8"></a></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</span>
<span id="cb20-10"><a href="#cb20-10"></a>map f [] <span class="fu">=</span> <span class="ot">?map_rhs_1</span></span>
<span id="cb20-11"><a href="#cb20-11"></a>map f (x <span class="ot">::</span> y) <span class="fu">=</span> <span class="ot">?map_rhs_2</span></span>
<span id="cb20-12"><a href="#cb20-12"></a></span>
<span id="cb20-13"><a href="#cb20-13"></a><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-14"><a href="#cb20-14"></a>plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></span>
<span id="cb20-15"><a href="#cb20-15"></a></span>
<span id="cb20-16"><a href="#cb20-16"></a><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</span>
<span id="cb20-17"><a href="#cb20-17"></a>main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span></code></pre></div>
<p>Again, as with our Haskell example, the only sensible output when the input is an empty <code>Vect</code> is another empty <code>Vect</code>. We think so, but what does Idris think? It has a nifty feature called “proof search” that can search the space of all possible programs that fit and choose the first one. We can use this with <code>&lt;localleader&gt;o</code> (‘o’ is for obvious):</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</span>
<span id="cb21-3"><a href="#cb21-3"></a>    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</span>
<span id="cb21-4"><a href="#cb21-4"></a></span>
<span id="cb21-5"><a href="#cb21-5"></a>implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</span>
<span id="cb21-8"><a href="#cb21-8"></a></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</span>
<span id="cb21-10"><a href="#cb21-10"></a>map f [] <span class="fu">=</span> []</span>
<span id="cb21-11"><a href="#cb21-11"></a>map f (x <span class="ot">::</span> y) <span class="fu">=</span> <span class="ot">?map_rhs_2</span></span>
<span id="cb21-12"><a href="#cb21-12"></a></span>
<span id="cb21-13"><a href="#cb21-13"></a><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb21-14"><a href="#cb21-14"></a>plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></span>
<span id="cb21-15"><a href="#cb21-15"></a></span>
<span id="cb21-16"><a href="#cb21-16"></a><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</span>
<span id="cb21-17"><a href="#cb21-17"></a>main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span></code></pre></div>
<p>And we get the result we expect. This works for the simple case, but does it work for the more complex one?</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb22-1"><a href="#cb22-1"></a><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</span>
<span id="cb22-3"><a href="#cb22-3"></a>    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</span>
<span id="cb22-4"><a href="#cb22-4"></a></span>
<span id="cb22-5"><a href="#cb22-5"></a>implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</span>
<span id="cb22-10"><a href="#cb22-10"></a>map f [] <span class="fu">=</span> []</span>
<span id="cb22-11"><a href="#cb22-11"></a>map f (x <span class="ot">::</span> y) <span class="fu">=</span> f x <span class="ot">::</span> map f y</span>
<span id="cb22-12"><a href="#cb22-12"></a></span>
<span id="cb22-13"><a href="#cb22-13"></a><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb22-14"><a href="#cb22-14"></a>plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></span>
<span id="cb22-15"><a href="#cb22-15"></a></span>
<span id="cb22-16"><a href="#cb22-16"></a><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</span>
<span id="cb22-17"><a href="#cb22-17"></a>main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span></code></pre></div>
<p>It does!</p>
<p>What happens when we try to break this like we broke our Haskell program?</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode idris"><code class="sourceCode idris"><span id="cb23-1"><a href="#cb23-1"></a><span class="kw">data</span> <span class="dt">Vect</span> <span class="ot">:</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>    <span class="dt">Nil</span>  <span class="ot">:</span> <span class="dt">Vect</span> <span class="dv">0</span> a</span>
<span id="cb23-3"><a href="#cb23-3"></a>    <span class="fu">(::)</span> <span class="ot">:</span> a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> (<span class="dv">1</span> <span class="fu">+</span> length) a</span>
<span id="cb23-4"><a href="#cb23-4"></a></span>
<span id="cb23-5"><a href="#cb23-5"></a>implementation (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Vect</span> l a) <span class="kw">where</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>    (<span class="fu">==</span>) []      []      <span class="fu">=</span> <span class="dt">True</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>    (<span class="fu">==</span>) (x<span class="ot">::</span>xs) (y<span class="ot">::</span>ys) <span class="fu">=</span> x <span class="fu">==</span> y <span class="fu">&amp;&amp;</span> xs <span class="fu">==</span> ys</span>
<span id="cb23-8"><a href="#cb23-8"></a></span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="fu">map</span> <span class="ot">:</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vect</span> length a <span class="ot">-&gt;</span> <span class="dt">Vect</span> length b</span>
<span id="cb23-10"><a href="#cb23-10"></a>map f [] <span class="fu">=</span> []</span>
<span id="cb23-11"><a href="#cb23-11"></a>map f (x <span class="ot">::</span> y) <span class="fu">=</span> []</span>
<span id="cb23-12"><a href="#cb23-12"></a></span>
<span id="cb23-13"><a href="#cb23-13"></a><span class="fu">plusOne</span> <span class="ot">:</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb23-14"><a href="#cb23-14"></a>plusOne i <span class="fu">=</span> i <span class="fu">+</span> <span class="dv">1</span></span>
<span id="cb23-15"><a href="#cb23-15"></a></span>
<span id="cb23-16"><a href="#cb23-16"></a><span class="fu">main</span> <span class="ot">:</span> <span class="dt">IO</span> ()</span>
<span id="cb23-17"><a href="#cb23-17"></a>main <span class="fu">=</span> printLn ((map plusOne [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]) <span class="fu">==</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>])</span></code></pre></div>
<p>This is what Idris has to say:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1"></a>*Main&gt; :r</span>
<span id="cb24-2"><a href="#cb24-2"></a>Type checking ./Main.idr</span>
<span id="cb24-3"><a href="#cb24-3"></a>Main.idr:11:18-19:</span>
<span id="cb24-4"><a href="#cb24-4"></a>   |</span>
<span id="cb24-5"><a href="#cb24-5"></a>11 | map f (x :: y) = []</span>
<span id="cb24-6"><a href="#cb24-6"></a>   |                  ~~</span>
<span id="cb24-7"><a href="#cb24-7"></a>When checking right hand side of Main.map with expected type</span>
<span id="cb24-8"><a href="#cb24-8"></a>        Vect (1 + length) b</span>
<span id="cb24-9"><a href="#cb24-9"></a></span>
<span id="cb24-10"><a href="#cb24-10"></a>Type mismatch between</span>
<span id="cb24-11"><a href="#cb24-11"></a>        Vect 0 a (Type of [])</span>
<span id="cb24-12"><a href="#cb24-12"></a>and</span>
<span id="cb24-13"><a href="#cb24-13"></a>        Vect (S length) b (Expected type)</span>
<span id="cb24-14"><a href="#cb24-14"></a></span>
<span id="cb24-15"><a href="#cb24-15"></a>Specifically:</span>
<span id="cb24-16"><a href="#cb24-16"></a>        Type mismatch between</span>
<span id="cb24-17"><a href="#cb24-17"></a>                0</span>
<span id="cb24-18"><a href="#cb24-18"></a>        and</span>
<span id="cb24-19"><a href="#cb24-19"></a>                S length</span>
<span id="cb24-20"><a href="#cb24-20"></a></span>
<span id="cb24-21"><a href="#cb24-21"></a>Holes: Main.map</span></code></pre></div>
<p>We get a useful and informative error message.</p>
<p>And we’ve done it! You can download and use these languages today. When using other languages with static types, I always felt that they existed merely as busywork and I essentially had to shove them down the compiler’s throat in order to get it to accept my program, and I feel the opposite way about these languages. In other words, types are friends, not food! They can help you design your program, write that program, and even debug it if necessary.</p>
<p>One aspect of programming that always bothered me was my perception of the compiler (or interpreter) as some sort of gatekeeper whose job was to dismiss my program until it met some arbitrary standard. Even worse, I would find myself writing a program that passed but was subtly incorrect, and I would iterate on this process, writing a series of subtly incorrect programs without any guidance from my tools. Discovering typed holes and the style of programming they enable has shown me a different approach, where I can open up a dialogue with my language and collaborate on writing a program whose correctness I am more confident of.</p>
<p>That’s all I have to say about typed holes, but there’s recently been interesting work on untyped holes that I would like to mention briefly. Suppose you like the idea of holes but not the idea of types, or you work in a language that isn’t statically typed and you want some of these benefits. What you could do is:</p>
<ol type="1">
<li>Write a program with gaps where you’re unsure what should happen (we’ll call this a <em>sketch</em>)</li>
<li>Write some test cases that the correct program should satisfy</li>
<li>Feed both these things to a SAT/SMT solver (a clever program with a bag of tricks)</li>
<li>???</li>
<li>Profit!!!</li>
</ol>
<p>The solver churns through the space of all prossible programs and picks the one that passes the tests, giving us the correct program we wanted!</p>
<p>This sounds great in theory, so why aren’t we doing this yet? There is (predictably) a catch, which is that this is still a research topic for now. You can read <a href="https://people.csail.mit.edu/asolar/papers/thesis.pdf">Armando Solar-Lezama’s PhD thesis on this</a>, and systems like <a href="http://comcom.csail.mit.edu/comcom/#Synquid">Synquid</a> and <a href="https://github.com/webyrd/Barliman">Barliman</a> demonstrate the current state of the art. I think it’s especially interesting that Synquid has both typed and untyped holes, which suggests to me that it is the most promising approach.</p>
<p>I’ll leave you with some resources about typed holes, particularly Conor McBride’s presentations at <a href="https://www.youtube.com/watch?v=3U3lV5VPmOU">YOW! Lambda Jam</a> and <a href="https://skillsmatter.com/skillscasts/8893-is-a-type-a-lifebuoy-or-a-lamp">Haskell eXchange</a> that are rich with insight. There’s also <a href="https://www.shimweasel.com/2015/02/17/typed-holes-for-beginners">a tutorial by Mark Wotton</a>, and finally <a href="http://hazel.org/">Hazel</a>, which is a live functional programming environment with typed holes!</p>
<p>I hope I’ve encouraged you to try this style of programming for yourself. There’s never been a better time to do it.</p>
</summary>
</entry>
<entry>
    <title>HAMTs from Scratch</title>
    <link href="https://vaibhavsagar.com/blog/2018/07/29/hamts-from-scratch/" />
    <id>https://vaibhavsagar.com/blog/2018/07/29/hamts-from-scratch/index.html</id>
    <published>2018-07-29</published>
    <updated>2018-07-29T00:00:00Z</updated>
    <summary type="html"><div class="info">
    Posted on 29 July 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/programming/index.html">programming</a>, <a href="/blog/tags/haskell/index.html">haskell</a>
    
</div>

<p><em>This blog post is also an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/hamt/HAMTsFromScratch.ipynb">IHaskell notebook</a> and the source is available <a href="https://github.com/vaibhavsagar/notebooks/tree/master/hamt/hamt">separately</a>. I also <a href="https://www.youtube.com/watch?v=wgMgtgVZdYg">did a talk at NYHUG based on this material</a>.</em></p>
<p>I wanted an explanation for HAMTs (Hash Array Mapped Tries) that was more detailed than <a href="https://idea.popcount.org/2012-07-25-introduction-to-hamt/">Marek Majkowski’s introduction</a> and more approachable than <a href="https://lampwww.epfl.ch/papers/idealhashtrees.pdf"><em>Ideal Hash Trees</em> by Phil Bagwell</a>, the paper that introduced them. If you haven’t heard of them before, HAMTs are a way of efficiently representing a hashtable as a <a href="https://en.wikipedia.org/wiki/Trie">trie</a>, and although they were first envisioned as a mutable data structure they are easily adapted to work as a <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent data structure</a>. They form the backbone of the <a href="http://hackage.haskell.org/package/unordered-containers"><code>unordered-containers</code></a> library but the <a href="https://github.com/tibbe/unordered-containers/blob/efa43a2ab09dc6eb72893d12676a8e188cb4ca63/Data/HashMap/Base.hs">implementation has been lovingly optimised</a> to the point where I found it impenetrable. <a href="https://github.com/ezyang/hamt/blob/a43559795630980eb16ab832a003d8e6acd21cf6/HAMT.hs">Edward Z. Yang’s implementation</a> is much easier to follow and after adapting it I think I’m in a good place to provide my own take on them.</p>
<p>Let’s start with a few imports! I’ll be using these packages:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/base"><code>base</code></a></li>
<li><a href="http://hackage.haskell.org/package/bytestring"><code>bytestring</code></a></li>
<li><a href="http://hackage.haskell.org/package/memory"><code>memory</code></a></li>
<li><a href="http://hackage.haskell.org/package/pretty-show"><code>pretty-show</code></a></li>
<li><a href="http://hackage.haskell.org/package/timeit"><code>timeit</code></a></li>
<li><a href="http://hackage.haskell.org/package/vector"><code>vector</code></a></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">import</span> <span class="dt">Data.Bits</span>             (<span class="dt">Bits</span> (bit, complement, popCount, shiftR, (.&amp;.), (.|.)),</span>
<span id="cb1-2"><a href="#cb1-2"></a>                              <span class="dt">FiniteBits</span> (finiteBitSize))</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span> <span class="dt">Data.ByteArray.Hash</span>   (<span class="dt">FnvHash32</span> (..), fnv1Hash)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Char8</span> (pack)</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span> <span class="dt">Data.Char</span>             (intToDigit)</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">import</span> <span class="dt">Data.Semigroup</span>        ((&lt;&gt;))</span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">import</span> <span class="dt">Data.Vector</span>           (<span class="dt">Vector</span>, drop, singleton, take, (!), (//))</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="kw">import</span> <span class="dt">Data.Word</span>             (<span class="dt">Word16</span>, <span class="dt">Word32</span>)</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">import</span> <span class="dt">Numeric</span>               (showIntAtBase)</span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">import</span> <span class="dt">Prelude</span>               <span class="kw">hiding</span> (drop, lookup, take)</span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">import</span> <span class="dt">System.TimeIt</span>         (timeIt)</span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span>      (pPrint)</span></code></pre></div>
<p>We’re going to be doing some bit twiddling. To make this easier to follow I’m going to define a <code>newtype</code> whose <code>Show</code> instance displays the binary representation.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">newtype</span> <span class="dt">Binary</span> a <span class="ot">=</span> <span class="dt">Binary</span> a</span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="kw">deriving</span> (<span class="dt">Enum</span>, <span class="dt">Ord</span>, <span class="dt">Real</span>, <span class="dt">Integral</span>, <span class="dt">Eq</span>, <span class="dt">Num</span>, <span class="dt">Bits</span>, <span class="dt">FiniteBits</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="kw">instance</span> (<span class="dt">FiniteBits</span> a, <span class="dt">Show</span> a, <span class="dt">Integral</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Binary</span> a) <span class="kw">where</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="fu">show</span> (<span class="dt">Binary</span> n) <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>        str <span class="ot">=</span> showIntAtBase <span class="dv">2</span> <span class="fu">intToDigit</span> n <span class="st">&quot;&quot;</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>        size <span class="ot">=</span> finiteBitSize n</span>
<span id="cb2-10"><a href="#cb2-10"></a>        <span class="kw">in</span> <span class="fu">replicate</span> (size <span class="op">-</span> <span class="fu">length</span> str) <span class="ch">&#39;0&#39;</span> <span class="op">&lt;&gt;</span> str</span></code></pre></div>
<p>Using this <code>newtype</code> we can turn this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="dv">24732</span><span class="ot"> ::</span> <span class="dt">Word16</span></span></code></pre></div>
<pre><code>24732</code></pre>
<p>into this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="dv">24732</span><span class="ot"> ::</span> <span class="dt">Binary</span> <span class="dt">Word16</span></span></code></pre></div>
<pre><code>0110000010011100</code></pre>
<p>I’m going to use 32-bit hashes (because they’re more convenient to display than 64-bit ones) and 16-bit bitmaps.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">type</span> <span class="dt">Hash</span> <span class="ot">=</span> <span class="dt">Binary</span> <span class="dt">Word32</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">type</span> <span class="dt">Bitmap</span> <span class="ot">=</span> <span class="dt">Binary</span> <span class="dt">Word16</span></span></code></pre></div>
<p>The width of bitmaps is <span class="math inline">2<sup><em>n</em></sup></span> where <span class="math inline"><em>n</em></span> is the number of bits of the hash that we use at each level of the tree (more on this below). I’m setting <span class="math inline"><em>n</em> = 4</span> which is what <code>unordered-containers</code> uses (as of this writing), but we could e.g. set <span class="math inline"><em>n</em> = 5</span> and use 32-bit bitmaps if we wanted.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">bitsPerSubkey ::</span> <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>bitsPerSubkey <span class="ot">=</span> <span class="dv">4</span></span></code></pre></div>
<p><code>Shift</code> is a multiple of <span class="math inline"><em>n</em></span> that we will use to focus on the correct part of the hash.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">type</span> <span class="dt">Shift</span> <span class="ot">=</span> <span class="dt">Int</span></span></code></pre></div>
<p>I’m also going to define a <code>Hashable</code> class to decouple the choice of a hash function from the implementation of <code>HAMT</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">class</span> <span class="dt">Hashable</span> a <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ot">    hash ::</span> a <span class="ot">-&gt;</span> <span class="dt">Hash</span></span></code></pre></div>
<p>For convenience, we’ll use the FNV-1 hash function with strings.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">String</span> <span class="kw">where</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>    hash s <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>        <span class="dt">FnvHash32</span> h <span class="ot">=</span> fnv1Hash (<span class="fu">pack</span> s)</span>
<span id="cb11-7"><a href="#cb11-7"></a>        <span class="kw">in</span> <span class="dt">Binary</span> h</span></code></pre></div>
<p>Here’s what it looks like in practice.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a>hash <span class="st">&quot;1&quot;</span><span class="ot"> ::</span> <span class="dt">Binary</span> <span class="dt">Word32</span></span></code></pre></div>
<pre><code>00000101000011000101110100101110</code></pre>
<p>A HAMT can be</p>
<ul>
<li>empty (<code>None</code>)</li>
<li>a leaf node with the hash, the key, and the value (<code>Leaf</code>)</li>
<li>a node with a bitmap and a (non-empty) vector of child HAMTs (<code>Many</code>)</li>
</ul>
<p>I’ve chosen to ignore the possibility of collisions, but we could handle them by adding an extra constructor, e.g. <code>Colliding</code> with a hash and a vector of key-value pairs.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">data</span> <span class="dt">HAMT</span> key value</span>
<span id="cb14-2"><a href="#cb14-2"></a>    <span class="ot">=</span> <span class="dt">None</span></span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="op">|</span> <span class="dt">Leaf</span> <span class="dt">Hash</span> key value</span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="op">|</span> <span class="dt">Many</span> <span class="dt">Bitmap</span> (<span class="dt">Vector</span> (<span class="dt">HAMT</span> key value))</span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="ot">empty ::</span> <span class="dt">HAMT</span> k v</span>
<span id="cb14-8"><a href="#cb14-8"></a>empty <span class="ot">=</span> <span class="dt">None</span></span></code></pre></div>
<p>We’ll need some helper functions for vectors:</p>
<ul>
<li><code>insertAt</code> inserts an element at a specified index, shifting elements to the right forwards</li>
<li><code>updateAt</code> replaces an element at a specified index with a new element</li>
<li><code>deleteAt</code> removes an element at an index, shifting elements to the right backwards</li>
</ul>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">insertAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</span>
<span id="cb15-2"><a href="#cb15-2"></a>insertAt vector <span class="fu">index</span> a <span class="ot">=</span> <span class="fu">take</span> <span class="fu">index</span> vector <span class="op">&lt;&gt;</span> singleton a <span class="op">&lt;&gt;</span> <span class="fu">drop</span> <span class="fu">index</span> vector</span>
<span id="cb15-3"><a href="#cb15-3"></a></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="ot">updateAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</span>
<span id="cb15-5"><a href="#cb15-5"></a>updateAt vector <span class="fu">index</span> a <span class="ot">=</span> vector <span class="op">//</span> [(<span class="fu">index</span>, a)]</span>
<span id="cb15-6"><a href="#cb15-6"></a></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="ot">deleteAt ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</span>
<span id="cb15-8"><a href="#cb15-8"></a>deleteAt vector <span class="fu">index</span> <span class="ot">=</span> <span class="fu">take</span> <span class="fu">index</span> vector <span class="op">&lt;&gt;</span> <span class="fu">drop</span> (<span class="fu">index</span><span class="op">+</span><span class="dv">1</span>) vector</span></code></pre></div>
<h3 id="insert">Insert</h3>
<p>I think the bit manipulation functions are crucial to understanding what’s going on, so I’m going to motivate them by trying to define <code>insert</code> without them and coming up with them as they are needed. This initial definition won’t be quite right so I’ll call it <code>insert_</code> to differentiate it from the correct <code>insert'</code> function I present later. The type signature for <code>insert_</code> is</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="ot">insert_ ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</span></code></pre></div>
<p>Inserting a key-value pair into an empty HAMT gives us a single leaf node:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a>insert_ hash key value <span class="dt">None</span> <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</span></code></pre></div>
<p>Inserting a key-value pair into a single leaf node where the hashes match gives us an updated leaf node (because we’re pretending collisions don’t exist):</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>insert_ hash key value (<span class="dt">Leaf</span> leafHash leafKey leafValue)</span>
<span id="cb18-2"><a href="#cb18-2"></a>    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</span></code></pre></div>
<p>Inserting into a HAMT consisting of a single leaf node where the hashes don’t match upgrades that leaf node to a <code>Many</code> node and inserts the key-value pair into that <code>Many</code> node:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a>insert_ hash key value leaf<span class="op">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</span>
<span id="cb19-2"><a href="#cb19-2"></a>    <span class="op">|</span> hash <span class="op">/=</span> leafHash <span class="ot">=</span> insert_ key value (<span class="dt">Many</span> someBitmap (singleton leaf))</span>
<span id="cb19-3"><a href="#cb19-3"></a>    <span class="kw">where</span> someBitmap <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<h4 id="bit-masking">Bit Masking</h4>
<p>Where does <code>someBitmap</code> come from? Time for an example! Let’s start with a <code>Leaf (hash "1") "1" 1</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a>h <span class="ot">=</span> hash <span class="st">&quot;1&quot;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>leaf <span class="ot">=</span> <span class="dt">Leaf</span> h <span class="st">&quot;1&quot;</span> <span class="dv">1</span></span>
<span id="cb20-3"><a href="#cb20-3"></a></span>
<span id="cb20-4"><a href="#cb20-4"></a>leaf</span></code></pre></div>
<pre><code>Leaf 00000101000011000101110100101110 &quot;1&quot; 1</code></pre>
<p><code>someBitMap</code> is a 16-bit bitmap where the number of bits set (the <code>popCount</code>) is the length of the vector, which in this case is <span class="math inline">1</span>. We want to set one bit, but which bit? We carve off the last <span class="math inline"><em>n</em></span> bits using a mask:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="ot">subkeyMask ::</span> <span class="dt">Bitmap</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>subkeyMask <span class="ot">=</span> (bit bitsPerSubkey) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb22-3"><a href="#cb22-3"></a></span>
<span id="cb22-4"><a href="#cb22-4"></a>subkeyMask</span></code></pre></div>
<pre><code>0000000000001111</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="co">--     0101110100101110</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="co">-- .&amp;. 0000000000001111</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="co">-----------------------</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="co">--     0000000000001110</span></span>
<span id="cb24-5"><a href="#cb24-5"></a></span>
<span id="cb24-6"><a href="#cb24-6"></a>fragment <span class="ot">=</span> <span class="fu">fromIntegral</span> h <span class="op">.&amp;.</span> subkeyMask</span>
<span id="cb24-7"><a href="#cb24-7"></a></span>
<span id="cb24-8"><a href="#cb24-8"></a>fragment</span></code></pre></div>
<pre><code>0000000000001110</code></pre>
<p>Then we interpret that fragment as a number:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a><span class="dt">Binary</span> position <span class="ot">=</span> fragment</span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a>position</span></code></pre></div>
<pre><code>14</code></pre>
<p>Finally, we set that bit and we have our bitmap:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="ot">someBitmap ::</span> <span class="dt">Bitmap</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>someBitmap <span class="ot">=</span> <span class="dt">Binary</span> <span class="op">$</span> bit <span class="op">$</span> <span class="fu">fromIntegral</span> position</span>
<span id="cb28-3"><a href="#cb28-3"></a></span>
<span id="cb28-4"><a href="#cb28-4"></a>someBitmap</span></code></pre></div>
<pre><code>0100000000000000</code></pre>
<p>We’re going to be doing this a lot, so I’ll define this as <code>bitMask_</code>. The extra <code>_</code> is because it isn’t quite right for the same reason as <code>insert_</code>:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="ot">bitMask_ ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>bitMask_ hash <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>    fragment <span class="ot">=</span> <span class="fu">fromIntegral</span> hash <span class="op">.&amp;.</span> subkeyMask</span>
<span id="cb30-4"><a href="#cb30-4"></a>    <span class="dt">Binary</span> position <span class="ot">=</span> fragment</span>
<span id="cb30-5"><a href="#cb30-5"></a>    <span class="kw">in</span> <span class="dt">Binary</span> (bit (<span class="fu">fromIntegral</span> position))</span></code></pre></div>
<p>Let’s look at the <code>Many</code> case. If we try inserting into a node where the bit in the bitmap corresponding to the mask is <code>0</code>, this means that there is an empty slot in the vector. We can insert a leaf node into this slot and set the corresponding bit in the bitmap to <code>1</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a>insert_ hash key value (<span class="dt">Many</span> bitmap vector)</span>
<span id="cb31-2"><a href="#cb31-2"></a>    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb31-3"><a href="#cb31-3"></a>        leaf <span class="ot">=</span> <span class="dt">Leaf</span> (hash key) key value</span>
<span id="cb31-4"><a href="#cb31-4"></a>        vector&#39; <span class="ot">=</span> insertAt vector <span class="fu">index</span> leaf</span>
<span id="cb31-5"><a href="#cb31-5"></a>        bitmap&#39; <span class="ot">=</span> bitmap <span class="op">.|.</span> mask</span>
<span id="cb31-6"><a href="#cb31-6"></a>        <span class="kw">in</span> <span class="dt">Many</span> bitmap&#39; vector&#39;</span>
<span id="cb31-7"><a href="#cb31-7"></a>    <span class="kw">where</span></span>
<span id="cb31-8"><a href="#cb31-8"></a>        mask <span class="ot">=</span> bitMask_ hash</span>
<span id="cb31-9"><a href="#cb31-9"></a>        <span class="fu">index</span> <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<h4 id="mask-indexing">Mask Indexing</h4>
<p>What <code>index</code> do we use? This is where <code>popCount</code> makes an appearance. Let’s demonstrate by inserting <code>("10", 2)</code> into our example. First we get the mask corresponding to <code>hash "10"</code>:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a>mask <span class="ot">=</span> bitMask_ (hash <span class="st">&quot;10&quot;</span>)</span>
<span id="cb32-2"><a href="#cb32-2"></a></span>
<span id="cb32-3"><a href="#cb32-3"></a>mask</span></code></pre></div>
<pre><code>0000010000000000</code></pre>
<p>Next we want to find the number of lower bits that have been set. We use <code>mask - 1</code> as a mask:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a>mask <span class="op">-</span> <span class="dv">1</span></span></code></pre></div>
<pre><code>0000001111111111</code></pre>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a><span class="co">--     0100000000000000</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="co">-- .&amp;. 0000001111111111</span></span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="co">-----------------------</span></span>
<span id="cb36-4"><a href="#cb36-4"></a><span class="co">--     0000000000000000</span></span>
<span id="cb36-5"><a href="#cb36-5"></a></span>
<span id="cb36-6"><a href="#cb36-6"></a>masked <span class="ot">=</span> someBitmap <span class="op">.&amp;.</span> (mask <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb36-7"><a href="#cb36-7"></a></span>
<span id="cb36-8"><a href="#cb36-8"></a>masked</span></code></pre></div>
<pre><code>0000000000000000</code></pre>
<p>Then we count the number of bits set with <code>popCount</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="fu">index</span> <span class="ot">=</span> popCount masked</span>
<span id="cb38-2"><a href="#cb38-2"></a></span>
<span id="cb38-3"><a href="#cb38-3"></a><span class="fu">index</span></span></code></pre></div>
<pre><code>0</code></pre>
<p>And this is the index we need to insert at! We’ll call this <code>maskIndex</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="ot">maskIndex ::</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>maskIndex bitmap mask <span class="ot">=</span> popCount (bitmap <span class="op">.&amp;.</span> (mask <span class="op">-</span> <span class="dv">1</span>))</span></code></pre></div>
<p>The final case is where the bit in the bitmap is already set. We need to recursively update the HAMT at the corresponding index:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a>insert_ hash key value (<span class="dt">Many</span> bitmap vector)</span>
<span id="cb41-2"><a href="#cb41-2"></a>    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb41-3"><a href="#cb41-3"></a>        subtree&#39; <span class="ot">=</span> insert_ hash key value (vector <span class="op">!</span> <span class="fu">index</span>) <span class="co">-- WRONG!</span></span>
<span id="cb41-4"><a href="#cb41-4"></a>        vector&#39; <span class="ot">=</span> updateAt vector <span class="fu">index</span> subtree&#39;</span>
<span id="cb41-5"><a href="#cb41-5"></a>        <span class="kw">in</span> <span class="dt">Many</span> bitmap vector&#39;</span>
<span id="cb41-6"><a href="#cb41-6"></a>    <span class="kw">where</span></span>
<span id="cb41-7"><a href="#cb41-7"></a>        mask <span class="ot">=</span> bitMask_ hash</span>
<span id="cb41-8"><a href="#cb41-8"></a>        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</span></code></pre></div>
<p>But this definition is wrong, because instead of carving off the last <span class="math inline"><em>n</em></span> bits of <code>hash</code>, we want to recursively carve off the next <span class="math inline"><em>n</em></span> bits!</p>
<h4 id="shifting">Shifting</h4>
<p>This is what’s missing from our definition, a <code>shift</code> parameter corresponding to how far up the <code>hash</code> we’re looking. This is why we defined <code>Shift</code> above. Taking this extra parameter into account, our bit manipulation functions now become:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a><span class="ot">subkeyMask ::</span> <span class="dt">Bitmap</span></span>
<span id="cb42-2"><a href="#cb42-2"></a>subkeyMask <span class="ot">=</span> (bit bitsPerSubkey) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb42-3"><a href="#cb42-3"></a></span>
<span id="cb42-4"><a href="#cb42-4"></a><span class="ot">maskIndex ::</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb42-5"><a href="#cb42-5"></a>maskIndex bitmap mask <span class="ot">=</span> popCount (bitmap <span class="op">.&amp;.</span> (mask <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb42-6"><a href="#cb42-6"></a></span>
<span id="cb42-7"><a href="#cb42-7"></a><span class="ot">subkey ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb42-8"><a href="#cb42-8"></a>subkey hash shift <span class="ot">=</span> <span class="fu">fromIntegral</span> <span class="op">$</span> (<span class="fu">fromIntegral</span> <span class="op">$</span> shiftR hash shift) <span class="op">.&amp;.</span> subkeyMask</span>
<span id="cb42-9"><a href="#cb42-9"></a></span>
<span id="cb42-10"><a href="#cb42-10"></a><span class="ot">bitMask ::</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Bitmap</span></span>
<span id="cb42-11"><a href="#cb42-11"></a>bitMask hash shift <span class="ot">=</span> bit (subkey hash shift)</span></code></pre></div>
<p>We plumb through this <code>shift</code> parameter, only modifying it in the final case, to give us the correct definitions of <code>insert'</code> and <code>insert</code>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1"></a><span class="ot">insert ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</span>
<span id="cb43-2"><a href="#cb43-2"></a>insert key value hamt <span class="ot">=</span> insert&#39; <span class="dv">0</span> (hash key) key value hamt</span>
<span id="cb43-3"><a href="#cb43-3"></a></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="ot">insert&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> key <span class="ot">-&gt;</span> value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</span>
<span id="cb43-5"><a href="#cb43-5"></a>insert&#39; shift hash key value <span class="dt">None</span> <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</span>
<span id="cb43-6"><a href="#cb43-6"></a></span>
<span id="cb43-7"><a href="#cb43-7"></a>insert&#39; shift hash key value leaf<span class="op">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</span>
<span id="cb43-8"><a href="#cb43-8"></a>    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</span>
<span id="cb43-9"><a href="#cb43-9"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> insert&#39; shift hash key value (<span class="dt">Many</span> (bitMask leafHash shift) (singleton leaf))</span>
<span id="cb43-10"><a href="#cb43-10"></a></span>
<span id="cb43-11"><a href="#cb43-11"></a>insert&#39; shift hash key value (<span class="dt">Many</span> bitmap vector)</span>
<span id="cb43-12"><a href="#cb43-12"></a>    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb43-13"><a href="#cb43-13"></a>        leaf <span class="ot">=</span> <span class="dt">Leaf</span> hash key value</span>
<span id="cb43-14"><a href="#cb43-14"></a>        vector&#39; <span class="ot">=</span> insertAt vector <span class="fu">index</span> leaf</span>
<span id="cb43-15"><a href="#cb43-15"></a>        bitmap&#39; <span class="ot">=</span> bitmap <span class="op">.|.</span> mask</span>
<span id="cb43-16"><a href="#cb43-16"></a>        <span class="kw">in</span> <span class="dt">Many</span> bitmap&#39; vector&#39;</span>
<span id="cb43-17"><a href="#cb43-17"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb43-18"><a href="#cb43-18"></a>        subtree <span class="ot">=</span> vector <span class="op">!</span> <span class="fu">index</span></span>
<span id="cb43-19"><a href="#cb43-19"></a>        subtree&#39; <span class="ot">=</span> insert&#39; (shift<span class="op">+</span>bitsPerSubkey) hash key value subtree</span>
<span id="cb43-20"><a href="#cb43-20"></a>        vector&#39; <span class="ot">=</span> updateAt vector <span class="fu">index</span> subtree&#39;</span>
<span id="cb43-21"><a href="#cb43-21"></a>        <span class="kw">in</span> <span class="dt">Many</span> bitmap vector&#39;</span>
<span id="cb43-22"><a href="#cb43-22"></a>    <span class="kw">where</span></span>
<span id="cb43-23"><a href="#cb43-23"></a>        mask <span class="ot">=</span> bitMask hash shift</span>
<span id="cb43-24"><a href="#cb43-24"></a>        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</span></code></pre></div>
<p>Now we can construct HAMTs and inspect them! I’ll define a <code>fromList</code> function and use <code>pPrint</code> from <code>pretty-show</code> to highlight the tree structure:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1"></a><span class="ot">fromList ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> [(key, value)] <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</span>
<span id="cb44-2"><a href="#cb44-2"></a>fromList <span class="ot">=</span> <span class="fu">foldr</span> (<span class="fu">uncurry</span> insert) empty</span>
<span id="cb44-3"><a href="#cb44-3"></a></span>
<span id="cb44-4"><a href="#cb44-4"></a>example <span class="ot">=</span> fromList [(<span class="st">&quot;1&quot;</span>, <span class="dv">1</span>), (<span class="st">&quot;10&quot;</span>, <span class="dv">2</span>), (<span class="st">&quot;100&quot;</span>, <span class="dv">3</span>), (<span class="st">&quot;1000&quot;</span>, <span class="dv">4</span>)]</span>
<span id="cb44-5"><a href="#cb44-5"></a></span>
<span id="cb44-6"><a href="#cb44-6"></a>pPrint example</span></code></pre></div>
<pre><code>Many
  0100010000000000
  [ Many
      0000000100100000
      [ Leaf 00100000011101101010111101011010 &quot;10&quot; 2
      , Leaf 10001010111100101011011010001010 &quot;1000&quot; 4
      ]
  , Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<h3 id="lookup">Lookup</h3>
<p>Compared to <code>insert</code>, <code>lookup</code> is a walk in the park. It’s implemented along the same lines as <code>insert</code>:</p>
<ul>
<li>on <code>None</code> nodes, it fails</li>
<li>on <code>Leaf</code> nodes, it succeeds if the hashes match</li>
<li>on <code>Many</code> nodes, it fails if the bit isn’t set, and recurses into the child node otherwise</li>
</ul>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">Maybe</span> value</span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="fu">lookup</span> key hamt <span class="ot">=</span> lookup&#39; <span class="dv">0</span> (hash key) hamt</span>
<span id="cb46-3"><a href="#cb46-3"></a></span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="ot">lookup&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">Maybe</span> value</span>
<span id="cb46-5"><a href="#cb46-5"></a>lookup&#39; shift hash <span class="dt">None</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb46-6"><a href="#cb46-6"></a></span>
<span id="cb46-7"><a href="#cb46-7"></a>lookup&#39; shift hash (<span class="dt">Leaf</span> leafHash leafKey leafValue)</span>
<span id="cb46-8"><a href="#cb46-8"></a>    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">Just</span> leafValue</span>
<span id="cb46-9"><a href="#cb46-9"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb46-10"><a href="#cb46-10"></a></span>
<span id="cb46-11"><a href="#cb46-11"></a>lookup&#39; shift hash (<span class="dt">Many</span> bitmap vector)</span>
<span id="cb46-12"><a href="#cb46-12"></a>    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb46-13"><a href="#cb46-13"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> lookup&#39; (shift<span class="op">+</span>bitsPerSubkey) hash (vector <span class="op">!</span> <span class="fu">index</span>)</span>
<span id="cb46-14"><a href="#cb46-14"></a>    <span class="kw">where</span></span>
<span id="cb46-15"><a href="#cb46-15"></a>        mask <span class="ot">=</span> bitMask hash shift</span>
<span id="cb46-16"><a href="#cb46-16"></a>        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</span></code></pre></div>
<p>Let’s quickly confirm that it works.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1"></a><span class="fu">lookup</span> <span class="st">&quot;100&quot;</span> example</span></code></pre></div>
<pre><code>Just 3</code></pre>
<h4 id="memoising-fibonacci">Memoising Fibonacci</h4>
<p>We now have enough of an API to use this as a hashtable! Let’s use it to memoise the calculation of the Fibonacci sequence. The naive implementation does a lot of unnecessary recomputation:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb49-2"><a href="#cb49-2"></a>fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb49-3"><a href="#cb49-3"></a>fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb49-4"><a href="#cb49-4"></a>fib n <span class="ot">=</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb49-5"><a href="#cb49-5"></a></span>
<span id="cb49-6"><a href="#cb49-6"></a>timeIt <span class="op">$</span> <span class="fu">print</span> <span class="op">$</span> fib <span class="dv">30</span></span></code></pre></div>
<pre><code>1346269
CPU time:   1.31s</code></pre>
<p>We can memoise it by storing previously calculated results and using them if they are available:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1"></a><span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb51-2"><a href="#cb51-2"></a>    hash int <span class="ot">=</span> <span class="dt">Binary</span> (<span class="fu">fromIntegral</span> int)</span>
<span id="cb51-3"><a href="#cb51-3"></a></span>
<span id="cb51-4"><a href="#cb51-4"></a><span class="ot">fib&#39; ::</span> <span class="dt">HAMT</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">HAMT</span> <span class="dt">Int</span> <span class="dt">Int</span>)</span>
<span id="cb51-5"><a href="#cb51-5"></a>fib&#39; table <span class="dv">0</span> <span class="ot">=</span> (<span class="dv">1</span>, insert <span class="dv">0</span> <span class="dv">1</span> table)</span>
<span id="cb51-6"><a href="#cb51-6"></a>fib&#39; table <span class="dv">1</span> <span class="ot">=</span> (<span class="dv">1</span>, insert <span class="dv">1</span> <span class="dv">1</span> table)</span>
<span id="cb51-7"><a href="#cb51-7"></a>fib&#39; table n <span class="ot">=</span> <span class="kw">case</span> <span class="fu">lookup</span> n table <span class="kw">of</span></span>
<span id="cb51-8"><a href="#cb51-8"></a>    <span class="dt">Just</span> i <span class="ot">-&gt;</span> (i, table)</span>
<span id="cb51-9"><a href="#cb51-9"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">let</span></span>
<span id="cb51-10"><a href="#cb51-10"></a>        (i1, table&#39;)  <span class="ot">=</span> fib&#39; table  (n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb51-11"><a href="#cb51-11"></a>        (i2, table&#39;&#39;) <span class="ot">=</span> fib&#39; table&#39; (n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb51-12"><a href="#cb51-12"></a>        <span class="kw">in</span> (i1 <span class="op">+</span> i2, insert n (i1 <span class="op">+</span> i2) table&#39;&#39;)</span>
<span id="cb51-13"><a href="#cb51-13"></a></span>
<span id="cb51-14"><a href="#cb51-14"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb51-15"><a href="#cb51-15"></a>fib n <span class="ot">=</span> <span class="fu">fst</span> <span class="op">$</span> fib&#39; empty n</span>
<span id="cb51-16"><a href="#cb51-16"></a></span>
<span id="cb51-17"><a href="#cb51-17"></a>timeIt <span class="op">$</span> <span class="fu">print</span> <span class="op">$</span> fib <span class="dv">30</span></span></code></pre></div>
<pre><code>1346269
CPU time:   0.00s</code></pre>
<h3 id="delete">Delete</h3>
<p>Finally we come to <code>delete</code>, which is only a little more complex than <code>lookup</code>. It needs to make sure that no <code>Many</code> node has a child <code>None</code> node, so if a <code>None</code> node:</p>
<ul>
<li>is an only child, it will replace the parent node</li>
<li>has any sibling nodes, it will be removed from the parent node’s bitmap and vector</li>
</ul>
<p><code>Leaf</code> nodes similarly replace their parents if they are the only child.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1"></a><span class="ot">delete ::</span> <span class="dt">Hashable</span> key <span class="ot">=&gt;</span> key <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</span>
<span id="cb53-2"><a href="#cb53-2"></a>delete key hamt <span class="ot">=</span> delete&#39; <span class="dv">0</span> (hash key) hamt</span>
<span id="cb53-3"><a href="#cb53-3"></a></span>
<span id="cb53-4"><a href="#cb53-4"></a><span class="ot">delete&#39; ::</span> <span class="dt">Shift</span> <span class="ot">-&gt;</span> <span class="dt">Hash</span> <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value <span class="ot">-&gt;</span> <span class="dt">HAMT</span> key value</span>
<span id="cb53-5"><a href="#cb53-5"></a>delete&#39; shift hash <span class="dt">None</span> <span class="ot">=</span> <span class="dt">None</span></span>
<span id="cb53-6"><a href="#cb53-6"></a></span>
<span id="cb53-7"><a href="#cb53-7"></a>delete&#39; shift hash leaf<span class="op">@</span>(<span class="dt">Leaf</span> leafHash leafKey leafValue)</span>
<span id="cb53-8"><a href="#cb53-8"></a>    <span class="op">|</span> hash <span class="op">==</span> leafHash <span class="ot">=</span> <span class="dt">None</span></span>
<span id="cb53-9"><a href="#cb53-9"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> leaf</span>
<span id="cb53-10"><a href="#cb53-10"></a></span>
<span id="cb53-11"><a href="#cb53-11"></a>delete&#39; shift hash many<span class="op">@</span>(<span class="dt">Many</span> bitmap vector)</span>
<span id="cb53-12"><a href="#cb53-12"></a>    <span class="op">|</span> bitmap <span class="op">.&amp;.</span> mask <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> many</span>
<span id="cb53-13"><a href="#cb53-13"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb53-14"><a href="#cb53-14"></a>        subtree <span class="ot">=</span> vector <span class="op">!</span> <span class="fu">index</span></span>
<span id="cb53-15"><a href="#cb53-15"></a>        subtree&#39; <span class="ot">=</span> delete&#39; (shift<span class="op">+</span>bitsPerSubkey) hash subtree</span>
<span id="cb53-16"><a href="#cb53-16"></a>        <span class="kw">in</span> <span class="kw">case</span> subtree&#39; <span class="kw">of</span></span>
<span id="cb53-17"><a href="#cb53-17"></a>            <span class="dt">None</span> <span class="ot">-&gt;</span> <span class="kw">if</span> <span class="fu">length</span> vector <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb53-18"><a href="#cb53-18"></a>                <span class="kw">then</span> <span class="dt">None</span></span>
<span id="cb53-19"><a href="#cb53-19"></a>                <span class="kw">else</span> <span class="dt">Many</span> (bitmap <span class="op">.&amp;.</span> complement mask) (deleteAt vector <span class="fu">index</span>)</span>
<span id="cb53-20"><a href="#cb53-20"></a>            <span class="dt">Leaf</span>{} <span class="ot">-&gt;</span> <span class="kw">if</span> <span class="fu">length</span> vector <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb53-21"><a href="#cb53-21"></a>                <span class="kw">then</span> subtree&#39;</span>
<span id="cb53-22"><a href="#cb53-22"></a>                <span class="kw">else</span>  <span class="dt">Many</span> bitmap (updateAt vector <span class="fu">index</span> subtree&#39;)</span>
<span id="cb53-23"><a href="#cb53-23"></a>            <span class="dt">Many</span>{} <span class="ot">-&gt;</span> <span class="dt">Many</span> bitmap (updateAt vector <span class="fu">index</span> subtree&#39;)</span>
<span id="cb53-24"><a href="#cb53-24"></a>    <span class="kw">where</span></span>
<span id="cb53-25"><a href="#cb53-25"></a>        mask <span class="ot">=</span> bitMask hash shift</span>
<span id="cb53-26"><a href="#cb53-26"></a>        <span class="fu">index</span> <span class="ot">=</span> maskIndex bitmap mask</span></code></pre></div>
<p>Let’s see this in action.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1"></a>pPrint <span class="op">$</span> delete <span class="st">&quot;1000&quot;</span> example</span></code></pre></div>
<pre><code>Many
  0100010000000000
  [ Many
      0000000000100000 [ Leaf 00100000011101101010111101011010 &quot;10&quot; 2 ]
  , Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<p>It’s possible to have a situation where we have a <code>Many</code> node with only one child, because our replacement behaviour checks the length of the vector before any elements are removed from it. However, removing the last leaf will correctly delete the parent node.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1"></a>pPrint <span class="op">$</span> delete <span class="st">&quot;10&quot;</span> <span class="op">$</span> delete <span class="st">&quot;1000&quot;</span> example</span></code></pre></div>
<pre><code>Many
  0100000000000000
  [ Many
      0000001000000100
      [ Leaf 00000101000011000101110100101110 &quot;1&quot; 1
      , Leaf 01110100110101100000101010011110 &quot;100&quot; 3
      ]
  ]</code></pre>
<p>And we’re done! I hope you understand HAMTs better than when you started reading this.</p>
<p>If you want to use this for something other than educational purposes, I would recommend adding logic to deal with hash collisions, which I intentionally omitted. There’s also some low-hanging fruit in terms of performance optimisations. The first thing that comes to mind is an additional <code>Full</code> constructor for the case where all bits in the bitmap are set, and the next thing is the use of unsafe vector functions that omit bounds checking.</p>
<p>Thanks to <a href="https://twitter.com/evanborden">Evan Borden</a>, <a href="https://twitter.com/candeira">Javier Candeira</a>, <a href="https://hypirion.com/">Jean Niklas L’orange</a>, <a href="http://mjhopkins.github.io/">Mark Hopkins</a>, and <a href="https://teh.id.au/">Tim Humphries</a> for comments and feedback.</p>
</summary>
</entry>
<entry>
    <title>Trees That Shrink</title>
    <link href="https://vaibhavsagar.com/blog/2018/06/19/trees-that-shrink/" />
    <id>https://vaibhavsagar.com/blog/2018/06/19/trees-that-shrink/index.html</id>
    <published>2018-06-19</published>
    <updated>2018-06-19T00:00:00Z</updated>
    <summary type="html"><div class="info">
    Posted on 19 June 2018
    
</div>
<div class="info">
    
        Tags: <a href="/blog/tags/haskell/index.html">haskell</a>, <a href="/blog/tags/programming/index.html">programming</a>
    
</div>

<p><em>This blog post is also available as an <a href="https://github.com/vaibhavsagar/notebooks/blob/master/trees-that-shrink/TreesThatShrink.ipynb">IHaskell notebook</a>.</em></p>
<p>I read <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf">this paper</a> a while ago and people seemed pretty excited about it, although I couldn’t see why. Fortunately, someone posed me an interesting problem recently and in the process of tackling it I think I understand now.</p>
<p>Suppose we have a simple algebraic data type representing the lambda calculus with <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">de Bruijn indices</a>, which are a way of avoiding the messy problem of variable names:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a</span>
<span id="cb1-2"><a href="#cb1-2"></a>    <span class="ot">=</span> <span class="dt">Lit</span> a</span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="op">|</span> <span class="dt">Var</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>    <span class="op">|</span> <span class="dt">Abs</span> (<span class="dt">Expr</span> a)</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="op">|</span> <span class="dt">App</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)</span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>So far so good! Now we want to have let bindings in this language, and we’ve decided that we want named variables as well while we’re at it because de Bruijn indices are not so much fun to work with. We dutifully define another data type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">Expr&#39;</span> a</span>
<span id="cb2-2"><a href="#cb2-2"></a>    <span class="ot">=</span> <span class="dt">Lit&#39;</span> a</span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="op">|</span> <span class="dt">Var&#39;</span> <span class="dt">String</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="op">|</span> <span class="dt">Abs&#39;</span> (<span class="dt">Expr&#39;</span> a)</span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="op">|</span> <span class="dt">App&#39;</span> (<span class="dt">Expr&#39;</span> a) (<span class="dt">Expr&#39;</span> a)</span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="op">|</span> <span class="dt">Let&#39;</span> <span class="dt">String</span> (<span class="dt">Expr&#39;</span> a) (<span class="dt">Expr&#39;</span> a)</span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>Let bindings can be easily desugared into lambda abstractions as follows:</p>
<pre><code>let &lt;n&gt; = &lt;x&gt; in &lt;y&gt; &lt;=&gt; (\n -&gt; y) x</code></pre>
<p>which will help us to write a simpler evaluator. However, we’d also like to make sure the desugaring has been implemented correctly, perhaps by converting to some intermediate state where both the name and the correct de Bruijn index coexist peacefully. We have a couple of options, none of which are great:</p>
<ol type="1">
<li>Define a third data type and then write an indexing pass that converts <code>Var String</code> to <code>Var (String, Int)</code> and then a desugaring pass that converts that to <code>Expr a</code>.</li>
<li>Work entirely within the bigger data type, forget about indexing, and throw errors whenever a <code>Let</code> is encountered after a desugaring pass.</li>
<li>Combine the desugaring and indexing passes into one, and forget about keeping track of the desugaring.</li>
</ol>
<p>Let’s implement the third:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Int</span></span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="ot">desugarAndAnonymise ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr&#39;</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span>
<span id="cb4-6"><a href="#cb4-6"></a>desugarAndAnonymise env expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="dt">Lit&#39;</span> a <span class="ot">-&gt;</span> <span class="dt">Lit</span> a</span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="dt">Var&#39;</span> name <span class="ot">-&gt;</span> <span class="dt">Var</span> (env <span class="op">Map.!</span> name)</span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="dt">Abs&#39;</span> expr&#39; <span class="ot">-&gt;</span> <span class="kw">let</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>        env&#39;  <span class="ot">=</span> Map.map <span class="fu">succ</span> env</span>
<span id="cb4-11"><a href="#cb4-11"></a>        <span class="kw">in</span> <span class="dt">Abs</span> (desugarAndAnonymise env&#39; expr&#39;)</span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="dt">App&#39;</span> f x <span class="ot">-&gt;</span> <span class="dt">App</span> (desugarAndAnonymise env f) (desugarAndAnonymise env x)</span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="dt">Let&#39;</span> n v expr&#39; <span class="ot">-&gt;</span> desugarAndAnonymise env (<span class="dt">App&#39;</span> (<span class="dt">Abs&#39;</span> expr&#39;) v)</span></code></pre></div>
<p>That wasn’t a lot of fun to write, I have no idea if I did the conversion from names to indices correctly, and there’s no easy way to check if I did.</p>
<p>These problems are (barely) manageable in this case, but what if we want to add more syntax sugar or share this data type with other libraries that have different use cases? We’d either have to write variations on a theme over and over again or say goodbye to type safety. It also becomes harder and harder to decompose our functions into smaller ones that only do one thing. There has to be a better way!</p>
<p>This is the subject of <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/trees-that-grow.pdf">Trees that Grow</a> by Shayan Najd and Simon Peyton Jones. They noticed the need for this approach when looking at GHC’s abstract syntax tree type but the idiom is generally applicable.</p>
<p>The first insight is that defining different data types for each use case is the wrong approach. Conceptually all these data types are the same type, just with different annotations or decoration, and we should be able to define the base data type with enough extensibility to accommodate all the other use cases.</p>
<p>The second insight is that we can use some of GHC’s fancier features to ease the pain of working with this ridiculously extensible data type, such as type families and pattern synonyms.</p>
<p>The third insight is that this can be made to work with other language features, such as generalised abstract data types and existentials! We won’t use this here, but it’s great to know that it’s possible.</p>
<p>Let’s see how we can use it to solve our problem. The first thing to do is turn on some language extensions, as with anything moderately fun in Haskell:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">{-# LANGUAGE PatternSynonyms   #-}</span></span></code></pre></div>
<p>The next steps are:</p>
<ol type="1">
<li>Add a type parameter to the data type declaration.</li>
<li>Add a field to each constructor with a new data type that uses this parameter (and any others).</li>
<li>Add an extra constructor to enable extending this data type, also with a new data type as in step 2.</li>
<li>Define type families for each of the new data types you declared in steps 2 and 3.</li>
</ol>
<p>And we’re done! This is what that looks like for our example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">data</span> <span class="dt">ExpX</span> i a</span>
<span id="cb6-2"><a href="#cb6-2"></a>    <span class="ot">=</span> <span class="dt">LitX</span> (<span class="dt">XLit</span> i a) a</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="op">|</span> <span class="dt">VarX</span> (<span class="dt">XVar</span> i a)</span>
<span id="cb6-4"><a href="#cb6-4"></a>    <span class="op">|</span> <span class="dt">AbsX</span> (<span class="dt">XAbs</span> i a) (<span class="dt">ExpX</span> i a)</span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="op">|</span> <span class="dt">AppX</span> (<span class="dt">XApp</span> i a) (<span class="dt">ExpX</span> i a) (<span class="dt">ExpX</span> i a)</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="op">|</span> <span class="dt">ExpX</span> (<span class="dt">XExp</span> i a)</span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XLit</span> i a</span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XVar</span> i a</span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XAbs</span> i a</span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XApp</span> i a</span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XExp</span> i a</span></code></pre></div>
<p>The next thing to do is to reconstruct our original data type with no extensions. To do this we’ll need to use the <a href="http://hackage.haskell.org/package/base/docs/Data-Void.html"><code>Data.Void</code></a> package:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ot">void ::</span> <span class="dt">Void</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>void <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Attempt to evaluate void&quot;</span></span></code></pre></div>
<p>Now we can define <code>ExpUD</code> (UD for “undecorated”) using <code>Int</code> for our <code>Var</code> like we originally wanted and <code>Void</code> for all other extension points. It might get frustrating to construct and work with these values by hand, so we can use pattern synonyms to ease this pain.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">type</span> <span class="dt">ExpUD</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">UD</span> a</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">data</span> <span class="dt">UD</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="kw">pattern</span> <span class="dt">LitUD</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="kw">pattern</span> <span class="dt">LitUD</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="kw">where</span> <span class="dt">LitUD</span> a <span class="ot">=</span> <span class="dt">LitX</span> void a</span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="kw">pattern</span> <span class="dt">VarUD</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="kw">pattern</span> <span class="dt">VarUD</span> i <span class="ot">&lt;-</span> <span class="dt">VarX</span> i</span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="kw">where</span> <span class="dt">VarUD</span> i <span class="ot">=</span> <span class="dt">VarX</span> i</span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="kw">pattern</span> <span class="dt">AbsUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="kw">pattern</span> <span class="dt">AbsUD</span> a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> _ a</span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span class="kw">where</span> <span class="dt">AbsUD</span> a <span class="ot">=</span> <span class="dt">AbsX</span> void a</span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="kw">pattern</span> <span class="dt">AppUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="kw">pattern</span> <span class="dt">AppUD</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</span>
<span id="cb8-20"><a href="#cb8-20"></a>    <span class="kw">where</span> <span class="dt">AppUD</span> f a <span class="ot">=</span> <span class="dt">AppX</span> void f a</span></code></pre></div>
<p>This is unfortunately a bit boilerplate-y, but now we can define that intermediate data type that uses named variables as well as de Bruijn indices! As a bonus, we can now have named parameters to lambdas, which would not have been possible with the approach we tried to use above.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">type</span> <span class="dt">ExpAnn</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Ann</span> a</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">data</span> <span class="dt">Ann</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Ann</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">Int</span>)</span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="kw">pattern</span> <span class="dt">LitAnn</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw">pattern</span> <span class="dt">LitAnn</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</span>
<span id="cb9-11"><a href="#cb9-11"></a>    <span class="kw">where</span> <span class="dt">LitAnn</span> a <span class="ot">=</span> <span class="dt">LitX</span> void a</span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="kw">pattern</span> <span class="dt">VarAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="kw">pattern</span> <span class="dt">VarAnn</span> s i <span class="ot">&lt;-</span> <span class="dt">VarX</span> (s,i)</span>
<span id="cb9-14"><a href="#cb9-14"></a>    <span class="kw">where</span> <span class="dt">VarAnn</span> s i <span class="ot">=</span> <span class="dt">VarX</span> (s, i)</span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="kw">pattern</span> <span class="dt">AbsAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="kw">pattern</span> <span class="dt">AbsAnn</span> s a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> s a</span>
<span id="cb9-17"><a href="#cb9-17"></a>    <span class="kw">where</span> <span class="dt">AbsAnn</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</span>
<span id="cb9-18"><a href="#cb9-18"></a><span class="kw">pattern</span> <span class="dt">AppAnn</span><span class="ot"> ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</span>
<span id="cb9-19"><a href="#cb9-19"></a><span class="kw">pattern</span> <span class="dt">AppAnn</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</span>
<span id="cb9-20"><a href="#cb9-20"></a>    <span class="kw">where</span> <span class="dt">AppAnn</span> f a <span class="ot">=</span> <span class="dt">AppX</span> void f a</span></code></pre></div>
<p>Now for my favourite part, where we add let bindings! We achieve this by using a tuple to represent <code>let &lt;name&gt; = &lt;expr&gt; in &lt;expr&gt;</code> as <code>(&lt;name&gt;, &lt;expr&gt;, &lt;expr&gt;)</code>, and we use named variables and parameters in this representation.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">type</span> <span class="dt">ExpLet</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Let</span> a</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw">data</span> <span class="dt">Let</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Let</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">ExpLet</span> a, <span class="dt">ExpLet</span> a)</span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="kw">pattern</span> <span class="dt">LitLet</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="kw">pattern</span> <span class="dt">LitLet</span> a <span class="ot">&lt;-</span> <span class="dt">LitX</span> _ a</span>
<span id="cb10-11"><a href="#cb10-11"></a>    <span class="kw">where</span> <span class="dt">LitLet</span> a <span class="ot">=</span> <span class="dt">LitX</span> void a</span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="kw">pattern</span> <span class="dt">VarLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="kw">pattern</span> <span class="dt">VarLet</span> s <span class="ot">&lt;-</span> <span class="dt">VarX</span> s</span>
<span id="cb10-14"><a href="#cb10-14"></a>    <span class="kw">where</span> <span class="dt">VarLet</span> s <span class="ot">=</span> <span class="dt">VarX</span> s</span>
<span id="cb10-15"><a href="#cb10-15"></a><span class="kw">pattern</span> <span class="dt">AbsLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="kw">pattern</span> <span class="dt">AbsLet</span> s a <span class="ot">&lt;-</span> <span class="dt">AbsX</span> s a</span>
<span id="cb10-17"><a href="#cb10-17"></a>    <span class="kw">where</span> <span class="dt">AbsLet</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</span>
<span id="cb10-18"><a href="#cb10-18"></a><span class="kw">pattern</span> <span class="dt">AppLet</span><span class="ot"> ::</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</span>
<span id="cb10-19"><a href="#cb10-19"></a><span class="kw">pattern</span> <span class="dt">AppLet</span> f a <span class="ot">&lt;-</span> <span class="dt">AppX</span> _ f a</span>
<span id="cb10-20"><a href="#cb10-20"></a>    <span class="kw">where</span> <span class="dt">AppLet</span> f a <span class="ot">=</span> <span class="dt">AppX</span> void f a</span>
<span id="cb10-21"><a href="#cb10-21"></a><span class="kw">pattern</span> <span class="dt">LetLet</span> n v e <span class="ot">&lt;-</span> <span class="dt">ExpX</span> (n,v,e)</span></code></pre></div>
<p>Now instead of writing a single giant pass, we can write smaller ones!</p>
<p>We can write a desugarer that preserves names and rewrites our let bindings as follows:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">desugar ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</span>
<span id="cb11-2"><a href="#cb11-2"></a>desugar env expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="dt">LitLet</span> a <span class="ot">-&gt;</span> <span class="dt">LitAnn</span> a</span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="dt">VarLet</span> name <span class="ot">-&gt;</span> <span class="dt">VarAnn</span> name (env <span class="op">Map.!</span> name)</span>
<span id="cb11-5"><a href="#cb11-5"></a>    <span class="dt">AbsLet</span> name expr&#39; <span class="ot">-&gt;</span> <span class="kw">let</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>        env&#39;  <span class="ot">=</span> Map.map <span class="fu">succ</span> env</span>
<span id="cb11-7"><a href="#cb11-7"></a>        env&#39;&#39; <span class="ot">=</span> Map.insert name <span class="dv">0</span> env&#39;</span>
<span id="cb11-8"><a href="#cb11-8"></a>        <span class="kw">in</span> <span class="dt">AbsAnn</span> name (desugar env&#39;&#39; expr&#39;)</span>
<span id="cb11-9"><a href="#cb11-9"></a>    <span class="dt">AppLet</span> f x <span class="ot">-&gt;</span> <span class="dt">AppAnn</span> (desugar env f) (desugar env x)</span>
<span id="cb11-10"><a href="#cb11-10"></a>    <span class="dt">LetLet</span> n v expr&#39; <span class="ot">-&gt;</span> desugar env (<span class="dt">AppLet</span> (<span class="dt">AbsLet</span> n expr&#39;) v)</span></code></pre></div>
<p>We can also write an anonymiser that throws the names away:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="ot">anonymise ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</span>
<span id="cb12-2"><a href="#cb12-2"></a>anonymise expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="dt">LitAnn</span> a <span class="ot">-&gt;</span> <span class="dt">LitUD</span> a</span>
<span id="cb12-4"><a href="#cb12-4"></a>    <span class="dt">VarAnn</span> _ i <span class="ot">-&gt;</span> <span class="dt">VarUD</span> i</span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="dt">AbsAnn</span> _ e <span class="ot">-&gt;</span> <span class="dt">AbsUD</span> (anonymise e)</span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="dt">AppAnn</span> f x <span class="ot">-&gt;</span> <span class="dt">AppUD</span> (anonymise f) (anonymise x)</span></code></pre></div>
<p>And finally an evaluator that operates on undecorated expressions:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">eval ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb13-2"><a href="#cb13-2"></a>eval env expr <span class="ot">=</span> <span class="kw">case</span> expr <span class="kw">of</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="dt">LitUD</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="dt">VarUD</span> i <span class="ot">-&gt;</span> env <span class="op">!!</span> i</span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="dt">AbsUD</span> f <span class="ot">-&gt;</span> eval env f</span>
<span id="cb13-6"><a href="#cb13-6"></a>    <span class="dt">AppUD</span> f x <span class="ot">-&gt;</span> <span class="kw">let</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>        x&#39; <span class="ot">=</span> eval env x</span>
<span id="cb13-8"><a href="#cb13-8"></a>        <span class="kw">in</span> eval (x&#39;<span class="op">:</span>env) f</span></code></pre></div>
<p>Let’s see it in action!</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a>identity <span class="ot">=</span> <span class="dt">AbsLet</span> <span class="st">&quot;i&quot;</span> (<span class="dt">VarLet</span> <span class="st">&quot;i&quot;</span>)</span>
<span id="cb14-2"><a href="#cb14-2"></a>konst <span class="ot">=</span> (<span class="dt">AbsLet</span> <span class="st">&quot;x&quot;</span> (<span class="dt">AbsLet</span> <span class="st">&quot;y&quot;</span> (<span class="dt">VarLet</span> <span class="st">&quot;x&quot;</span>)))</span>
<span id="cb14-3"><a href="#cb14-3"></a></span>
<span id="cb14-4"><a href="#cb14-4"></a>eval [] <span class="op">.</span> anonymise <span class="op">.</span> desugar Map.empty <span class="op">$</span> <span class="dt">AppLet</span> (<span class="dt">AppLet</span> konst (<span class="dt">LitLet</span> <span class="dv">1</span>)) (<span class="dt">LitLet</span> <span class="dv">2</span>)</span></code></pre></div>
<pre><code>2</code></pre>
<p>Awesome! We have composable compiler passes that are easier to write and to think about. Even with this small example, I hope the benefits are clear.</p>
<p>Edit: <a href="https://www.reddit.com/r/haskell/comments/8s75n3/trees_that_shrink/e0x8se2">Edward Kmett points out</a> that using <code>Void</code> makes this approach unnecessarily footgun-prone and suggests using strict fields and <code>()</code> instead. This allows for simpler pattern synonyms and comes with the additional benefit that we can disable constructors with <code>Void</code> so we can actually have trees that shrink:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">data</span> <span class="dt">ExpX</span> i a</span>
<span id="cb16-2"><a href="#cb16-2"></a>    <span class="ot">=</span> <span class="dt">LitX</span> <span class="op">!</span>(<span class="dt">XLit</span> i a) a</span>
<span id="cb16-3"><a href="#cb16-3"></a>    <span class="op">|</span> <span class="dt">VarX</span> <span class="op">!</span>(<span class="dt">XVar</span> i a)</span>
<span id="cb16-4"><a href="#cb16-4"></a>    <span class="op">|</span> <span class="dt">AbsX</span> <span class="op">!</span>(<span class="dt">XAbs</span> i a) (<span class="dt">ExpX</span> i a)</span>
<span id="cb16-5"><a href="#cb16-5"></a>    <span class="op">|</span> <span class="dt">AppX</span> <span class="op">!</span>(<span class="dt">XApp</span> i a) (<span class="dt">ExpX</span> i a) (<span class="dt">ExpX</span> i a)</span>
<span id="cb16-6"><a href="#cb16-6"></a>    <span class="op">|</span> <span class="dt">ExpX</span> <span class="op">!</span>(<span class="dt">XExp</span> i a)</span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XLit</span> i a</span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XVar</span> i a</span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XAbs</span> i a</span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XApp</span> i a</span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XExp</span> i a</span>
<span id="cb16-13"><a href="#cb16-13"></a></span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="kw">type</span> <span class="dt">ExpUD</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">UD</span> a</span>
<span id="cb16-15"><a href="#cb16-15"></a><span class="kw">data</span> <span class="dt">UD</span></span>
<span id="cb16-16"><a href="#cb16-16"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">UD</span> a <span class="ot">=</span> ()</span>
<span id="cb16-17"><a href="#cb16-17"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb16-18"><a href="#cb16-18"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">UD</span> a <span class="ot">=</span> ()</span>
<span id="cb16-19"><a href="#cb16-19"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">UD</span> a <span class="ot">=</span> ()</span>
<span id="cb16-20"><a href="#cb16-20"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">UD</span> a <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb16-21"><a href="#cb16-21"></a></span>
<span id="cb16-22"><a href="#cb16-22"></a><span class="kw">pattern</span> <span class="dt">LitUD</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</span>
<span id="cb16-23"><a href="#cb16-23"></a><span class="kw">pattern</span> <span class="dt">LitUD</span> a <span class="ot">=</span> <span class="dt">LitX</span> () a</span>
<span id="cb16-24"><a href="#cb16-24"></a><span class="kw">pattern</span> <span class="dt">VarUD</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</span>
<span id="cb16-25"><a href="#cb16-25"></a><span class="kw">pattern</span> <span class="dt">VarUD</span> i <span class="ot">=</span> <span class="dt">VarX</span> i</span>
<span id="cb16-26"><a href="#cb16-26"></a><span class="kw">pattern</span> <span class="dt">AbsUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</span>
<span id="cb16-27"><a href="#cb16-27"></a><span class="kw">pattern</span> <span class="dt">AbsUD</span> a <span class="ot">=</span> <span class="dt">AbsX</span> () a</span>
<span id="cb16-28"><a href="#cb16-28"></a><span class="kw">pattern</span> <span class="dt">AppUD</span><span class="ot"> ::</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a <span class="ot">-&gt;</span> <span class="dt">ExpUD</span> a</span>
<span id="cb16-29"><a href="#cb16-29"></a><span class="kw">pattern</span> <span class="dt">AppUD</span> f a <span class="ot">=</span> <span class="dt">AppX</span> () f a</span>
<span id="cb16-30"><a href="#cb16-30"></a></span>
<span id="cb16-31"><a href="#cb16-31"></a><span class="kw">type</span> <span class="dt">ExpAnn</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Ann</span> a</span>
<span id="cb16-32"><a href="#cb16-32"></a><span class="kw">data</span> <span class="dt">Ann</span></span>
<span id="cb16-33"><a href="#cb16-33"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Ann</span> a <span class="ot">=</span> ()</span>
<span id="cb16-34"><a href="#cb16-34"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Ann</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">Int</span>)</span>
<span id="cb16-35"><a href="#cb16-35"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb16-36"><a href="#cb16-36"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Ann</span> a <span class="ot">=</span> ()</span>
<span id="cb16-37"><a href="#cb16-37"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Ann</span> a <span class="ot">=</span> <span class="dt">Void</span></span>
<span id="cb16-38"><a href="#cb16-38"></a></span>
<span id="cb16-39"><a href="#cb16-39"></a><span class="kw">pattern</span> <span class="dt">LitAnn</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</span>
<span id="cb16-40"><a href="#cb16-40"></a><span class="kw">pattern</span> <span class="dt">LitAnn</span> a <span class="ot">=</span> <span class="dt">LitX</span> () a</span>
<span id="cb16-41"><a href="#cb16-41"></a><span class="kw">pattern</span> <span class="dt">VarAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</span>
<span id="cb16-42"><a href="#cb16-42"></a><span class="kw">pattern</span> <span class="dt">VarAnn</span> s i <span class="ot">=</span> <span class="dt">VarX</span> (s, i)</span>
<span id="cb16-43"><a href="#cb16-43"></a><span class="kw">pattern</span> <span class="dt">AbsAnn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</span>
<span id="cb16-44"><a href="#cb16-44"></a><span class="kw">pattern</span> <span class="dt">AbsAnn</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</span>
<span id="cb16-45"><a href="#cb16-45"></a><span class="kw">pattern</span> <span class="dt">AppAnn</span><span class="ot"> ::</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a <span class="ot">-&gt;</span> <span class="dt">ExpAnn</span> a</span>
<span id="cb16-46"><a href="#cb16-46"></a><span class="kw">pattern</span> <span class="dt">AppAnn</span> f a <span class="ot">=</span> <span class="dt">AppX</span> () f a</span>
<span id="cb16-47"><a href="#cb16-47"></a></span>
<span id="cb16-48"><a href="#cb16-48"></a><span class="kw">type</span> <span class="dt">ExpLet</span> a <span class="ot">=</span> <span class="dt">ExpX</span> <span class="dt">Let</span> a</span>
<span id="cb16-49"><a href="#cb16-49"></a><span class="kw">data</span> <span class="dt">Let</span></span>
<span id="cb16-50"><a href="#cb16-50"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XLit</span> <span class="dt">Let</span> a <span class="ot">=</span> ()</span>
<span id="cb16-51"><a href="#cb16-51"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XVar</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb16-52"><a href="#cb16-52"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XAbs</span> <span class="dt">Let</span> a <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb16-53"><a href="#cb16-53"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XApp</span> <span class="dt">Let</span> a <span class="ot">=</span> ()</span>
<span id="cb16-54"><a href="#cb16-54"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">XExp</span> <span class="dt">Let</span> a <span class="ot">=</span> (<span class="dt">String</span>, <span class="dt">ExpLet</span> a, <span class="dt">ExpLet</span> a)</span>
<span id="cb16-55"><a href="#cb16-55"></a></span>
<span id="cb16-56"><a href="#cb16-56"></a><span class="kw">pattern</span> <span class="dt">LitLet</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</span>
<span id="cb16-57"><a href="#cb16-57"></a><span class="kw">pattern</span> <span class="dt">LitLet</span> a <span class="ot">=</span> <span class="dt">LitX</span> () a</span>
<span id="cb16-58"><a href="#cb16-58"></a><span class="kw">pattern</span> <span class="dt">VarLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</span>
<span id="cb16-59"><a href="#cb16-59"></a><span class="kw">pattern</span> <span class="dt">VarLet</span> s <span class="ot">=</span> <span class="dt">VarX</span> s</span>
<span id="cb16-60"><a href="#cb16-60"></a><span class="kw">pattern</span> <span class="dt">AbsLet</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</span>
<span id="cb16-61"><a href="#cb16-61"></a><span class="kw">pattern</span> <span class="dt">AbsLet</span> s a <span class="ot">=</span> <span class="dt">AbsX</span> s a</span>
<span id="cb16-62"><a href="#cb16-62"></a><span class="kw">pattern</span> <span class="dt">AppLet</span><span class="ot"> ::</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a <span class="ot">-&gt;</span> <span class="dt">ExpLet</span> a</span>
<span id="cb16-63"><a href="#cb16-63"></a><span class="kw">pattern</span> <span class="dt">AppLet</span> f a <span class="ot">=</span> <span class="dt">AppX</span> () f a</span>
<span id="cb16-64"><a href="#cb16-64"></a><span class="kw">pattern</span> <span class="dt">LetLet</span> n v e <span class="ot">&lt;-</span> <span class="dt">ExpX</span> (n,v,e)</span></code></pre></div>
<p>The definitions of <code>desugar</code>, <code>anonymise</code>, and <code>eval</code> are unchanged.</p>
<p>Thanks to <a href="http://andychu.net/">Andy Chu</a> and <a href="https://push.cx/">Peter Bhat Harkins</a> for comments and feedback.</p>
</summary>
</entry>

</feed>
