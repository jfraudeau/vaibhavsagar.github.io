<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Quick and Easy Nixpkgs Pinning - Vaibhav Sagar</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-79891461-1', 'auto');
          ga('send', 'pageview');

        </script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">Vaibhav Sagar</a>
            </div>
            <div id="navigation">
                <a href="../../about/">About</a>
                <a href="../../archive/">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Quick and Easy Nixpkgs Pinning</h1>

            <div class="info">
    Posted on 19 January 2018
    
</div>
<div class="info">
    
        Tags: <a href="../../blog/tags/programming/">programming</a>, <a href="../../blog/tags/nix/">nix</a>
    
</div>

<p>I love Nix because it makes packaging and using software so easy. For example, here’s an expression that makes a recent version of Pandoc available in a <code>nix-shell</code> at the time of writing:</p>
<div class="sourceCode"><pre class="sourceCode nix"><code class="sourceCode bash"><span class="bu">let</span>
  <span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span><span class="kw">;</span>
  <span class="ex">haskellPkgs</span> = pkgs.haskell.packages.ghc802.override {
    <span class="ex">overrides</span> = self: super: {
      <span class="ex">doctemplates</span> = self.callHackage <span class="st">&quot;doctemplates&quot;</span> <span class="st">&quot;0.2.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">hslua</span> = self.callHackage <span class="st">&quot;hslua&quot;</span> <span class="st">&quot;0.9.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.0.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">skylighting</span> = self.callHackage <span class="st">&quot;skylighting&quot;</span> <span class="st">&quot;0.4.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
    };
  };
<span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {
  <span class="ex">buildInputs</span> = [ haskellPkgs.pandoc ]<span class="kw">;</span>
} <span class="st">&quot;&quot;</span></code></pre></div>
<p>If we save this to <code>default.nix</code> we can use it as follows:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">nix-shell</span> default.nix
<span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span>
[<span class="ex">nix-shell</span>]$ pandoc --version
<span class="ex">pandoc</span> 2.0.1
<span class="op">&lt;</span><span class="ex">...</span><span class="op">&gt;</span></code></pre></div>
<p>Pandoc is infamously large, so this will probably take a while the first time. Fortunately, Nix caches build artifacts and knows to provide the same output if the inputs are unchanged, so if we immediately try this again a second time it should be nearly instantaneous.</p>
<p>Barring an event like the garbage collection of the Nix store or a change in the expression above, we would like to never rebuild this package again. Unfortunately, there is a serious flaw with this expression that prevents us from guaranteeing this.</p>
<p>The problem is not immediately obvious, and might only manifest days or weeks later. The issue is with the second line,</p>
<div class="sourceCode"><pre class="sourceCode nix"><code class="sourceCode bash"><span class="ex">pkgs</span> = import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span><span class="kw">;</span></code></pre></div>
<p>where we import the system-wide <code>nixpkgs</code>. If we later update this by running</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">nix-channel</span> --update</code></pre></div>
<p>and any of the transitive dependencies of our expression are updated, this will cause a rebuild because Nix will rightly detect that the inputs have changed.</p>
<p>This might be desirable in many cases, but for us it means a lot of waiting. We can avoid this by pinning <code>nixpkgs</code> to a known-good commit. One way to do this is by setting the <code>NIX_PATH</code> environment variable, which is where Nix looks for the location of <code>nixpkgs</code>. We could do this as follows:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="va">NIX_PATH=</span>nixpkgs=<span class="ex">https</span>://github.com/NixOS/nixpkgs-channels/archive/d9a2891c32ee452a2cd701310040b660da0cc853.tar.gz nix-shell default.nix</code></pre></div>
<p>which takes advantage of the fact that Nix will transparently download a URL for <code>nixpkgs</code> instead of a filepath. This can quickly get tedious and is easy to forget though. Let’s pin <code>nixpkgs</code> directly in the expression:</p>
<div class="sourceCode"><pre class="sourceCode nix"><code class="sourceCode bash"><span class="bu">let</span>
  <span class="ex">inherit</span> (import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span>) <span class="ex">fetchFromGitHub</span><span class="kw">;</span>
  <span class="ex">nixpkgs</span> = fetchFromGitHub {
    <span class="ex">owner</span> = <span class="st">&quot;NixOS&quot;</span><span class="kw">;</span>
    <span class="ex">repo</span>  = <span class="st">&quot;nixpkgs-channels&quot;</span><span class="kw">;</span>
    <span class="fu">rev</span> = <span class="st">&quot;d9a2891c32ee452a2cd701310040b660da0cc853&quot;</span><span class="kw">;</span>
    <span class="ex">sha256</span> = <span class="st">&quot;14m6krpv7iga96bjpb4xmdq1fpysryyfvkghn68k6g8gr9y61fqs&quot;</span><span class="kw">;</span>
  };
  <span class="ex">pkgs</span> = import nixpkgs <span class="dt">{}</span><span class="kw">;</span>
  <span class="ex">haskellPkgs</span> = pkgs.haskell.packages.ghc802.override {
    <span class="ex">overrides</span> = self: super: {
      <span class="ex">doctemplates</span> = self.callHackage <span class="st">&quot;doctemplates&quot;</span> <span class="st">&quot;0.2.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">hslua</span> = self.callHackage <span class="st">&quot;hslua&quot;</span> <span class="st">&quot;0.9.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.0.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">skylighting</span> = self.callHackage <span class="st">&quot;skylighting&quot;</span> <span class="st">&quot;0.4.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
    };
  };
<span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {
  <span class="ex">buildInputs</span> = [ haskellPkgs.pandoc ]<span class="kw">;</span>
} <span class="st">&quot;&quot;</span></code></pre></div>
<p>Now we use the system-wide <code>nixpkgs</code> only to provide one function, <code>fetchFromGitHub</code>, which we then use to download a specific version of <code>nixpkgs</code> that we import instead. This is easier to use but computing the <code>sha256</code> is frustrating. One trick to keep in mind is that <code>fetchFromGitHub</code> is equivalent to</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">nix-prefetch-url</span> --unpack https://github.com/<span class="op">&lt;</span>owner<span class="op">&gt;</span>/<span class="op">&lt;</span>repo<span class="op">&gt;</span>/archive/<span class="op">&lt;</span>rev<span class="op">&gt;</span>.tar.gz</code></pre></div>
<p>which outputs the correct hash at the end.</p>
<p>What happens if we want to update pinned version? One workflow I’ve seen suggested is to update the <code>rev</code>, change one character in the <code>sha256</code>, and let the Nix error message tell you the correct hash to use. I think we can do better than this.</p>
<p><a href="https://github.com/expipiplus1">Joe Hermaszewski</a> has a handy tool called <a href="https://github.com/expipiplus1/update-nix-fetchgit">update-nix-fetchgit</a> that parses Nix files and automatically updates any <code>fetchFromGitHub</code> calls to the latest <code>master</code> revision and SHA256 of the repository. This is certainly a lot more convenient, but it doesn’t seem to work for repositories that don’t have a <code>master</code> branch or that we want to update to the <code>HEAD</code> of a different branch. This seems like an unimportant omission except that <code>nixpkgs-channels</code> is one such repository, and we want to update it to the <code>HEAD</code> of e.g. <code>nixos-17.09</code>.</p>
<p>So, we have a tedious manual process on one hand and a quick, efficient, and wrong process on the other. There has to be a better way!</p>
<p>I’ve settled on a solution that uses two extra files: an <code>updater</code> script and a <code>versions.json</code> that stores the arguments to <code>fetchFromGitHub</code> as JSON.</p>
<p>My <code>updater</code> script looks like</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="co">#! /usr/bin/env nix-shell</span>
<span class="co">#! nix-shell -i bash</span>
<span class="co">#! nix-shell -p curl jq nix</span>

<span class="kw">set</span> <span class="ex">-eufo</span> pipefail

<span class="va">FILE=$1</span>
<span class="va">PROJECT=$2</span>
<span class="va">BRANCH=${3:-</span>master<span class="va">}</span>

<span class="va">OWNER=$(</span><span class="ex">jq</span> -r <span class="st">'.[$project].owner'</span> --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span>
<span class="va">REPO=$(</span><span class="ex">jq</span> -r <span class="st">'.[$project].repo'</span> --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span>

<span class="va">REV=$(</span><span class="ex">curl</span> <span class="st">&quot;https://api.github.com/repos/</span><span class="va">$OWNER</span><span class="st">/</span><span class="va">$REPO</span><span class="st">/branches/</span><span class="va">$BRANCH</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="ex">jq</span> -r <span class="st">'.commit.sha'</span><span class="va">)</span>
<span class="va">SHA256=$(</span><span class="ex">nix-prefetch-url</span> --unpack <span class="st">&quot;https://github.com/</span><span class="va">$OWNER</span><span class="st">/</span><span class="va">$REPO</span><span class="st">/archive/</span><span class="va">$REV</span><span class="st">.tar.gz&quot;</span><span class="va">)</span>
<span class="va">TJQ=$(</span><span class="ex">jq</span> <span class="st">'.[$project] = {owner: $owner, repo: $repo, rev: $rev, sha256: $sha256}'</span> \
  --arg project <span class="st">&quot;</span><span class="va">$PROJECT</span><span class="st">&quot;</span> \
  --arg owner <span class="st">&quot;</span><span class="va">$OWNER</span><span class="st">&quot;</span> \
  --arg repo <span class="st">&quot;</span><span class="va">$REPO</span><span class="st">&quot;</span> \
  --arg rev <span class="st">&quot;</span><span class="va">$REV</span><span class="st">&quot;</span> \
  --arg sha256 <span class="st">&quot;</span><span class="va">$SHA256</span><span class="st">&quot;</span> \
  <span class="op">&lt;</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span><span class="va">)</span>
<span class="kw">[[</span> <span class="va">$?</span> <span class="ot">==</span> 0<span class="kw"> ]]</span> <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">${TJQ}</span><span class="st">&quot;</span> <span class="op">&gt;</span><span class="kw">|</span> <span class="st">&quot;</span><span class="va">$FILE</span><span class="st">&quot;</span></code></pre></div>
<p>It uses <code>curl</code> and <code>jq</code> to interact with the GitHub API and <code>nix</code> to calculate the appropriate hashes.</p>
<p>A simple <code>versions.json</code> looks like</p>
<div class="sourceCode"><pre class="sourceCode json"><code class="sourceCode json"><span class="fu">{</span>
  <span class="dt">&quot;nixpkgs&quot;</span><span class="fu">:</span> <span class="fu">{</span>
    <span class="dt">&quot;owner&quot;</span><span class="fu">:</span> <span class="st">&quot;NixOS&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;repo&quot;</span><span class="fu">:</span> <span class="st">&quot;nixpkgs-channels&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;rev&quot;</span><span class="fu">:</span> <span class="st">&quot;d9a2891c32ee452a2cd701310040b660da0cc853&quot;</span><span class="fu">,</span>
    <span class="dt">&quot;sha256&quot;</span><span class="fu">:</span> <span class="st">&quot;14m6krpv7iga96bjpb4xmdq1fpysryyfvkghn68k6g8gr9y61fqs&quot;</span>
  <span class="fu">}</span>
<span class="fu">}</span></code></pre></div>
<p>And a Nix expression using these files looks like</p>
<div class="sourceCode"><pre class="sourceCode nix"><code class="sourceCode bash"><span class="bu">let</span>
  <span class="ex">inherit</span> (import <span class="op">&lt;</span>nixpkgs<span class="op">&gt;</span> <span class="dt">{}</span>) <span class="ex">fetchFromGitHub</span> lib<span class="kw">;</span>
  <span class="ex">versions</span> = lib.mapAttrs
    <span class="kw">(</span><span class="ex">_</span>: fetchFromGitHub<span class="kw">)</span>
    <span class="kw">(</span><span class="ex">builtins.fromJSON</span> (builtins.readFile ./versions.json<span class="kw">)</span>);
  <span class="co"># ./updater versions.json nixpkgs nixos-17.09</span>
  <span class="ex">pkgs</span> = import versions.nixpkgs <span class="dt">{}</span><span class="kw">;</span>
  <span class="ex">haskellPkgs</span> = pkgs.haskell.packages.ghc802.override {
    <span class="ex">overrides</span> = self: super: {
      <span class="ex">doctemplates</span> = self.callHackage <span class="st">&quot;doctemplates&quot;</span> <span class="st">&quot;0.2.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">hslua</span> = self.callHackage <span class="st">&quot;hslua&quot;</span> <span class="st">&quot;0.9.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">pandoc</span> = self.callHackage <span class="st">&quot;pandoc&quot;</span> <span class="st">&quot;2.0.1&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">pandoc-types</span> = self.callHackage <span class="st">&quot;pandoc-types&quot;</span> <span class="st">&quot;1.17.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
      <span class="ex">skylighting</span> = self.callHackage <span class="st">&quot;skylighting&quot;</span> <span class="st">&quot;0.4.2&quot;</span> <span class="dt">{}</span><span class="kw">;</span>
    };
  };
<span class="kw">in</span> <span class="ex">pkgs.runCommand</span> <span class="st">&quot;dummy&quot;</span> {
  <span class="ex">buildInputs</span> = [ haskellPkgs.pandoc ]<span class="kw">;</span>
} <span class="st">&quot;&quot;</span></code></pre></div>
<p>And the command to update <code>nixpkgs</code> is</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">./updater</span> versions.json nixpkgs nixos-17.09</code></pre></div>
<p>The reason I went with this approach is that <code>jq</code> is easier and friendlier to use than most of the Nix tooling available, and Nix fortunately has good JSON interoperability. I’ve toyed with the idea of rewriting my updater script in a language that is more robust but I feel like it’s at a local maximum and I’m happy with the way it works for now.</p>
<p>I hope you find some of the ideas and/or code here useful the next time you’re wondering if you should pin <code>nixpkgs</code> and how to do so!</p>

        </div>
        <div id="footer">
            <div class="rc-scout">
                <script async defer src="https://www.recurse-scout.com/loader.js?t=5ac465e5d3396a7e491e42afac4c5c90"></script>
            </div>
        </div>
    </body>
</html>
