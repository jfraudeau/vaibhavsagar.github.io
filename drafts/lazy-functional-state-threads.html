<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <title>Lazy Functional State Threads</title>
        <link rel="stylesheet" href="http://www.vaibhavsagar.com/theme/css/main.css" />
        <link href="http://www.vaibhavsagar.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Vaibhav Sagar's Site Atom Feed" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
<a href="https://github.com/vaibhavsagar">
<img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" />
</a>
        <header id="banner" class="body">
                <h1><a href="http://www.vaibhavsagar.com/">Vaibhav Sagar's Site </a></h1>
                <nav><ul>
                    <li><a href="/blog/archives/">all</a></li>
                    <li><a href="http://www.vaibhavsagar.com/about/">about</a></li>
                    <li><a href="http://www.vaibhavsagar.com/blog/misc/">misc</a></li>
                    <li class="active"><a href="http://www.vaibhavsagar.com/blog/programming/">programming</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="http://www.vaibhavsagar.com/drafts/lazy-functional-state-threads.html" rel="bookmark"
           title="Permalink to Lazy Functional State Threads">Lazy Functional State Threads</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-06-19T00:00:00+10:00">
                Published: Mon 19 June 2017
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="http://www.vaibhavsagar.com/author/vaibhav-sagar.html">Vaibhav Sagar</a>
        </address>
<p>In <a href="http://www.vaibhavsagar.com/blog/programming/">programming</a>.</p>

</footer><!-- /.post-info -->      <p>A funny thing happened when I was writing my Imperative Haskell post: after
railing against Haskell's tendency to tell you to go off and read a paper when
introducing a library, I went off and read 'Lazy Functional State Threads' and
was gobsmacked by how accessible I found it. I'd like to try and demystify it
for a wider audience.</p>
<p>The paper begins by admitting that we sometimes want to express strict stateful
computations in a purely-functional language efficiently. We want to do this
<a href="http://www.threewordphrase.com/pardonme.gif">because of reasons</a>. Some
examples of algorithms we'd like to express are those based on mutable hash
tables, union find, and especially input/output. However, the language we are
working with is renowned for its laziness, which means the order of evaluation
can be counterintuitive, and its referential transparency, which means a lack
of side effects.</p>
<p>We square this circle by leveraging the type system, which simultaneously
allows most of the features we take for granted in imperative languages
(multiple named variables, in-place updates) as well as being encapsulated and
referentially transparent (for certain values of referentially transparent).
Let's define a 'state transformer' that takes an initial state as input and
returns a final state. This can be represented as a value of type <code>ST s a</code>
where <code>s</code> is the state type and <code>a</code> is the return type.</p>
<!-- picture of state transformer -->

<p>A state transformer can have multiple inputs (multiple arguments to a function)
and multiple outputs (a tuple).</p>
<!-- picture of multiple input/output state transformer -->

<p>The simplest state transformer takes a value of type <code>a</code> and sticks it in a
state transformer. We'll call it <code>returnST</code>.</p>
<!-- picture of returnST -->

<p>Let's talk about 'state' now, specifically mutable variables or references.
Let's specify an API for working with references:</p>
<div class="highlight"><pre><span></span><span class="nf">newVar</span>   <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="p">(</span><span class="kt">MutVar</span> <span class="n">s</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">readVar</span>  <span class="ow">::</span> <span class="kt">MutVar</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">a</span>
<span class="nf">writeVar</span> <span class="ow">::</span> <span class="kt">MutVar</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="nb">()</span>
</pre></div>


<p>In other words, <code>newVar</code> takes a value of type <code>a</code> and returns a state
transformer that can be supplied a state to output a new state containing a
fresh reference to the provided value. <code>readVar</code> is a state transformer which
leaves the provided state unchanged but extracts the value in the reference
from it. <code>writeVar</code> takes a reference and a new value and returns a state
transformer that updates the reference to point to the new value. The fact that
the return value is <code>()</code> indicates that this state transformer is only useful
for its effect on the state.</p>
<p>To compose these state transformers together we can define a <code>thenST</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">thenST</span> <span class="ow">::</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">b</span>
</pre></div>


<!-- picture of thenST -->

<p>Two things to note here: both <code>s1</code> and <code>s2</code> have to work with the same state
type <code>s</code>, and they way they work is inherently sequential, because the output
of <code>s1</code> is the input of <code>s2</code>. This is where 'thread' in the title comes from. I
like to think of this as the baton in a relay: you can't run when you're not
holding the baton, and you can't use a different team's baton because that's
against the rules.</p>
<p>While we let that sink in, I'd like to make a brief historical digression. At
this stage in Haskell's history, monads had been identified as a useful
abstraction and a predecessor to this paper had proposed a particular syntax
for working with them, but do-notation had not yet made its way into the
language. If you're not familiar with monads, you can think of them as an
interface for a type defined by two functions, <code>return</code> and <code>&gt;&gt;=</code>
(pronounced 'bind') and certain laws that these functions must obey:</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="kr">where</span>
    <span class="n">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>


<p>The actual definition differs slightly in ways that aren't relevant here. Why
do I bring this up? If you look closely, we've encountered functions that look
very similar to the two above. If we textually replace <code>m</code> with <code>ST s</code>, we get</p>
<div class="highlight"><pre><span></span><span class="nf">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">a</span>
<span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="ow">::</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">b</span>
</pre></div>


<p>which are exactly the type signatures of <code>returnST</code> and <code>thenST</code>. This isn't a
coincidence. I will also claim (but not prove) that these definitions are
law-abiding.</p>
<p>What can we do with this information? Let's take this code snippet that swaps
the contents of two references:</p>
<div class="highlight"><pre><span></span><span class="nf">swap</span> <span class="ow">::</span> <span class="kt">MutVar</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">MutVar</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="nb">()</span>
<span class="nf">swap</span> <span class="n">v</span> <span class="n">w</span> <span class="ow">=</span> <span class="n">readVar</span> <span class="n">v</span>    <span class="p">`</span><span class="n">thenST</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="ow">-&gt;</span>
           <span class="n">readVar</span> <span class="n">w</span>    <span class="p">`</span><span class="n">thenST</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="n">b</span> <span class="ow">-&gt;</span>
           <span class="n">writeVar</span> <span class="n">v</span> <span class="n">b</span> <span class="p">`</span><span class="n">thenST</span><span class="p">`</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span>
           <span class="n">writeVar</span> <span class="n">w</span> <span class="n">a</span><span class="p">)))</span>
</pre></div>


<p>This requires working with infix backticks and lambdas and looks pretty ugly,
but we can do better! We have do-notation which is syntax sugar that converts</p>
<div class="highlight"><pre><span></span><span class="kr">do</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">f</span>
   <span class="n">y</span>
</pre></div>


<p>into</p>
<div class="highlight"><pre><span></span><span class="nf">f</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">y</span><span class="p">)</span>
</pre></div>


<p>and</p>
<div class="highlight"><pre><span></span><span class="kr">do</span> <span class="n">x</span>
   <span class="n">y</span>
</pre></div>


<p>into</p>
<div class="highlight"><pre><span></span><span class="nf">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span>
</pre></div>


<p>where <code>&gt;&gt;</code> is like <code>&gt;&gt;=</code> that ignores the output of the left hand side:</p>
<div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="p">(</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="n">ma</span> <span class="n">mb</span> <span class="ow">=</span> <span class="n">ma</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">mb</span><span class="p">)</span>
</pre></div>


<p>Armed with this knowledge, we can rewrite the above example:</p>
<div class="highlight"><pre><span></span><span class="nf">swap</span> <span class="ow">::</span> <span class="kt">MutVar</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">MutVar</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="nb">()</span>
<span class="nf">swap</span> <span class="n">v</span> <span class="n">w</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">readVar</span> <span class="n">v</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">readVar</span> <span class="n">w</span>
    <span class="n">writeVar</span> <span class="n">v</span> <span class="n">b</span>
    <span class="n">writeVar</span> <span class="n">w</span> <span class="n">a</span>
</pre></div>


<p>Much better! We even define <code>(&gt;&gt;)</code> directly as <code>thenST_</code>. The rest of the code
samples in this post will use do-notation.</p>
<p>The authors also mention the existence of <code>fixST</code>, but this isn't discussed
elsewhere in the paper so I'll skip that.</p>
<p>We now move to the other main contribution of the paper, which is the matter of
how to prevent state from leaking out of our state transformers. The naive
approach would be to define a <code>runST</code> that would provide an initial state as
follows:</p>
<div class="highlight"><pre><span></span><span class="nf">runST</span> <span class="ow">::</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>


<p>But this would allow leakage as in the following example:</p>
<div class="highlight"><pre><span></span><span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">runST</span> <span class="p">(</span><span class="n">newVar</span> <span class="kt">True</span><span class="p">)</span>
<span class="kr">in</span>
<span class="nf">runST</span> <span class="p">(</span><span class="n">readVar</span> <span class="n">v</span><span class="p">)</span>
</pre></div>


<p>and because Haskell is a lazy language, we cannot enforce an ordering on
updates to the state. What we really want is for our <code>runST</code> to work <em>regardless
of which initial state it was given</em>, and we can encode that in the type
signature with rank-2 polymorphism as follows:</p>
<div class="highlight"><pre><span></span><span class="nf">runST</span> <span class="ow">::</span> <span class="err">∀</span><span class="n">a</span><span class="o">.</span> <span class="p">(</span><span class="err">∀</span><span class="n">s</span><span class="o">.</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>


<p>We can read ∀ as 'forall' and this is rank-2 because <code>s</code> is scoped within the
parentheses and we can't move it outside without changing the meaning of the
type signature. We can read this as 'for any <code>a</code>, given a state transformer
that would work with any <code>s</code>, provide it with some state and extract the <code>a</code>'.
Our previous example no longer typechecks, because <code>v</code> does not have the type
<code>∀s.ST s a</code>, and we can see that the typechecker enforces our requirement that
the state cannot leak out of the state transformer, hence ensuring referential
transparency. This definition still allows useful code such as:</p>
<div class="highlight"><pre><span></span><span class="nf">f</span> <span class="ow">::</span> <span class="kt">MutVar</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">MutVar</span> <span class="n">s</span> <span class="n">a</span>
<span class="nf">f</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">runST</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">w</span> <span class="ow">&lt;-</span> <span class="n">newVar</span> <span class="n">v</span>
    <span class="n">readVar</span> <span class="n">w</span>
</pre></div>


<p>which works because <code>v</code> is never dereferenced.</p>
<p>We can generalise our references to consider an array of mutable references. An
API for this could look like:</p>
<div class="highlight"><pre><span></span><span class="nf">newArr</span>    <span class="ow">::</span> <span class="kt">Ix</span> <span class="n">i</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">elt</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="p">(</span><span class="kt">MutArr</span> <span class="n">s</span> <span class="n">i</span> <span class="n">elt</span><span class="p">)</span>
<span class="nf">readArr</span>   <span class="ow">::</span> <span class="kt">Ix</span> <span class="n">i</span> <span class="ow">=&gt;</span> <span class="kt">MutArr</span> <span class="n">s</span> <span class="n">i</span> <span class="n">elt</span> <span class="ow">-&gt;</span> <span class="n">i</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="n">elt</span>
<span class="nf">writeArr</span>  <span class="ow">::</span> <span class="kt">Ix</span> <span class="n">i</span> <span class="ow">=&gt;</span> <span class="kt">MutArr</span> <span class="n">s</span> <span class="n">i</span> <span class="n">elt</span> <span class="ow">-&gt;</span> <span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">elt</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="nb">()</span>
<span class="nf">freezeArr</span> <span class="ow">::</span> <span class="kt">Ix</span> <span class="n">i</span> <span class="ow">=&gt;</span> <span class="kt">MutArr</span> <span class="n">s</span> <span class="n">i</span> <span class="n">elt</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Array</span> <span class="n">i</span> <span class="n">elt</span><span class="p">)</span>
</pre></div>


<p>This is very similar to our API for references, but parametrised over the index
type <code>i</code> and including a function <code>freezeArr</code> that looks up the current value
of a mutable array in the state and returns an immutable copy of it.</p>
<p>With this API, we can define <code>accumArray</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">accumArray</span> <span class="ow">::</span> <span class="kt">Ix</span> <span class="n">i</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">i</span> <span class="n">a</span>
</pre></div>


<p>This takes a function, an initial value, array bounds, and a list of indexed
values, and does a left fold over each indexed value, putting the result at the
associated index. This can be used to compute a histogram:</p>
<div class="highlight"><pre><span></span><span class="nf">hist</span> <span class="ow">::</span> <span class="kt">Ix</span> <span class="n">i</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">i</span> <span class="kt">Int</span>
<span class="nf">hist</span> <span class="n">bnds</span> <span class="n">is</span> <span class="ow">=</span> <span class="n">accumArray</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="n">bnds</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="n">is</span><span class="p">,</span> <span class="n">inRange</span> <span class="n">bnds</span> <span class="n">i</span><span class="p">]</span>
</pre></div>


<p>that counts occurrences of elements in <code>is</code> within the bounds provided or
<code>binSort</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">binSort</span> <span class="ow">::</span> <span class="kt">Ix</span> <span class="n">i</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">i</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">i</span> <span class="n">a</span>
<span class="nf">binSort</span> <span class="n">bnds</span> <span class="n">key</span> <span class="n">vs</span> <span class="ow">=</span> <span class="n">accumArray</span> <span class="p">(</span><span class="n">flip</span> <span class="p">(</span><span class="kt">:</span><span class="p">))</span> <span class="kt">[]</span> <span class="n">bnds</span> <span class="p">[(</span><span class="n">key</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">|</span> <span class="n">v</span> <span class="ow">&lt;-</span> <span class="n">vs</span><span class="p">]</span>
</pre></div>


<p>that puts each element of <code>vs</code> into a bin based on its <code>key</code>. <code>accumArray</code> can
be defined as follows:</p>
<div class="highlight"><pre><span></span><span class="nf">accumArray</span> <span class="n">f</span> <span class="n">z</span> <span class="n">bnds</span> <span class="n">ivs</span> <span class="ow">=</span> <span class="n">runST</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">newArr</span> <span class="n">bnds</span> <span class="n">z</span>
    <span class="n">fill</span> <span class="n">a</span> <span class="n">f</span> <span class="n">ivs</span>
    <span class="n">freezeArr</span> <span class="n">a</span>

<span class="nf">fill</span> <span class="n">a</span> <span class="n">f</span> <span class="kt">[]</span>          <span class="ow">=</span> <span class="n">return</span> <span class="nb">()</span>
<span class="nf">fill</span> <span class="n">a</span> <span class="n">f</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="kt">:</span><span class="n">ivs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">readArr</span> <span class="n">a</span> <span class="n">i</span>
    <span class="n">writeArr</span> <span class="n">a</span> <span class="n">i</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">fill</span> <span class="n">a</span> <span class="n">f</span> <span class="n">ivs</span>
</pre></div>


<p>This is a good example of a function that is internally imperative but
externally pure.</p>
<p>If we define a function to sequence state transformers:</p>
<div class="highlight"><pre><span></span><span class="nf">seqST</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">ST</span> <span class="n">s</span> <span class="nb">()</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="nb">()</span>
<span class="nf">seqST</span> <span class="ow">=</span> <span class="n">sequence_</span> <span class="c1">-- originally defined as `foldr (&gt;&gt;) (return ())`</span>
</pre></div>


<p>then we can rewrite <code>accumArray</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">accumArray</span> <span class="n">f</span> <span class="n">z</span> <span class="n">bnds</span> <span class="n">ivs</span> <span class="ow">=</span> <span class="n">runST</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">newArr</span> <span class="n">bnds</span> <span class="n">z</span>
    <span class="n">seqST</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">update</span> <span class="n">a</span> <span class="n">f</span><span class="p">)</span> <span class="n">ivs</span><span class="p">)</span>
    <span class="n">freezeArr</span> <span class="n">s</span>

<span class="nf">update</span> <span class="n">a</span> <span class="n">f</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">readArr</span> <span class="n">a</span> <span class="n">i</span>
    <span class="n">writeArr</span> <span class="n">a</span> <span class="n">i</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span> <span class="n">v</span><span class="p">)</span>
</pre></div>


<p>Let's reformulate IO in terms of state transformers. It can be thought of as
a state transformer of type <code>ST RealWorld a</code>, where <code>RealWorld</code> is an abstract
type representing the real world. We can make this explicit as a type synonym:</p>
<div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">IO</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ST</span> <span class="kt">RealWorld</span> <span class="n">a</span>
</pre></div>


<p>We also have a few functions that are specific to IO but not other ST
computations, e.g.</p>
<div class="highlight"><pre><span></span><span class="nf">putChar</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">getChar</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">Char</span>
</pre></div>


<p>And this is enough to build e.g. <code>putString</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">putString</span> <span class="n">cs</span> <span class="ow">=</span> <span class="n">seqST</span> <span class="p">(</span><span class="n">map</span> <span class="n">putChar</span> <span class="n">cs</span><span class="p">)</span>
</pre></div>


<p>However, we can take it further and define both <code>putChar</code> and <code>getChar</code> in
terms of <code>ccall</code>, which is a language construct that allows the programmer to
call any C procedure (with certain restrictions placed on its use):</p>
<div class="highlight"><pre><span></span><span class="nf">putChar</span> <span class="n">c</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">ccall</span> <span class="n">putChar</span> <span class="n">c</span>
    <span class="n">return</span> <span class="nb">()</span>
<span class="nf">getChar</span> <span class="ow">=</span> <span class="n">ccall</span> <span class="n">getChar</span>
</pre></div>


<p>Because <code>IO</code> is not polymorphic in its state, it can't be used with <code>runST</code>.
This is the behaviour we want, and we need to define a special function to
execute <code>IO</code> actions. We can call this <code>mainIO</code>:</p>
<div class="highlight"><pre><span></span><span class="nf">mainIO</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
</pre></div>


<p>and have it play a role similar to <code>main()</code> in C. In fact, IO in GHC is
implemented in Haskell in precisely this manner.</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>
                            <li><a href="http://www.vaibhavsagar.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate">atom feed</a></li>

                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

    <script type="text/javascript">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-79891461-1', 'auto');
    ga('send', 'pageview');
    </script>
<script type="text/javascript">
    var disqus_shortname = 'vaibhavsagar';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>
</html>