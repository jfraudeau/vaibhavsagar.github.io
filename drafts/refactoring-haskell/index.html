<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Refactoring Haskell: A Case Study - Vaibhav Sagar</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-79891461-1', 'auto');
          ga('send', 'pageview');

        </script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">Vaibhav Sagar</a>
            </div>
            <div id="navigation">
                <a href="../../about/">About</a>
                <a href="../../archive/">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Refactoring Haskell: A Case Study</h1>

            <div class="info">
    Posted on 28 February 2018
    
</div>
<div class="info">
    
        Tags: <a href="../../blog/tags/programming/">programming</a>, <a href="../../blog/tags/haskell/">haskell</a>
    
</div>

<p>Many people claim that <a href="https://twitter.com/search?q=haskell%20refactoring">refactoring Haskell is a joy</a>. I’ve certainly found this to be the case, but what does that mean in practice? I thought it might be useful to demonstrate by refactoring some of my own code from when I was less familiar with Haskell.</p>
<p>The code we’re looking at today is an implementation of <a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Tarjan’s Strongly Connected Components algorithm</a> used to determine whether a given 2SAT problem is satisfiable or not, and was written to complete <a href="https://online.stanford.edu/course/algorithms-design-and-analysis-part-1">an online course</a> that is now offered in a different form. I’ve <a href="http://vaibhavsagar.com/blog/2017/06/10/dag-toolkit/">written about Tarjan’s algorithm previously</a> and it can be used to determine the satisfiability of a 2SAT problem by checking if any SCC contains both a variable and its negation. If it does, we have a contradiction and the problem is unsatisfiable, otherwise the problem is satisfiable.</p>
<p>The initial version of the code is as follows:</p>
<p><details> <summary>Initial 2SAT.hs</summary></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE LambdaCase #-}</span>

<span class="kw">import qualified</span> <span class="dt">Data.Graph</span>      <span class="kw">as</span> <span class="dt">G</span>
<span class="kw">import qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">M</span>
<span class="kw">import qualified</span> <span class="dt">Data.Set</span>        <span class="kw">as</span> <span class="dt">S</span>
<span class="kw">import qualified</span> <span class="dt">Data.Array</span>      <span class="kw">as</span> <span class="dt">A</span>
<span class="kw">import qualified</span> <span class="dt">Prelude</span>         <span class="kw">as</span> <span class="dt">P</span>

<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)

<span class="kw">import </span><span class="dt">Control.Monad.ST</span>
<span class="kw">import </span><span class="dt">Data.STRef</span>
<span class="kw">import </span><span class="dt">Control.Monad</span> (forM_, when)
<span class="kw">import </span><span class="dt">Data.Maybe</span> (isJust, isNothing, fromJust)

<span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>]
tarjan n graph <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span>
    index    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span>
    stack    <span class="ot">&lt;-</span> newSTRef []
    stackSet <span class="ot">&lt;-</span> newSTRef S.empty
    indices  <span class="ot">&lt;-</span> newSTRef M.empty
    lowlinks <span class="ot">&lt;-</span> newSTRef M.empty
    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])

    forM_ (G.vertices graph) <span class="fu">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span>
        vIndex <span class="ot">&lt;-</span> M.lookup v <span class="fu">&lt;$&gt;</span> readSTRef indices
        when (isNothing vIndex) <span class="fu">$</span>
            strongConnect n v graph index stack stackSet indices lowlinks output

    readSTRef output

strongConnect
<span class="ot">    ::</span> <span class="dt">Int</span>
    <span class="ot">-&gt;</span> <span class="dt">Int</span>
    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span>
    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span>
    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]
    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>)
    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)
    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)
    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>])
    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()
strongConnect n v graph index stack stackSet indices lowlinks output <span class="fu">=</span> <span class="kw">do</span>
    i <span class="ot">&lt;-</span> readSTRef index
    insert v i indices
    insert v i lowlinks
    modifySTRef' index (<span class="fu">+</span><span class="dv">1</span>)
    push stack stackSet v

    forM_ (graph <span class="fu">A.!</span> v) <span class="fu">$</span> \w <span class="ot">-&gt;</span> lookup w indices <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span>
        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="kw">do</span>
            strongConnect n w graph index stack stackSet indices lowlinks output
            vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup v lowlinks
            wLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup w lowlinks
            insert v (min vLowLink wLowLink) lowlinks
        <span class="dt">Just</span> wIndex <span class="ot">-&gt;</span> <span class="kw">do</span>
            wOnStack <span class="ot">&lt;-</span> S.member w <span class="fu">&lt;$&gt;</span> readSTRef stackSet
            when wOnStack <span class="fu">$</span> <span class="kw">do</span>
                vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup v lowlinks
                insert v (min vLowLink wIndex) lowlinks

    vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup v lowlinks
    vIndex   <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup v indices
    when (vLowLink <span class="fu">==</span> vIndex) <span class="fu">$</span> <span class="kw">do</span>
        scc <span class="ot">&lt;-</span> addSCC n v S.empty stack stackSet
        modifySTRef' output <span class="fu">$</span> \sccs <span class="ot">-&gt;</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> scc <span class="fu">&lt;*&gt;</span> sccs
    <span class="kw">where</span>
        lookup value hashMap     <span class="fu">=</span> M.lookup value <span class="fu">&lt;$&gt;</span> readSTRef hashMap
        insert key value hashMap <span class="fu">=</span> modifySTRef' hashMap (M.insert key value)

<span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> (<span class="dt">S.Set</span> <span class="dt">Int</span>))
addSCC n v scc stack stackSet <span class="fu">=</span> pop stack stackSet <span class="fu">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`S.member`</span> scc) <span class="kw">then</span> return <span class="dt">Nothing</span> <span class="kw">else</span>
    <span class="kw">let</span> scc' <span class="fu">=</span> S.insert w scc
    <span class="kw">in</span> <span class="kw">if</span> w <span class="fu">==</span> v <span class="kw">then</span> return (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc' stack stackSet

<span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()
push stack stackSet e <span class="fu">=</span> <span class="kw">do</span>
    modifySTRef' stack    (e<span class="fu">:</span>)
    modifySTRef' stackSet (S.insert e)

<span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span>
pop stack stackSet <span class="fu">=</span> <span class="kw">do</span>
    e <span class="ot">&lt;-</span> head <span class="fu">&lt;$&gt;</span> readSTRef stack
    modifySTRef' stack tail
    modifySTRef' stackSet (S.delete e)
    return e

denormalise     <span class="fu">=</span> subtract
normalise       <span class="fu">=</span> (<span class="fu">+</span>)
other n v       <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>n <span class="fu">-</span> v
clauses n [u,v] <span class="fu">=</span> [(other n u, v), (other n v, u)]

<span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span>
checkSat name <span class="fu">=</span> <span class="kw">do</span>
    p <span class="ot">&lt;-</span> map (map P.read <span class="fu">.</span> words) <span class="fu">.</span> lines <span class="fu">&lt;$&gt;</span> readFile name
    <span class="kw">let</span> pNo    <span class="fu">=</span> head <span class="fu">$</span> head p
        pn     <span class="fu">=</span> map (map (normalise pNo)) <span class="fu">$</span> tail p
        pGraph <span class="fu">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="fu">*</span>pNo) <span class="fu">$</span> concatMap (clauses pNo) pn
    return <span class="fu">$</span> (<span class="dt">Nothing</span> <span class="fu">/=</span>) <span class="fu">$</span> tarjan pNo pGraph</code></pre></div>
<p></details></p>
<p>I’ve included 2SAT-specific functionality for completeness, but I’ll omit this in future listings as I’ll only be changing the <code>tarjan</code> function and the functions it depends on (<code>strongConnect</code>, <code>addSCC</code>, <code>push</code>, and <code>pop</code>).</p>
<p>The first change is using more suitable data structures. Tarjan’s algorithm is only linear in the size of the graph when operations such as checking if <code>w</code> is on the stack and looking up indices happen in constant time (<span class="math inline"><em>O</em>(1)</span>). I’m currently using <code>Data.Map</code> and <code>Data.Set</code> which are both implemented with trees and are <span class="math inline"><em>O</em>(log <em>n</em>)</span> in these operations.</p>

        </div>
        <div id="footer">
            <div class="rc-scout">
                <script async defer src="https://www.recurse-scout.com/loader.js?t=5ac465e5d3396a7e491e42afac4c5c90"></script>
            </div>
        </div>
    </body>
</html>
