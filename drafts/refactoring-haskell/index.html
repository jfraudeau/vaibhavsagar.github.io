<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Refactoring Haskell: A Case Study - Vaibhav Sagar</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../css/syntax.css" />
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-79891461-1', 'auto');
          ga('send', 'pageview');

        </script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">Vaibhav Sagar</a>
            </div>
            <div id="navigation">
                <a href="../../about/">About</a>
                <a href="../../talks/">Talks</a>
                <a href="../../archive/">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Refactoring Haskell: A Case Study</h1>

            <div class="info">
    Posted on 10 February 2019
    
</div>
<div class="info">
    
        Tags: <a href="../../blog/tags/programming/">programming</a>, <a href="../../blog/tags/haskell/">haskell</a>
    
</div>

<p>Many people claim that <a href="https://twitter.com/search?q=haskell%20refactoring">refactoring Haskell is a joy</a>. I’ve certainly found this to be the case, but what does that mean in practice? I thought it might be useful to demonstrate by refactoring some of my own code.</p>
<p>The code we’re looking at today is an implementation of <a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Tarjan’s Strongly Connected Components algorithm</a> used to determine whether a given <a href="https://en.wikipedia.org/wiki/2-satisfiability">2-SAT problem</a> is satisfiable or not, and was written to complete <a href="https://online.stanford.edu/course/algorithms-design-and-analysis-part-1">an online course</a> that is now offered in a different form. I’ve <a href="http://vaibhavsagar.com/blog/2017/06/10/dag-toolkit/">written about Tarjan’s algorithm previously</a> and it can be used to determine the satisfiability of a 2-SAT problem by checking if any SCC contains both a variable and its negation. If it does, we have a contradiction and the problem is unsatisfiable, otherwise the problem is satisfiable.</p>
<p>This code isn’t particularly elegant or easy to follow, and it’s lousy with mutable state. Despite these drawbacks, it is still relatively straightforward to refactor.</p>
<p>If you’d like to follow along, I have the code (and some test data) available <a href="https://gist.github.com/vaibhavsagar/2418c9dd79da431065ad0d80e690b12f">at this gist</a> with each revision representing a refactoring step.</p>
<p>The initial version of the code is as follows:</p>
<details>
<p><summary style="cursor: pointer">Initial 2SAT.hs</summary></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span>      <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">M</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span>        <span class="kw">as</span> <span class="dt">S</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span>      <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>         <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_, when)</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Data.Maybe</span> (isJust, isNothing, fromJust)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">tarjan n graph <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">    index    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">    stackSet <span class="ot">&lt;-</span> newSTRef S.empty</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">    indices  <span class="ot">&lt;-</span> newSTRef M.empty</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">    lowlinks <span class="ot">&lt;-</span> newSTRef M.empty</a>
<a class="sourceLine" id="cb1-23" data-line-number="23">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb1-24" data-line-number="24"></a>
<a class="sourceLine" id="cb1-25" data-line-number="25">    forM_ (G.vertices graph) <span class="fu">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">        vIndex <span class="ot">&lt;-</span> M.lookup v <span class="fu">&lt;$&gt;</span> readSTRef indices</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">        when (isNothing vIndex) <span class="fu">$</span></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">            strongConnect n v graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb1-29" data-line-number="29"></a>
<a class="sourceLine" id="cb1-30" data-line-number="30">    readSTRef output</a>
<a class="sourceLine" id="cb1-31" data-line-number="31"></a>
<a class="sourceLine" id="cb1-32" data-line-number="32">strongConnect</a>
<a class="sourceLine" id="cb1-33" data-line-number="33"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-34" data-line-number="34">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-35" data-line-number="35">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb1-36" data-line-number="36">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-37" data-line-number="37">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb1-38" data-line-number="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-39" data-line-number="39">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-40" data-line-number="40">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">M.Map</span> <span class="dt">Int</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-41" data-line-number="41">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [<span class="dt">S.Set</span> <span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb1-42" data-line-number="42">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb1-43" data-line-number="43">strongConnect n v graph index stack stackSet indices lowlinks output <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-44" data-line-number="44">    i <span class="ot">&lt;-</span> readSTRef index</a>
<a class="sourceLine" id="cb1-45" data-line-number="45">    insert v i indices</a>
<a class="sourceLine" id="cb1-46" data-line-number="46">    insert v i lowlinks</a>
<a class="sourceLine" id="cb1-47" data-line-number="47">    modifySTRef' index (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-48" data-line-number="48">    push stack stackSet v</a>
<a class="sourceLine" id="cb1-49" data-line-number="49"></a>
<a class="sourceLine" id="cb1-50" data-line-number="50">    forM_ (graph <span class="fu">A.!</span> v) <span class="fu">$</span> \w <span class="ot">-&gt;</span> lookup w indices <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb1-51" data-line-number="51">        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-52" data-line-number="52">            strongConnect n w graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb1-53" data-line-number="53">            vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup v lowlinks</a>
<a class="sourceLine" id="cb1-54" data-line-number="54">            wLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup w lowlinks</a>
<a class="sourceLine" id="cb1-55" data-line-number="55">            insert v (min vLowLink wLowLink) lowlinks</a>
<a class="sourceLine" id="cb1-56" data-line-number="56">        <span class="dt">Just</span> wIndex <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-57" data-line-number="57">            wOnStack <span class="ot">&lt;-</span> S.member w <span class="fu">&lt;$&gt;</span> readSTRef stackSet</a>
<a class="sourceLine" id="cb1-58" data-line-number="58">            when wOnStack <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-59" data-line-number="59">                vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup v lowlinks</a>
<a class="sourceLine" id="cb1-60" data-line-number="60">                insert v (min vLowLink wIndex) lowlinks</a>
<a class="sourceLine" id="cb1-61" data-line-number="61"></a>
<a class="sourceLine" id="cb1-62" data-line-number="62">    vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup v lowlinks</a>
<a class="sourceLine" id="cb1-63" data-line-number="63">    vIndex   <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup v indices</a>
<a class="sourceLine" id="cb1-64" data-line-number="64">    when (vLowLink <span class="fu">==</span> vIndex) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-65" data-line-number="65">        scc <span class="ot">&lt;-</span> addSCC n v S.empty stack stackSet</a>
<a class="sourceLine" id="cb1-66" data-line-number="66">        modifySTRef' output <span class="fu">$</span> \sccs <span class="ot">-&gt;</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> scc <span class="fu">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb1-67" data-line-number="67">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-68" data-line-number="68">        lookup value hashMap     <span class="fu">=</span> M.lookup value <span class="fu">&lt;$&gt;</span> readSTRef hashMap</a>
<a class="sourceLine" id="cb1-69" data-line-number="69">        insert key value hashMap <span class="fu">=</span> modifySTRef' hashMap (M.insert key value)</a>
<a class="sourceLine" id="cb1-70" data-line-number="70"></a>
<a class="sourceLine" id="cb1-71" data-line-number="71"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">S.Set</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> (<span class="dt">S.Set</span> <span class="dt">Int</span>))</a>
<a class="sourceLine" id="cb1-72" data-line-number="72">addSCC n v scc stack stackSet <span class="fu">=</span> pop stack stackSet <span class="fu">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`S.member`</span> scc) <span class="kw">then</span> return <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb1-73" data-line-number="73">    <span class="kw">let</span> scc' <span class="fu">=</span> S.insert w scc</a>
<a class="sourceLine" id="cb1-74" data-line-number="74">    <span class="kw">in</span> <span class="kw">if</span> w <span class="fu">==</span> v <span class="kw">then</span> return (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc' stack stackSet</a>
<a class="sourceLine" id="cb1-75" data-line-number="75"></a>
<a class="sourceLine" id="cb1-76" data-line-number="76"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb1-77" data-line-number="77">push stack stackSet e <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-78" data-line-number="78">    modifySTRef' stack    (e<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb1-79" data-line-number="79">    modifySTRef' stackSet (S.insert e)</a>
<a class="sourceLine" id="cb1-80" data-line-number="80"></a>
<a class="sourceLine" id="cb1-81" data-line-number="81"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">S.Set</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-82" data-line-number="82">pop stack stackSet <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-83" data-line-number="83">    e <span class="ot">&lt;-</span> head <span class="fu">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb1-84" data-line-number="84">    modifySTRef' stack tail</a>
<a class="sourceLine" id="cb1-85" data-line-number="85">    modifySTRef' stackSet (S.delete e)</a>
<a class="sourceLine" id="cb1-86" data-line-number="86">    return e</a>
<a class="sourceLine" id="cb1-87" data-line-number="87"></a>
<a class="sourceLine" id="cb1-88" data-line-number="88">denormalise     <span class="fu">=</span> subtract</a>
<a class="sourceLine" id="cb1-89" data-line-number="89">normalise       <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb1-90" data-line-number="90">other n v       <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>n <span class="fu">-</span> v</a>
<a class="sourceLine" id="cb1-91" data-line-number="91">clauses n [u,v] <span class="fu">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb1-92" data-line-number="92"></a>
<a class="sourceLine" id="cb1-93" data-line-number="93"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-94" data-line-number="94">checkSat name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-95" data-line-number="95">    p <span class="ot">&lt;-</span> map (map P.read <span class="fu">.</span> words) <span class="fu">.</span> lines <span class="fu">&lt;$&gt;</span> readFile name</a>
<a class="sourceLine" id="cb1-96" data-line-number="96">    <span class="kw">let</span> pNo    <span class="fu">=</span> head <span class="fu">$</span> head p</a>
<a class="sourceLine" id="cb1-97" data-line-number="97">        pn     <span class="fu">=</span> map (map (normalise pNo)) <span class="fu">$</span> tail p</a>
<a class="sourceLine" id="cb1-98" data-line-number="98">        pGraph <span class="fu">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="fu">*</span>pNo) <span class="fu">$</span> concatMap (clauses pNo) pn</a>
<a class="sourceLine" id="cb1-99" data-line-number="99">    return <span class="fu">$</span> (<span class="dt">Nothing</span> <span class="fu">/=</span>) <span class="fu">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>I’ve included 2SAT-specific functionality for completeness, but I’ll only be changing the <code>tarjan</code> function and the functions it depends on (<code>strongConnect</code>, <code>addSCC</code>, <code>push</code>, and <code>pop</code>).</p>
<p>The first change is using more suitable data structures. Tarjan’s algorithm is only linear in the size of the graph when operations, such as checking if <code>w</code> is on the stack and looking up indices, happen in constant time (<span class="math inline"><em>O</em>(1)</span>). I’m currently using <code>Data.Map</code> and <code>Data.Set</code> which are both implemented with trees and are <span class="math inline"><em>O</em>(log <em>n</em>)</span> in these operations. A better choice would be <a href="http://hackage.haskell.org/package/vector/docs/Data-Vector-Mutable.html"><code>Data.Vector.Mutable</code></a> from the <code>vector</code> package, which does have constant-time operations.</p>
<p>This refactoring mostly consists of initialising vectors with a known length and replacing calls to <code>lookup</code> and <code>insert</code> with calls to <code>read</code> and <code>write</code>.</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>vector</code></summary></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_, when)</a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Data.Maybe</span>          (isJust, isNothing, fromJust)</a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb2-14" data-line-number="14"></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">tarjan n graph <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">    index    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">    stackSet <span class="ot">&lt;-</span> replicate size <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">    indices  <span class="ot">&lt;-</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21">    lowlinks <span class="ot">&lt;-</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb2-22" data-line-number="22">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb2-23" data-line-number="23"></a>
<a class="sourceLine" id="cb2-24" data-line-number="24">    forM_ (G.vertices graph) <span class="fu">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-25" data-line-number="25">        vIndex <span class="ot">&lt;-</span> read indices v</a>
<a class="sourceLine" id="cb2-26" data-line-number="26">        when (isNothing vIndex) <span class="fu">$</span></a>
<a class="sourceLine" id="cb2-27" data-line-number="27">            strongConnect n v graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb2-28" data-line-number="28"></a>
<a class="sourceLine" id="cb2-29" data-line-number="29">    readSTRef output</a>
<a class="sourceLine" id="cb2-30" data-line-number="30">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-31" data-line-number="31">        size <span class="fu">=</span> snd (A.bounds graph) <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-32" data-line-number="32"></a>
<a class="sourceLine" id="cb2-33" data-line-number="33">strongConnect</a>
<a class="sourceLine" id="cb2-34" data-line-number="34"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-35" data-line-number="35">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-36" data-line-number="36">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb2-37" data-line-number="37">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-38" data-line-number="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb2-39" data-line-number="39">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-40" data-line-number="40">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb2-41" data-line-number="41">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb2-42" data-line-number="42">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb2-43" data-line-number="43">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb2-44" data-line-number="44">strongConnect n v graph index stack stackSet indices lowlinks output <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-45" data-line-number="45">    i <span class="ot">&lt;-</span> readSTRef index</a>
<a class="sourceLine" id="cb2-46" data-line-number="46">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb2-47" data-line-number="47">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb2-48" data-line-number="48">    modifySTRef' index (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb2-49" data-line-number="49">    push stack stackSet v</a>
<a class="sourceLine" id="cb2-50" data-line-number="50"></a>
<a class="sourceLine" id="cb2-51" data-line-number="51">    forM_ (graph <span class="fu">A.!</span> v) <span class="fu">$</span> \w <span class="ot">-&gt;</span> read indices w <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb2-52" data-line-number="52">        <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-53" data-line-number="53">            strongConnect n w graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb2-54" data-line-number="54">            vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> read lowlinks v</a>
<a class="sourceLine" id="cb2-55" data-line-number="55">            wLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> read lowlinks w</a>
<a class="sourceLine" id="cb2-56" data-line-number="56">            write lowlinks v (<span class="dt">Just</span> (min vLowLink wLowLink))</a>
<a class="sourceLine" id="cb2-57" data-line-number="57">        <span class="dt">Just</span> wIndex <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-58" data-line-number="58">            wOnStack <span class="ot">&lt;-</span> read stackSet w</a>
<a class="sourceLine" id="cb2-59" data-line-number="59">            when wOnStack <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-60" data-line-number="60">                vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> read lowlinks v</a>
<a class="sourceLine" id="cb2-61" data-line-number="61">                write lowlinks v (<span class="dt">Just</span> (min vLowLink wIndex))</a>
<a class="sourceLine" id="cb2-62" data-line-number="62"></a>
<a class="sourceLine" id="cb2-63" data-line-number="63">    vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> read lowlinks v</a>
<a class="sourceLine" id="cb2-64" data-line-number="64">    vIndex   <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> read indices  v</a>
<a class="sourceLine" id="cb2-65" data-line-number="65">    when (vLowLink <span class="fu">==</span> vIndex) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-66" data-line-number="66">        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</a>
<a class="sourceLine" id="cb2-67" data-line-number="67">        modifySTRef' output <span class="fu">$</span> \sccs <span class="ot">-&gt;</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> scc <span class="fu">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb2-68" data-line-number="68"></a>
<a class="sourceLine" id="cb2-69" data-line-number="69"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb2-70" data-line-number="70">addSCC n v scc stack stackSet <span class="fu">=</span> pop stack stackSet <span class="fu">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> return <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb2-71" data-line-number="71">    <span class="kw">let</span> scc' <span class="fu">=</span> w<span class="fu">:</span>scc</a>
<a class="sourceLine" id="cb2-72" data-line-number="72">    <span class="kw">in</span> <span class="kw">if</span> w <span class="fu">==</span> v <span class="kw">then</span> return (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc' stack stackSet</a>
<a class="sourceLine" id="cb2-73" data-line-number="73"></a>
<a class="sourceLine" id="cb2-74" data-line-number="74"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb2-75" data-line-number="75">push stack stackSet e <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-76" data-line-number="76">    modifySTRef' stack (e<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb2-77" data-line-number="77">    write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb2-78" data-line-number="78"></a>
<a class="sourceLine" id="cb2-79" data-line-number="79"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-80" data-line-number="80">pop stack stackSet <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-81" data-line-number="81">    e <span class="ot">&lt;-</span> head <span class="fu">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb2-82" data-line-number="82">    modifySTRef' stack tail</a>
<a class="sourceLine" id="cb2-83" data-line-number="83">    write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb2-84" data-line-number="84">    return e</a>
<a class="sourceLine" id="cb2-85" data-line-number="85"></a>
<a class="sourceLine" id="cb2-86" data-line-number="86">denormalise     <span class="fu">=</span> subtract</a>
<a class="sourceLine" id="cb2-87" data-line-number="87">normalise       <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb2-88" data-line-number="88">other n v       <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>n <span class="fu">-</span> v</a>
<a class="sourceLine" id="cb2-89" data-line-number="89">clauses n [u,v] <span class="fu">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb2-90" data-line-number="90"></a>
<a class="sourceLine" id="cb2-91" data-line-number="91"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-92" data-line-number="92">checkSat name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-93" data-line-number="93">    p <span class="ot">&lt;-</span> map (map P.read <span class="fu">.</span> words) <span class="fu">.</span> lines <span class="fu">&lt;$&gt;</span> readFile name</a>
<a class="sourceLine" id="cb2-94" data-line-number="94">    <span class="kw">let</span> pNo    <span class="fu">=</span> head <span class="fu">$</span> head p</a>
<a class="sourceLine" id="cb2-95" data-line-number="95">        pn     <span class="fu">=</span> map (map (normalise pNo)) <span class="fu">$</span> tail p</a>
<a class="sourceLine" id="cb2-96" data-line-number="96">        pGraph <span class="fu">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="fu">*</span>pNo) <span class="fu">$</span> concatMap (clauses pNo) pn</a>
<a class="sourceLine" id="cb2-97" data-line-number="97">    return <span class="fu">$</span> (<span class="dt">Nothing</span> <span class="fu">/=</span>) <span class="fu">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>I didn’t notice a significant difference in speed on my inputs, but it’s good to know that the algorithm has been implemented with the correct asymptotics now!</p>
<p><em>Sidenote: A <code>Vector</code> of <code>Bool</code>s can be much more compactly represented as a sequence of 0s and 1s, which are just machine words. For implementations of this in Haskell, see the <a href="https://hackage.haskell.org/package/bv">bv</a> or <a href="https://hackage.haskell.org/package/bv-little">bv-little</a> packages. Using these could be another possible refactoring.</em></p>
<p>Looking at the code again, I notice some repetition of the form</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">x <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup vectorX i</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">y <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> lookup vectorY j</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">write vectorZ k (<span class="dt">Just</span> (operation x y))</a></code></pre></div>
<p>and with the judicious use of <code>(=&lt;&lt;)</code> and <code>(&lt;*&gt;)</code> this can instead be</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">write vectorZ k <span class="fu">=&lt;&lt;</span> (operation <span class="fu">&lt;$&gt;</span> lookup vectorX i <span class="fu">&lt;*&gt;</span> lookup vectorY j)</a></code></pre></div>
<p>There are a couple of other places we could use <code>(&lt;*&gt;)</code>:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>(&lt;*&gt;)</code></summary></p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_, when)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Data.Maybe</span>          (isJust, isNothing, fromJust)</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb5-14" data-line-number="14"></a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">tarjan n graph <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    index    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">    stackSet <span class="ot">&lt;-</span> replicate size <span class="dt">False</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">    indices  <span class="ot">&lt;-</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">    lowlinks <span class="ot">&lt;-</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb5-22" data-line-number="22">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb5-23" data-line-number="23"></a>
<a class="sourceLine" id="cb5-24" data-line-number="24">    forM_ (G.vertices graph) <span class="fu">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-25" data-line-number="25">        vIndex <span class="ot">&lt;-</span> read indices v</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">        when (isNothing vIndex) <span class="fu">$</span></a>
<a class="sourceLine" id="cb5-27" data-line-number="27">            strongConnect n v graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb5-28" data-line-number="28"></a>
<a class="sourceLine" id="cb5-29" data-line-number="29">    readSTRef output</a>
<a class="sourceLine" id="cb5-30" data-line-number="30">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-31" data-line-number="31">        size <span class="fu">=</span> snd (A.bounds graph) <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-32" data-line-number="32"></a>
<a class="sourceLine" id="cb5-33" data-line-number="33">strongConnect</a>
<a class="sourceLine" id="cb5-34" data-line-number="34"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-35" data-line-number="35">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-36" data-line-number="36">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb5-37" data-line-number="37">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-38" data-line-number="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb5-39" data-line-number="39">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-40" data-line-number="40">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb5-41" data-line-number="41">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb5-42" data-line-number="42">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb5-43" data-line-number="43">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb5-44" data-line-number="44">strongConnect n v graph index stack stackSet indices lowlinks output <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-45" data-line-number="45">    i <span class="ot">&lt;-</span> readSTRef index</a>
<a class="sourceLine" id="cb5-46" data-line-number="46">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb5-47" data-line-number="47">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb5-48" data-line-number="48">    modifySTRef' index (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-49" data-line-number="49">    push stack stackSet v</a>
<a class="sourceLine" id="cb5-50" data-line-number="50"></a>
<a class="sourceLine" id="cb5-51" data-line-number="51">    forM_ (graph <span class="fu">A.!</span> v) <span class="fu">$</span> \w <span class="ot">-&gt;</span> read indices w <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb5-52" data-line-number="52">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-53" data-line-number="53">            strongConnect n w graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb5-54" data-line-number="54">            write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read lowlinks w)</a>
<a class="sourceLine" id="cb5-55" data-line-number="55">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-56" data-line-number="56">            wOnStack <span class="ot">&lt;-</span> read stackSet w</a>
<a class="sourceLine" id="cb5-57" data-line-number="57">            when wOnStack <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-58" data-line-number="58">                write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read indices w)</a>
<a class="sourceLine" id="cb5-59" data-line-number="59"></a>
<a class="sourceLine" id="cb5-60" data-line-number="60">    vLowLink <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> read lowlinks v</a>
<a class="sourceLine" id="cb5-61" data-line-number="61">    vIndex   <span class="ot">&lt;-</span> fromJust <span class="fu">&lt;$&gt;</span> read indices  v</a>
<a class="sourceLine" id="cb5-62" data-line-number="62">    when (vLowLink <span class="fu">==</span> vIndex) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-63" data-line-number="63">        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</a>
<a class="sourceLine" id="cb5-64" data-line-number="64">        modifySTRef' output <span class="fu">$</span> \sccs <span class="ot">-&gt;</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> scc <span class="fu">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb5-65" data-line-number="65"></a>
<a class="sourceLine" id="cb5-66" data-line-number="66"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb5-67" data-line-number="67">addSCC n v scc stack stackSet <span class="fu">=</span> pop stack stackSet <span class="fu">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> return <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb5-68" data-line-number="68">    <span class="kw">let</span> scc' <span class="fu">=</span> w<span class="fu">:</span>scc</a>
<a class="sourceLine" id="cb5-69" data-line-number="69">    <span class="kw">in</span> <span class="kw">if</span> w <span class="fu">==</span> v <span class="kw">then</span> return (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc' stack stackSet</a>
<a class="sourceLine" id="cb5-70" data-line-number="70"></a>
<a class="sourceLine" id="cb5-71" data-line-number="71"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb5-72" data-line-number="72">push stack stackSet e <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-73" data-line-number="73">    modifySTRef' stack (e<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb5-74" data-line-number="74">    write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb5-75" data-line-number="75"></a>
<a class="sourceLine" id="cb5-76" data-line-number="76"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-77" data-line-number="77">pop stack stackSet <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-78" data-line-number="78">    e <span class="ot">&lt;-</span> head <span class="fu">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb5-79" data-line-number="79">    modifySTRef' stack tail</a>
<a class="sourceLine" id="cb5-80" data-line-number="80">    write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb5-81" data-line-number="81">    return e</a>
<a class="sourceLine" id="cb5-82" data-line-number="82"></a>
<a class="sourceLine" id="cb5-83" data-line-number="83">denormalise     <span class="fu">=</span> subtract</a>
<a class="sourceLine" id="cb5-84" data-line-number="84">normalise       <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb5-85" data-line-number="85">other n v       <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>n <span class="fu">-</span> v</a>
<a class="sourceLine" id="cb5-86" data-line-number="86">clauses n [u,v] <span class="fu">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb5-87" data-line-number="87"></a>
<a class="sourceLine" id="cb5-88" data-line-number="88"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-89" data-line-number="89">checkSat name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-90" data-line-number="90">    p <span class="ot">&lt;-</span> map (map P.read <span class="fu">.</span> words) <span class="fu">.</span> lines <span class="fu">&lt;$&gt;</span> readFile name</a>
<a class="sourceLine" id="cb5-91" data-line-number="91">    <span class="kw">let</span> pNo    <span class="fu">=</span> head <span class="fu">$</span> head p</a>
<a class="sourceLine" id="cb5-92" data-line-number="92">        pn     <span class="fu">=</span> map (map (normalise pNo)) <span class="fu">$</span> tail p</a>
<a class="sourceLine" id="cb5-93" data-line-number="93">        pGraph <span class="fu">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="fu">*</span>pNo) <span class="fu">$</span> concatMap (clauses pNo) pn</a>
<a class="sourceLine" id="cb5-94" data-line-number="94">    return <span class="fu">$</span> (<span class="dt">Nothing</span> <span class="fu">/=</span>) <span class="fu">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>This is much nicer with the applicative combinators.</p>
<p>I would like to clean up that <code>when</code> as well, and for that I’d need a function like</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a></code></pre></div>
<p>which is <a href="hackage.haskell.org/package/extra/docs/Control-Monad-Extra.html#v:whenM">available in Neil Mitchell’s <code>extra</code> package</a>.</p>
<p>I don’t think it’s worth pulling in that dependency though, so I’ll just copy that definition:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>whenM</code></summary></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb7-13" data-line-number="13"></a>
<a class="sourceLine" id="cb7-14" data-line-number="14"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">whenM condM block <span class="fu">=</span> condM <span class="fu">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> return ()</a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">tarjan n graph <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-19" data-line-number="19">    index    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb7-21" data-line-number="21">    stackSet <span class="ot">&lt;-</span> replicate size <span class="dt">False</span></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">    indices  <span class="ot">&lt;-</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">    lowlinks <span class="ot">&lt;-</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb7-25" data-line-number="25"></a>
<a class="sourceLine" id="cb7-26" data-line-number="26">    forM_ (G.vertices graph) <span class="fu">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-27" data-line-number="27">        whenM ((<span class="fu">==</span>) <span class="dt">Nothing</span> <span class="fu">&lt;$&gt;</span> read indices v) <span class="fu">$</span></a>
<a class="sourceLine" id="cb7-28" data-line-number="28">            strongConnect n v graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb7-29" data-line-number="29"></a>
<a class="sourceLine" id="cb7-30" data-line-number="30">    readSTRef output</a>
<a class="sourceLine" id="cb7-31" data-line-number="31">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-32" data-line-number="32">        size <span class="fu">=</span> snd (A.bounds graph) <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-33" data-line-number="33"></a>
<a class="sourceLine" id="cb7-34" data-line-number="34">strongConnect</a>
<a class="sourceLine" id="cb7-35" data-line-number="35"><span class="ot">    ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-36" data-line-number="36">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-37" data-line-number="37">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb7-38" data-line-number="38">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-39" data-line-number="39">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb7-40" data-line-number="40">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-41" data-line-number="41">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-42" data-line-number="42">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb7-43" data-line-number="43">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb7-44" data-line-number="44">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb7-45" data-line-number="45">strongConnect n v graph index stack stackSet indices lowlinks output <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-46" data-line-number="46">    i <span class="ot">&lt;-</span> readSTRef index</a>
<a class="sourceLine" id="cb7-47" data-line-number="47">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb7-48" data-line-number="48">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb7-49" data-line-number="49">    modifySTRef' index (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb7-50" data-line-number="50">    push stack stackSet v</a>
<a class="sourceLine" id="cb7-51" data-line-number="51"></a>
<a class="sourceLine" id="cb7-52" data-line-number="52">    forM_ (graph <span class="fu">A.!</span> v) <span class="fu">$</span> \w <span class="ot">-&gt;</span> read indices w <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb7-53" data-line-number="53">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-54" data-line-number="54">            strongConnect n w graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb7-55" data-line-number="55">            write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read lowlinks w)</a>
<a class="sourceLine" id="cb7-56" data-line-number="56">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (read stackSet w) <span class="fu">$</span></a>
<a class="sourceLine" id="cb7-57" data-line-number="57">            write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read indices  w)</a>
<a class="sourceLine" id="cb7-58" data-line-number="58"></a>
<a class="sourceLine" id="cb7-59" data-line-number="59">    whenM ((<span class="fu">==</span>) <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read indices v) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-60" data-line-number="60">        scc <span class="ot">&lt;-</span> addSCC n v [] stack stackSet</a>
<a class="sourceLine" id="cb7-61" data-line-number="61">        modifySTRef' output <span class="fu">$</span> \sccs <span class="ot">-&gt;</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> scc <span class="fu">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb7-62" data-line-number="62"></a>
<a class="sourceLine" id="cb7-63" data-line-number="63"><span class="ot">addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb7-64" data-line-number="64">addSCC n v scc stack stackSet <span class="fu">=</span> pop stack stackSet <span class="fu">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> return <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb7-65" data-line-number="65">    <span class="kw">let</span> scc' <span class="fu">=</span> w<span class="fu">:</span>scc</a>
<a class="sourceLine" id="cb7-66" data-line-number="66">    <span class="kw">in</span> <span class="kw">if</span> w <span class="fu">==</span> v <span class="kw">then</span> return (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc' stack stackSet</a>
<a class="sourceLine" id="cb7-67" data-line-number="67"></a>
<a class="sourceLine" id="cb7-68" data-line-number="68"><span class="ot">push ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb7-69" data-line-number="69">push stack stackSet e <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-70" data-line-number="70">    modifySTRef' stack (e<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb7-71" data-line-number="71">    write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb7-72" data-line-number="72"></a>
<a class="sourceLine" id="cb7-73" data-line-number="73"><span class="ot">pop ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-74" data-line-number="74">pop stack stackSet <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-75" data-line-number="75">    e <span class="ot">&lt;-</span> head <span class="fu">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb7-76" data-line-number="76">    modifySTRef' stack tail</a>
<a class="sourceLine" id="cb7-77" data-line-number="77">    write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb7-78" data-line-number="78">    return e</a>
<a class="sourceLine" id="cb7-79" data-line-number="79"></a>
<a class="sourceLine" id="cb7-80" data-line-number="80">denormalise     <span class="fu">=</span> subtract</a>
<a class="sourceLine" id="cb7-81" data-line-number="81">normalise       <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb7-82" data-line-number="82">other n v       <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>n <span class="fu">-</span> v</a>
<a class="sourceLine" id="cb7-83" data-line-number="83">clauses n [u,v] <span class="fu">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb7-84" data-line-number="84"></a>
<a class="sourceLine" id="cb7-85" data-line-number="85"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-86" data-line-number="86">checkSat name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-87" data-line-number="87">    p <span class="ot">&lt;-</span> map (map P.read <span class="fu">.</span> words) <span class="fu">.</span> lines <span class="fu">&lt;$&gt;</span> readFile name</a>
<a class="sourceLine" id="cb7-88" data-line-number="88">    <span class="kw">let</span> pNo    <span class="fu">=</span> head <span class="fu">$</span> head p</a>
<a class="sourceLine" id="cb7-89" data-line-number="89">        pn     <span class="fu">=</span> map (map (normalise pNo)) <span class="fu">$</span> tail p</a>
<a class="sourceLine" id="cb7-90" data-line-number="90">        pGraph <span class="fu">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="fu">*</span>pNo) <span class="fu">$</span> concatMap (clauses pNo) pn</a>
<a class="sourceLine" id="cb7-91" data-line-number="91">    return <span class="fu">$</span> (<span class="dt">Nothing</span> <span class="fu">/=</span>) <span class="fu">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>Now I don’t actually even need <code>when</code> anymore!</p>
<p>Since most of the auxiliary functions aren’t used outside <code>strongConnect</code>, it might make sense to put them under a <code>where</code> clause. This would also make the parameters passed to <code>strongConnect</code> available to these functions. This is one place that the <code>ScopedTypeVariables</code> language extension is necessary, otherwise GHC can’t tell that the <code>s</code> in the type signature of <code>strongConnect</code> is the same <code>s</code> as the one in each type signature under the <code>where</code> clause.</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>where</code></summary></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb8-14" data-line-number="14"></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">whenM condM block <span class="fu">=</span> condM <span class="fu">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> return ()</a>
<a class="sourceLine" id="cb8-17" data-line-number="17"></a>
<a class="sourceLine" id="cb8-18" data-line-number="18"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">tarjan n graph <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">    index    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb8-22" data-line-number="22">    stackSet <span class="ot">&lt;-</span> replicate size <span class="dt">False</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">    indices  <span class="ot">&lt;-</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb8-24" data-line-number="24">    lowlinks <span class="ot">&lt;-</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb8-25" data-line-number="25">    output   <span class="ot">&lt;-</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb8-26" data-line-number="26"></a>
<a class="sourceLine" id="cb8-27" data-line-number="27">    forM_ (G.vertices graph) <span class="fu">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-28" data-line-number="28">        whenM ((<span class="fu">==</span>) <span class="dt">Nothing</span> <span class="fu">&lt;$&gt;</span> read indices v) <span class="fu">$</span></a>
<a class="sourceLine" id="cb8-29" data-line-number="29">            strongConnect n v graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb8-30" data-line-number="30"></a>
<a class="sourceLine" id="cb8-31" data-line-number="31">    readSTRef output</a>
<a class="sourceLine" id="cb8-32" data-line-number="32">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-33" data-line-number="33">        size <span class="fu">=</span> snd (A.bounds graph) <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-34" data-line-number="34"></a>
<a class="sourceLine" id="cb8-35" data-line-number="35">strongConnect</a>
<a class="sourceLine" id="cb8-36" data-line-number="36"><span class="ot">    ::</span> forall s</a>
<a class="sourceLine" id="cb8-37" data-line-number="37">    <span class="fu">.</span>  <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-38" data-line-number="38">    <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-39" data-line-number="39">    <span class="ot">-&gt;</span> <span class="dt">G.Graph</span></a>
<a class="sourceLine" id="cb8-40" data-line-number="40">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-41" data-line-number="41">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb8-42" data-line-number="42">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb8-43" data-line-number="43">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb8-44" data-line-number="44">    <span class="ot">-&gt;</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb8-45" data-line-number="45">    <span class="ot">-&gt;</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb8-46" data-line-number="46">    <span class="ot">-&gt;</span> <span class="dt">ST</span>    s ()</a>
<a class="sourceLine" id="cb8-47" data-line-number="47">strongConnect n v graph index stack stackSet indices lowlinks output <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-48" data-line-number="48">    i <span class="ot">&lt;-</span> readSTRef index</a>
<a class="sourceLine" id="cb8-49" data-line-number="49">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb8-50" data-line-number="50">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb8-51" data-line-number="51">    modifySTRef' index (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-52" data-line-number="52">    push v</a>
<a class="sourceLine" id="cb8-53" data-line-number="53"></a>
<a class="sourceLine" id="cb8-54" data-line-number="54">    forM_ (graph <span class="fu">A.!</span> v) <span class="fu">$</span> \w <span class="ot">-&gt;</span> read indices w <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb8-55" data-line-number="55">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-56" data-line-number="56">            strongConnect n w graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb8-57" data-line-number="57">            write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read lowlinks w)</a>
<a class="sourceLine" id="cb8-58" data-line-number="58">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (read stackSet w) <span class="fu">$</span></a>
<a class="sourceLine" id="cb8-59" data-line-number="59">            write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read indices  w)</a>
<a class="sourceLine" id="cb8-60" data-line-number="60"></a>
<a class="sourceLine" id="cb8-61" data-line-number="61">    whenM ((<span class="fu">==</span>) <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read indices v) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-62" data-line-number="62">        scc <span class="ot">&lt;-</span> addSCC n v []</a>
<a class="sourceLine" id="cb8-63" data-line-number="63">        modifySTRef' output <span class="fu">$</span> \sccs <span class="ot">-&gt;</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> scc <span class="fu">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb8-64" data-line-number="64">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-65" data-line-number="65"><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb8-66" data-line-number="66">        addSCC n v scc <span class="fu">=</span> pop <span class="fu">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> return <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb8-67" data-line-number="67">            <span class="kw">let</span> scc' <span class="fu">=</span> w<span class="fu">:</span>scc</a>
<a class="sourceLine" id="cb8-68" data-line-number="68">            <span class="kw">in</span> <span class="kw">if</span> w <span class="fu">==</span> v <span class="kw">then</span> return (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc'</a>
<a class="sourceLine" id="cb8-69" data-line-number="69"><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb8-70" data-line-number="70">        push e <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-71" data-line-number="71">            modifySTRef' stack (e<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb8-72" data-line-number="72">            write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb8-73" data-line-number="73"><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-74" data-line-number="74">        pop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-75" data-line-number="75">            e <span class="ot">&lt;-</span> head <span class="fu">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb8-76" data-line-number="76">            modifySTRef' stack tail</a>
<a class="sourceLine" id="cb8-77" data-line-number="77">            write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb8-78" data-line-number="78">            return e</a>
<a class="sourceLine" id="cb8-79" data-line-number="79"></a>
<a class="sourceLine" id="cb8-80" data-line-number="80">denormalise     <span class="fu">=</span> subtract</a>
<a class="sourceLine" id="cb8-81" data-line-number="81">normalise       <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb8-82" data-line-number="82">other n v       <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>n <span class="fu">-</span> v</a>
<a class="sourceLine" id="cb8-83" data-line-number="83">clauses n [u,v] <span class="fu">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb8-84" data-line-number="84"></a>
<a class="sourceLine" id="cb8-85" data-line-number="85"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb8-86" data-line-number="86">checkSat name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-87" data-line-number="87">    p <span class="ot">&lt;-</span> map (map P.read <span class="fu">.</span> words) <span class="fu">.</span> lines <span class="fu">&lt;$&gt;</span> readFile name</a>
<a class="sourceLine" id="cb8-88" data-line-number="88">    <span class="kw">let</span> pNo    <span class="fu">=</span> head <span class="fu">$</span> head p</a>
<a class="sourceLine" id="cb8-89" data-line-number="89">        pn     <span class="fu">=</span> map (map (normalise pNo)) <span class="fu">$</span> tail p</a>
<a class="sourceLine" id="cb8-90" data-line-number="90">        pGraph <span class="fu">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="fu">*</span>pNo) <span class="fu">$</span> concatMap (clauses pNo) pn</a>
<a class="sourceLine" id="cb8-91" data-line-number="91">    return <span class="fu">$</span> (<span class="dt">Nothing</span> <span class="fu">/=</span>) <span class="fu">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>I think the logic is clearer now that the auxiliary functions take fewer arguments.</p>
<p>Instead of a large number of implictly related variables, it might be nice to define a single product type containing our entire environment and pass just one value around. With <code>RecordWildCards</code> only minimal code changes are required:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs using <code>RecordWildCards</code></summary></p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10"></a>
<a class="sourceLine" id="cb9-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb9-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb9-15" data-line-number="15"></a>
<a class="sourceLine" id="cb9-16" data-line-number="16"><span class="kw">data</span> <span class="dt">TarjanEnv</span> s <span class="fu">=</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    {<span class="ot"> index    ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18">    ,<span class="ot"> stack    ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    ,<span class="ot"> stackSet ::</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb9-20" data-line-number="20">    ,<span class="ot"> indices  ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb9-21" data-line-number="21">    ,<span class="ot"> lowlinks ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">    ,<span class="ot"> output   ::</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb9-23" data-line-number="23">    }</a>
<a class="sourceLine" id="cb9-24" data-line-number="24"></a>
<a class="sourceLine" id="cb9-25" data-line-number="25"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb9-26" data-line-number="26">whenM condM block <span class="fu">=</span> condM <span class="fu">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> return ()</a>
<a class="sourceLine" id="cb9-27" data-line-number="27"></a>
<a class="sourceLine" id="cb9-28" data-line-number="28"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb9-29" data-line-number="29">tarjan n graph <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-30" data-line-number="30">    tarjanEnv <span class="ot">&lt;-</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb9-31" data-line-number="31">        <span class="fu">&lt;$&gt;</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb9-32" data-line-number="32">        <span class="fu">&lt;*&gt;</span> newSTRef []</a>
<a class="sourceLine" id="cb9-33" data-line-number="33">        <span class="fu">&lt;*&gt;</span> replicate size <span class="dt">False</span></a>
<a class="sourceLine" id="cb9-34" data-line-number="34">        <span class="fu">&lt;*&gt;</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-35" data-line-number="35">        <span class="fu">&lt;*&gt;</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-36" data-line-number="36">        <span class="fu">&lt;*&gt;</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb9-37" data-line-number="37"></a>
<a class="sourceLine" id="cb9-38" data-line-number="38">    forM_ (G.vertices graph) <span class="fu">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-39" data-line-number="39">        whenM ((<span class="fu">==</span>) <span class="dt">Nothing</span> <span class="fu">&lt;$&gt;</span> read (indices tarjanEnv) v) <span class="fu">$</span></a>
<a class="sourceLine" id="cb9-40" data-line-number="40">            strongConnect n v graph tarjanEnv</a>
<a class="sourceLine" id="cb9-41" data-line-number="41"></a>
<a class="sourceLine" id="cb9-42" data-line-number="42">    readSTRef (output tarjanEnv)</a>
<a class="sourceLine" id="cb9-43" data-line-number="43">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-44" data-line-number="44">        size <span class="fu">=</span> snd (A.bounds graph) <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb9-45" data-line-number="45"></a>
<a class="sourceLine" id="cb9-46" data-line-number="46"><span class="ot">strongConnect ::</span> forall s<span class="fu">.</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">TarjanEnv</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb9-47" data-line-number="47">strongConnect n v graph <span class="dt">TarjanEnv</span>{<span class="fu">..</span>} <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-48" data-line-number="48">    i <span class="ot">&lt;-</span> readSTRef index</a>
<a class="sourceLine" id="cb9-49" data-line-number="49">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb9-50" data-line-number="50">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb9-51" data-line-number="51">    modifySTRef' index (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb9-52" data-line-number="52">    push v</a>
<a class="sourceLine" id="cb9-53" data-line-number="53"></a>
<a class="sourceLine" id="cb9-54" data-line-number="54">    forM_ (graph <span class="fu">A.!</span> v) <span class="fu">$</span> \w <span class="ot">-&gt;</span> read indices w <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb9-55" data-line-number="55">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-56" data-line-number="56">            strongConnect n w graph <span class="dt">TarjanEnv</span>{<span class="fu">..</span>}</a>
<a class="sourceLine" id="cb9-57" data-line-number="57">            write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read lowlinks w)</a>
<a class="sourceLine" id="cb9-58" data-line-number="58">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (read stackSet w) <span class="fu">$</span></a>
<a class="sourceLine" id="cb9-59" data-line-number="59">            write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read indices  w)</a>
<a class="sourceLine" id="cb9-60" data-line-number="60"></a>
<a class="sourceLine" id="cb9-61" data-line-number="61">    whenM ((<span class="fu">==</span>) <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read indices v) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-62" data-line-number="62">        scc <span class="ot">&lt;-</span> addSCC n v []</a>
<a class="sourceLine" id="cb9-63" data-line-number="63">        modifySTRef' output <span class="fu">$</span> \sccs <span class="ot">-&gt;</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> scc <span class="fu">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb9-64" data-line-number="64">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-65" data-line-number="65"><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb9-66" data-line-number="66">        addSCC n v scc <span class="fu">=</span> pop <span class="fu">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc) <span class="kw">then</span> return <span class="dt">Nothing</span> <span class="kw">else</span></a>
<a class="sourceLine" id="cb9-67" data-line-number="67">            <span class="kw">let</span> scc' <span class="fu">=</span> w<span class="fu">:</span>scc</a>
<a class="sourceLine" id="cb9-68" data-line-number="68">            <span class="kw">in</span> <span class="kw">if</span> w <span class="fu">==</span> v <span class="kw">then</span> return (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc'</a>
<a class="sourceLine" id="cb9-69" data-line-number="69"><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb9-70" data-line-number="70">        push e <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-71" data-line-number="71">            modifySTRef' stack (e<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb9-72" data-line-number="72">            write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb9-73" data-line-number="73"><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-74" data-line-number="74">        pop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-75" data-line-number="75">            e <span class="ot">&lt;-</span> head <span class="fu">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb9-76" data-line-number="76">            modifySTRef' stack tail</a>
<a class="sourceLine" id="cb9-77" data-line-number="77">            write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb9-78" data-line-number="78">            return e</a>
<a class="sourceLine" id="cb9-79" data-line-number="79"></a>
<a class="sourceLine" id="cb9-80" data-line-number="80">denormalise     <span class="fu">=</span> subtract</a>
<a class="sourceLine" id="cb9-81" data-line-number="81">normalise       <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb9-82" data-line-number="82">other n v       <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>n <span class="fu">-</span> v</a>
<a class="sourceLine" id="cb9-83" data-line-number="83">clauses n [u,v] <span class="fu">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb9-84" data-line-number="84"></a>
<a class="sourceLine" id="cb9-85" data-line-number="85"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb9-86" data-line-number="86">checkSat name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-87" data-line-number="87">    p <span class="ot">&lt;-</span> map (map P.read <span class="fu">.</span> words) <span class="fu">.</span> lines <span class="fu">&lt;$&gt;</span> readFile name</a>
<a class="sourceLine" id="cb9-88" data-line-number="88">    <span class="kw">let</span> pNo    <span class="fu">=</span> head <span class="fu">$</span> head p</a>
<a class="sourceLine" id="cb9-89" data-line-number="89">        pn     <span class="fu">=</span> map (map (normalise pNo)) <span class="fu">$</span> tail p</a>
<a class="sourceLine" id="cb9-90" data-line-number="90">        pGraph <span class="fu">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="fu">*</span>pNo) <span class="fu">$</span> concatMap (clauses pNo) pn</a>
<a class="sourceLine" id="cb9-91" data-line-number="91">    return <span class="fu">$</span> (<span class="dt">Nothing</span> <span class="fu">/=</span>) <span class="fu">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>Let’s pause here. Although more refactoring is certainly possible, my last two steps did not reduce the line count and may have in fact made the code harder to understand.</p>
<p>How have we benefited from this refactoring? Aside from the code being shorter and better structured, it’s now easier to make meaningful improvements. For example, this implementation is more inefficient than it needs to be, because it doesn’t short-circuit when it finds that the current problem is unsatisfiable. Instead it works through the rest of the problem, only to throw all that work away. A sophisticated solution to this problem might involve the use of the <a href="https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-Except.html"><code>ExceptT</code></a> monad transformer to throw an exception and exit early, but there is a simpler approach: we can store an extra boolean variable denoting whether or not the current problem is possibly satisfiable, and only continue working if it is. I’ll call this variable <code>possible</code>, update it in <code>addSCC</code>, and check for it before each call to <code>strongConnect</code> in <code>tarjan</code>. It takes more effort to reformat the code than to make this change:</p>
<details>
<p><summary style="cursor: pointer">2SAT.hs with short-circuiting</summary></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">{-# LANGUAGE LambdaCase #-}</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span>    <span class="kw">as</span> <span class="dt">P</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup, read, replicate)</a>
<a class="sourceLine" id="cb10-10" data-line-number="10"></a>
<a class="sourceLine" id="cb10-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_)</a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb10-15" data-line-number="15"></a>
<a class="sourceLine" id="cb10-16" data-line-number="16"><span class="kw">data</span> <span class="dt">TarjanEnv</span> s <span class="fu">=</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17">    {<span class="ot"> index    ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18">    ,<span class="ot"> stack    ::</span> <span class="dt">STRef</span> s [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">    ,<span class="ot"> stackSet ::</span> <span class="dt">STVector</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">    ,<span class="ot"> indices  ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">    ,<span class="ot"> lowlinks ::</span> <span class="dt">STVector</span> s (<span class="dt">Maybe</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    ,<span class="ot"> output   ::</span> <span class="dt">STRef</span> s (<span class="dt">Maybe</span> [[<span class="dt">Int</span>]])</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">    ,<span class="ot"> possible ::</span> <span class="dt">STRef</span> s <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-24" data-line-number="24">    }</a>
<a class="sourceLine" id="cb10-25" data-line-number="25"></a>
<a class="sourceLine" id="cb10-26" data-line-number="26"><span class="ot">whenM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m <span class="dt">Bool</span> <span class="ot">-&gt;</span> m () <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb10-27" data-line-number="27">whenM condM block <span class="fu">=</span> condM <span class="fu">&gt;&gt;=</span> \cond <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> block <span class="kw">else</span> return ()</a>
<a class="sourceLine" id="cb10-28" data-line-number="28"></a>
<a class="sourceLine" id="cb10-29" data-line-number="29"><span class="ot">tarjan ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Int</span>]]</a>
<a class="sourceLine" id="cb10-30" data-line-number="30">tarjan n graph <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-31" data-line-number="31">    tarjanEnv <span class="ot">&lt;-</span> <span class="dt">TarjanEnv</span></a>
<a class="sourceLine" id="cb10-32" data-line-number="32">        <span class="fu">&lt;$&gt;</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb10-33" data-line-number="33">        <span class="fu">&lt;*&gt;</span> newSTRef []</a>
<a class="sourceLine" id="cb10-34" data-line-number="34">        <span class="fu">&lt;*&gt;</span> replicate size <span class="dt">False</span></a>
<a class="sourceLine" id="cb10-35" data-line-number="35">        <span class="fu">&lt;*&gt;</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-36" data-line-number="36">        <span class="fu">&lt;*&gt;</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-37" data-line-number="37">        <span class="fu">&lt;*&gt;</span> newSTRef (<span class="dt">Just</span> [])</a>
<a class="sourceLine" id="cb10-38" data-line-number="38">        <span class="fu">&lt;*&gt;</span> newSTRef <span class="dt">True</span></a>
<a class="sourceLine" id="cb10-39" data-line-number="39"></a>
<a class="sourceLine" id="cb10-40" data-line-number="40">    forM_ (G.vertices graph) <span class="fu">$</span> \v <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-41" data-line-number="41">        whenM ((<span class="fu">&amp;&amp;</span>)</a>
<a class="sourceLine" id="cb10-42" data-line-number="42">            <span class="fu">&lt;$&gt;</span> ((<span class="fu">==</span>) <span class="dt">Nothing</span> <span class="fu">&lt;$&gt;</span> read (indices tarjanEnv) v)</a>
<a class="sourceLine" id="cb10-43" data-line-number="43">            <span class="fu">&lt;*&gt;</span> readSTRef (possible tarjanEnv)) <span class="fu">$</span></a>
<a class="sourceLine" id="cb10-44" data-line-number="44">                strongConnect n v graph tarjanEnv</a>
<a class="sourceLine" id="cb10-45" data-line-number="45"></a>
<a class="sourceLine" id="cb10-46" data-line-number="46">    readSTRef (output tarjanEnv)</a>
<a class="sourceLine" id="cb10-47" data-line-number="47">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-48" data-line-number="48">        size <span class="fu">=</span> snd (A.bounds graph) <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb10-49" data-line-number="49"></a>
<a class="sourceLine" id="cb10-50" data-line-number="50"><span class="ot">strongConnect ::</span> forall s<span class="fu">.</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">G.Graph</span> <span class="ot">-&gt;</span> <span class="dt">TarjanEnv</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb10-51" data-line-number="51">strongConnect n v graph <span class="dt">TarjanEnv</span>{<span class="fu">..</span>} <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-52" data-line-number="52">    i <span class="ot">&lt;-</span> readSTRef index</a>
<a class="sourceLine" id="cb10-53" data-line-number="53">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb10-54" data-line-number="54">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb10-55" data-line-number="55">    modifySTRef' index (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-56" data-line-number="56">    push v</a>
<a class="sourceLine" id="cb10-57" data-line-number="57"></a>
<a class="sourceLine" id="cb10-58" data-line-number="58">    forM_ (graph <span class="fu">A.!</span> v) <span class="fu">$</span> \w <span class="ot">-&gt;</span> read indices w <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb10-59" data-line-number="59">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-60" data-line-number="60">            strongConnect n w graph <span class="dt">TarjanEnv</span>{<span class="fu">..</span>}</a>
<a class="sourceLine" id="cb10-61" data-line-number="61">            write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read lowlinks w)</a>
<a class="sourceLine" id="cb10-62" data-line-number="62">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> whenM (read stackSet w) <span class="fu">$</span></a>
<a class="sourceLine" id="cb10-63" data-line-number="63">            write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read indices  w)</a>
<a class="sourceLine" id="cb10-64" data-line-number="64"></a>
<a class="sourceLine" id="cb10-65" data-line-number="65">    whenM ((<span class="fu">==</span>) <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read indices v) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-66" data-line-number="66">        scc <span class="ot">&lt;-</span> addSCC n v []</a>
<a class="sourceLine" id="cb10-67" data-line-number="67">        modifySTRef' output <span class="fu">$</span> \sccs <span class="ot">-&gt;</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> scc <span class="fu">&lt;*&gt;</span> sccs</a>
<a class="sourceLine" id="cb10-68" data-line-number="68">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-69" data-line-number="69"><span class="ot">        addSCC ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> [<span class="dt">Int</span>])</a>
<a class="sourceLine" id="cb10-70" data-line-number="70">        addSCC n v scc <span class="fu">=</span> pop <span class="fu">&gt;&gt;=</span> \w <span class="ot">-&gt;</span> <span class="kw">if</span> ((other n w) <span class="ot">`elem`</span> scc)</a>
<a class="sourceLine" id="cb10-71" data-line-number="71">            <span class="kw">then</span> writeSTRef possible <span class="dt">False</span> <span class="fu">&gt;&gt;</span> return <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb10-72" data-line-number="72">            <span class="kw">else</span></a>
<a class="sourceLine" id="cb10-73" data-line-number="73">                <span class="kw">let</span> scc' <span class="fu">=</span> w<span class="fu">:</span>scc</a>
<a class="sourceLine" id="cb10-74" data-line-number="74">                <span class="kw">in</span> <span class="kw">if</span> w <span class="fu">==</span> v <span class="kw">then</span> return (<span class="dt">Just</span> scc') <span class="kw">else</span> addSCC n v scc'</a>
<a class="sourceLine" id="cb10-75" data-line-number="75"><span class="ot">        push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb10-76" data-line-number="76">        push e <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-77" data-line-number="77">            modifySTRef' stack (e<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb10-78" data-line-number="78">            write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb10-79" data-line-number="79"><span class="ot">        pop ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-80" data-line-number="80">        pop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-81" data-line-number="81">            e <span class="ot">&lt;-</span> head <span class="fu">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb10-82" data-line-number="82">            modifySTRef' stack tail</a>
<a class="sourceLine" id="cb10-83" data-line-number="83">            write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb10-84" data-line-number="84">            return e</a>
<a class="sourceLine" id="cb10-85" data-line-number="85"></a>
<a class="sourceLine" id="cb10-86" data-line-number="86">denormalise     <span class="fu">=</span> subtract</a>
<a class="sourceLine" id="cb10-87" data-line-number="87">normalise       <span class="fu">=</span> (<span class="fu">+</span>)</a>
<a class="sourceLine" id="cb10-88" data-line-number="88">other n v       <span class="fu">=</span> <span class="dv">2</span><span class="fu">*</span>n <span class="fu">-</span> v</a>
<a class="sourceLine" id="cb10-89" data-line-number="89">clauses n [u,v] <span class="fu">=</span> [(other n u, v), (other n v, u)]</a>
<a class="sourceLine" id="cb10-90" data-line-number="90"></a>
<a class="sourceLine" id="cb10-91" data-line-number="91"><span class="ot">checkSat ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb10-92" data-line-number="92">checkSat name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-93" data-line-number="93">    p <span class="ot">&lt;-</span> map (map P.read <span class="fu">.</span> words) <span class="fu">.</span> lines <span class="fu">&lt;$&gt;</span> readFile name</a>
<a class="sourceLine" id="cb10-94" data-line-number="94">    <span class="kw">let</span> pNo    <span class="fu">=</span> head <span class="fu">$</span> head p</a>
<a class="sourceLine" id="cb10-95" data-line-number="95">        pn     <span class="fu">=</span> map (map (normalise pNo)) <span class="fu">$</span> tail p</a>
<a class="sourceLine" id="cb10-96" data-line-number="96">        pGraph <span class="fu">=</span> G.buildG (<span class="dv">0</span>,<span class="dv">2</span><span class="fu">*</span>pNo) <span class="fu">$</span> concatMap (clauses pNo) pn</a>
<a class="sourceLine" id="cb10-97" data-line-number="97">    return <span class="fu">$</span> (<span class="dt">Nothing</span> <span class="fu">/=</span>) <span class="fu">$</span> tarjan pNo pGraph</a></code></pre></div>
</details>
<p>This change does seem to make a significant difference, and it’s good to know we’re not doing useless work.</p>
<p>I think this is a good place to stop, and I hope I’ve been able to demonstrate some of Haskell’s strengths when it comes to refactoring. In my experience, it’s not usually necessary to deeply understand Haskell code in order to attempt a refactoring, especially if it’s backed by well-chosen types and a good test suite. I also find that I’m able to be more daring when writing new code, because bad up-front design is less costly and even the jankiest working code can be gently massaged into something presentable.</p>
<p><em>Thanks to <a href="https://joelburget.com/">Joel Burget</a>, <a href="http://www.matfournier.com/">Mat Fournier</a>, <a href="https://eskimor.gonimo.com/">Robert Klotzner</a>, <a href="https://github.com/L8D">Tenor</a>, <a href="http://www.tomharding.me/">Tom Harding</a>, and <a href="http://www.tylerweir.com/">Tyler Weir</a> for suggestions and feedback.</em></p>

        </div>
        <div id="footer">
            <div class="rc-scout">
                <script async defer src="https://www.recurse-scout.com/loader.js?t=5ac465e5d3396a7e491e42afac4c5c90"></script>
            </div>
        </div>
    </body>
</html>
