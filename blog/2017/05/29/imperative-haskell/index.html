<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Imperative Haskell - Vaibhav Sagar</title>
        <link rel="stylesheet" type="text/css" href="../../../../../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../../../../../css/syntax.css" />
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-79891461-1', 'auto');
          ga('send', 'pageview');

        </script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../../../../">Vaibhav Sagar</a>
            </div>
            <div id="navigation">
                <a href="../../../../../about/">About</a>
                <a href="../../../../../talks/">Talks</a>
                <a href="../../../../../archive/">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Imperative Haskell</h1>

            <div class="info">
    Posted on 29 May 2017
    
</div>
<div class="info">
    
        Tags: <a href="../../../../../blog/tags/haskell/">haskell</a>, <a href="../../../../../blog/tags/programming/">programming</a>
    
</div>

<p><em><a href="http://getcolorings.com/">Get Colorings</a> has kindly <a href="http://getcolorings.com/ru-imperative-haskell">translated this post</a> to Russian.</em></p>
<p><em>This post covers essentially the same material as a 5-minute presentation I gave at <a href="https://www.recurse.com/scout/click?t=5ac465e5d3396a7e491e42afac4c5c90">RC</a>, because giving that talk over and over again doesn’t scale and there are things I would like to cover that are difficult within that time limit.</em></p>
<p>I was working through Tim Roughgarden’s <a href="https://www.coursera.org/learn/algorithm-design-analysis/">Algorithms 1</a> (which has now been replaced by two smaller courses) and attempting to do all the exercises in Haskell when I bumped up against an uncomfortable truth. Haskell’s ‘quicksort’:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">qsort []     <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">qsort (x<span class="fu">:</span>xs) <span class="fu">=</span> lt <span class="fu">++</span> [x] <span class="fu">++</span> gt</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="kw">where</span> lt <span class="fu">=</span> qsort [e <span class="fu">|</span> e <span class="ot">&lt;-</span> xs, e <span class="fu">&lt;</span>  x]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">          gt <span class="fu">=</span> qsort [e <span class="fu">|</span> e <span class="ot">&lt;-</span> xs, e <span class="fu">&gt;=</span> x]</a></code></pre></div>
<p>isn’t a true quicksort! Specifically, it doesn’t sort the elements in place, and the assignment I was working on involved counting the number of comparisons, so I couldn’t get away with my fake quicksort. With my tail between my legs, I gave up on my pure Haskell approach and implemented a solution in Python:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="im">import</span> sys</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">sys.setrecursionlimit(<span class="dv">10000</span>)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">def</span> partition_first(array, l, r):</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    p <span class="op">=</span> array[l]</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    i <span class="op">=</span> l <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(l<span class="op">+</span><span class="dv">1</span>, r):</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        <span class="cf">if</span> array[j] <span class="op">&lt;</span> p:</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">            array[j], array[i] <span class="op">=</span> array[i], array[j]</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">            i <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    array[l], array[i<span class="dv">-1</span>] <span class="op">=</span> array[i<span class="dv">-1</span>], array[l]</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="cf">return</span> (i<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb2-13" data-line-number="13"></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="kw">def</span> partition_last(array, l, r):</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">    array[r<span class="dv">-1</span>], array[l] <span class="op">=</span> array[l], array[r<span class="dv">-1</span>]</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">    <span class="cf">return</span> partition_first(array, l, r)</a>
<a class="sourceLine" id="cb2-17" data-line-number="17"></a>
<a class="sourceLine" id="cb2-18" data-line-number="18"><span class="kw">def</span> partition_median(array, l, r):</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">    p_idx <span class="op">=</span> choose_median(array, l, r)</a>
<a class="sourceLine" id="cb2-20" data-line-number="20">    array[p_idx], array[l] <span class="op">=</span> array[l], array[p_idx]</a>
<a class="sourceLine" id="cb2-21" data-line-number="21">    <span class="cf">return</span> partition_first(array, l, r)</a>
<a class="sourceLine" id="cb2-22" data-line-number="22"></a>
<a class="sourceLine" id="cb2-23" data-line-number="23"><span class="kw">def</span> choose_median(array, l, r):</a>
<a class="sourceLine" id="cb2-24" data-line-number="24">    head <span class="op">=</span> array[l]</a>
<a class="sourceLine" id="cb2-25" data-line-number="25">    last <span class="op">=</span> array[r<span class="dv">-1</span>]</a>
<a class="sourceLine" id="cb2-26" data-line-number="26">    length <span class="op">=</span> r<span class="op">-</span>l</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">    <span class="cf">if</span> length <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb2-28" data-line-number="28">        mid_idx <span class="op">=</span> l <span class="op">+</span> (length<span class="op">//</span><span class="dv">2</span>) <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-29" data-line-number="29">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb2-30" data-line-number="30">        mid_idx <span class="op">=</span> l <span class="op">+</span> (length<span class="op">//</span><span class="dv">2</span>)</a>
<a class="sourceLine" id="cb2-31" data-line-number="31">    mid <span class="op">=</span> array[mid_idx]</a>
<a class="sourceLine" id="cb2-32" data-line-number="32">    options <span class="op">=</span> [(l, head), (mid_idx, mid), (r<span class="dv">-1</span>, last)]</a>
<a class="sourceLine" id="cb2-33" data-line-number="33">    options.remove(<span class="bu">max</span>(options, key<span class="op">=</span><span class="kw">lambda</span> v: v[<span class="dv">1</span>]))</a>
<a class="sourceLine" id="cb2-34" data-line-number="34">    options.remove(<span class="bu">min</span>(options, key<span class="op">=</span><span class="kw">lambda</span> v: v[<span class="dv">1</span>]))</a>
<a class="sourceLine" id="cb2-35" data-line-number="35">    <span class="cf">return</span> options[<span class="dv">0</span>][<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb2-36" data-line-number="36"></a>
<a class="sourceLine" id="cb2-37" data-line-number="37"><span class="kw">def</span> quicksort(array, start, end, partition):</a>
<a class="sourceLine" id="cb2-38" data-line-number="38">    <span class="kw">global</span> comparisons</a>
<a class="sourceLine" id="cb2-39" data-line-number="39">    <span class="cf">if</span> end<span class="op">&lt;=</span>start: <span class="cf">return</span></a>
<a class="sourceLine" id="cb2-40" data-line-number="40">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb2-41" data-line-number="41">        p_idx <span class="op">=</span> partition(array, start, end)</a>
<a class="sourceLine" id="cb2-42" data-line-number="42">        comparisons <span class="op">+=</span> (end<span class="op">-</span>start<span class="dv">-1</span>)</a>
<a class="sourceLine" id="cb2-43" data-line-number="43">        quicksort(array, start, p_idx, partition)</a>
<a class="sourceLine" id="cb2-44" data-line-number="44">        quicksort(array, p_idx<span class="op">+</span><span class="dv">1</span>, end, partition)</a>
<a class="sourceLine" id="cb2-45" data-line-number="45"></a>
<a class="sourceLine" id="cb2-46" data-line-number="46"></a>
<a class="sourceLine" id="cb2-47" data-line-number="47">comparisons <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-48" data-line-number="48">inp1 <span class="op">=</span> contents.copy()</a>
<a class="sourceLine" id="cb2-49" data-line-number="49">quicksort(inp1, <span class="dv">0</span>, <span class="bu">len</span>(inp1), partition_first)</a>
<a class="sourceLine" id="cb2-50" data-line-number="50"><span class="bu">print</span>(comparisons)</a>
<a class="sourceLine" id="cb2-51" data-line-number="51"></a>
<a class="sourceLine" id="cb2-52" data-line-number="52">comparisons <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-53" data-line-number="53">inp2 <span class="op">=</span> contents.copy()</a>
<a class="sourceLine" id="cb2-54" data-line-number="54">quicksort(inp2, <span class="dv">0</span>, <span class="bu">len</span>(inp2), partition_last)</a>
<a class="sourceLine" id="cb2-55" data-line-number="55"><span class="bu">print</span>(comparisons)</a>
<a class="sourceLine" id="cb2-56" data-line-number="56"></a>
<a class="sourceLine" id="cb2-57" data-line-number="57">comparisons <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-58" data-line-number="58">inp3 <span class="op">=</span> contents.copy()</a>
<a class="sourceLine" id="cb2-59" data-line-number="59">quicksort(inp3, <span class="dv">0</span>, <span class="bu">len</span>(inp3), partition_median)</a>
<a class="sourceLine" id="cb2-60" data-line-number="60"><span class="bu">print</span>(comparisons)</a></code></pre></div>
<p>This implementation is not particularly Pythonic: note the recursion limit and the use of a global variable. I actually forgot to reset the variable to 0 between iterations, which was fun to track down. But it works!</p>
<p>So far, so good. This isn’t something we’d be able to do in Haskell, right? And even if we could, the equivalent implementation would be so different as to be unrecognisable. At least this is what I thought until I took a closer look at <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Control-Monad-ST.html">Control.Monad.ST</a> and <a href="https://hackage.haskell.org/package/base-4.9.1.0/docs/Data-STRef.html">Data.STRef</a>.</p>
<p>One of my biggest gripes with Haskell is the quality of the documentation. <code>Control.Monad.ST</code> is introduced as</p>
<blockquote>
<p>This library provides support for strict state threads, as described in the PLDI ’94 paper by John Launchbury and Simon Peyton Jones <em>Lazy Functional State Threads</em>.</p>
</blockquote>
<p>and <code>Data.STRef</code> is introduced as</p>
<blockquote>
<p>Mutable references in the (strict) ST monad.</p>
</blockquote>
<p>I don’t want to read a paper to figure out how to use these libraries, and in fact I don’t have to! In recognition of this, I humbly present alternative descriptions for <code>Control.Monad.ST</code>:</p>
<blockquote>
<p>You asked for mutable state, here it is!</p>
</blockquote>
<p>and <code>Data.STRef</code>:</p>
<blockquote>
<p>Variables that you can actually vary!!!1!1!one!1eleventyone</p>
</blockquote>
<p>Code utilising these libraries can look very familiar to people used to imperative languages, e.g. past me. Here’s the above quicksort rewritten in Haskell:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">{-# LANGUAGE RankNTypes #-}</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Data.Vector</span> (fromList, toList, freeze, thaw)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, write, swap)</a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span> (<span class="dt">Vector</span>, length)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.List</span> (sortOn)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (read)</a>
<a class="sourceLine" id="cb3-11" data-line-number="11"></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">vector <span class="fu">=</span> fromList contents</a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">partitionFirst array l r <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    p <span class="ot">&lt;-</span> read array l</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    i <span class="ot">&lt;-</span> newSTRef (l<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">    forM_ [l<span class="fu">+</span><span class="dv">1</span><span class="fu">..</span>(r<span class="fu">-</span><span class="dv">1</span>)] <span class="fu">$</span> \j <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">        arrayJ <span class="ot">&lt;-</span> read array j</a>
<a class="sourceLine" id="cb3-19" data-line-number="19">        i'     <span class="ot">&lt;-</span> readSTRef i</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">        when (arrayJ <span class="fu">&lt;</span> p) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-21" data-line-number="21">            swap array i' j</a>
<a class="sourceLine" id="cb3-22" data-line-number="22">            modifySTRef' i (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-23" data-line-number="23">    i' <span class="ot">&lt;-</span> readSTRef i</a>
<a class="sourceLine" id="cb3-24" data-line-number="24">    swap array (i'<span class="fu">-</span><span class="dv">1</span>) l</a>
<a class="sourceLine" id="cb3-25" data-line-number="25">    return (i'<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-26" data-line-number="26"></a>
<a class="sourceLine" id="cb3-27" data-line-number="27">partitionLast array l r <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-28" data-line-number="28">    swap array (r<span class="fu">-</span><span class="dv">1</span>) l</a>
<a class="sourceLine" id="cb3-29" data-line-number="29">    partitionFirst array l r</a>
<a class="sourceLine" id="cb3-30" data-line-number="30"></a>
<a class="sourceLine" id="cb3-31" data-line-number="31">partitionMedian array l r <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-32" data-line-number="32">    p <span class="ot">&lt;-</span> chooseMedian array l r</a>
<a class="sourceLine" id="cb3-33" data-line-number="33">    swap array p l</a>
<a class="sourceLine" id="cb3-34" data-line-number="34">    partitionFirst array l r</a>
<a class="sourceLine" id="cb3-35" data-line-number="35"></a>
<a class="sourceLine" id="cb3-36" data-line-number="36">chooseMedian array l r <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-37" data-line-number="37">    h <span class="ot">&lt;-</span> read array l</a>
<a class="sourceLine" id="cb3-38" data-line-number="38">    t <span class="ot">&lt;-</span> read array (r<span class="fu">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-39" data-line-number="39">    <span class="kw">let</span> len <span class="fu">=</span> r<span class="fu">-</span>l</a>
<a class="sourceLine" id="cb3-40" data-line-number="40">    <span class="kw">let</span> mid <span class="fu">=</span> <span class="kw">if</span> (len <span class="ot">`mod`</span> <span class="dv">2</span>) <span class="fu">==</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-41" data-line-number="41">        <span class="kw">then</span> l <span class="fu">+</span> (len <span class="ot">`div`</span> <span class="dv">2</span>) <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-42" data-line-number="42">        <span class="kw">else</span> l <span class="fu">+</span> (len <span class="ot">`div`</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb3-43" data-line-number="43">    m <span class="ot">&lt;-</span> read array mid</a>
<a class="sourceLine" id="cb3-44" data-line-number="44">    <span class="kw">let</span> options <span class="fu">=</span> sortOn snd [(l, h), (mid, m), (r<span class="fu">-</span><span class="dv">1</span>, t)]</a>
<a class="sourceLine" id="cb3-45" data-line-number="45">    return (fst (options <span class="fu">!!</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb3-46" data-line-number="46"></a>
<a class="sourceLine" id="cb3-47" data-line-number="47">quicksort array start end partition comparisons <span class="fu">=</span> when (start <span class="fu">&lt;</span> end) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-48" data-line-number="48">    i <span class="ot">&lt;-</span> partition array start end</a>
<a class="sourceLine" id="cb3-49" data-line-number="49">    modifySTRef' comparisons (<span class="fu">+</span> (end<span class="fu">-</span>start<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb3-50" data-line-number="50">    quicksort array start i   partition comparisons</a>
<a class="sourceLine" id="cb3-51" data-line-number="51">    quicksort array (i<span class="fu">+</span><span class="dv">1</span>) end partition comparisons</a>
<a class="sourceLine" id="cb3-52" data-line-number="52"></a>
<a class="sourceLine" id="cb3-53" data-line-number="53"><span class="ot">quicksort' ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> a <span class="ot">-&gt;</span> (forall s a<span class="fu">.</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">STVector</span> s a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-54" data-line-number="54">quicksort' vector partition <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-55" data-line-number="55">    array  <span class="ot">&lt;-</span> thaw vector</a>
<a class="sourceLine" id="cb3-56" data-line-number="56">    comps  <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-57" data-line-number="57">    quicksort array <span class="dv">0</span> (V.length vector) partition comps</a>
<a class="sourceLine" id="cb3-58" data-line-number="58">    readSTRef comps</a>
<a class="sourceLine" id="cb3-59" data-line-number="59"></a>
<a class="sourceLine" id="cb3-60" data-line-number="60">quicksort' vector partitionFirst</a>
<a class="sourceLine" id="cb3-61" data-line-number="61">quicksort' vector partitionLast</a>
<a class="sourceLine" id="cb3-62" data-line-number="62">quicksort' vector partitionMedian</a></code></pre></div>
<p>This is roughly the same length as the Python implementation, and even improves on it in some ways: no recursion limit fiddling and no global variables.</p>
<p>If we can write Haskell that resembles Python, and Python is executable pseudocode, can we cut out the middleman and translate pseudocode directly to Haskell? Let’s take a look at another problem.</p>
<p>I needed to calculate the size of the strongly connected components of a graph for another assignment, and I decided to use Tarjan’s Strongly Connected Components algorithm. The pseudocode for that (as taken from Wikipedia) is:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode noweb"><code class="sourceCode noweb"><a class="sourceLine" id="cb4-1" data-line-number="1"> algorithm tarjan is</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  input: graph G = (V, E)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  output: set of strongly connected components (sets of vertices)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  index := 0</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  S := empty array</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  for each v in V do</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    if (v.index is undefined) then</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">      strongconnect(v)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    end if</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  end for</a>
<a class="sourceLine" id="cb4-12" data-line-number="12"></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  function strongconnect(v)</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">    // Set the depth index for v to the smallest unused index</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">    v.index := index</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">    v.lowlink := index</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">    index := index + 1</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">    S.push(v)</a>
<a class="sourceLine" id="cb4-19" data-line-number="19">    v.onStack := true</a>
<a class="sourceLine" id="cb4-20" data-line-number="20"></a>
<a class="sourceLine" id="cb4-21" data-line-number="21">    // Consider successors of v</a>
<a class="sourceLine" id="cb4-22" data-line-number="22">    for each (v, w) in E do</a>
<a class="sourceLine" id="cb4-23" data-line-number="23">      if (w.index is undefined) then</a>
<a class="sourceLine" id="cb4-24" data-line-number="24">        // Successor w has not yet been visited; recurse on it</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">        strongconnect(w)</a>
<a class="sourceLine" id="cb4-26" data-line-number="26">        v.lowlink  := min(v.lowlink, w.lowlink)</a>
<a class="sourceLine" id="cb4-27" data-line-number="27">      else if (w.onStack) then</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">        // Successor w is in stack S and hence in the current SCC</a>
<a class="sourceLine" id="cb4-29" data-line-number="29">        // Note: The next line may look odd - but is correct.</a>
<a class="sourceLine" id="cb4-30" data-line-number="30">        // It says w.index not w.lowlink; that is deliberate and from the original paper</a>
<a class="sourceLine" id="cb4-31" data-line-number="31">        v.lowlink  := min(v.lowlink, w.index)</a>
<a class="sourceLine" id="cb4-32" data-line-number="32">      end if</a>
<a class="sourceLine" id="cb4-33" data-line-number="33">    end for</a>
<a class="sourceLine" id="cb4-34" data-line-number="34"></a>
<a class="sourceLine" id="cb4-35" data-line-number="35">    // If v is a root node, pop the stack and generate an SCC</a>
<a class="sourceLine" id="cb4-36" data-line-number="36">    if (v.lowlink = v.index) then</a>
<a class="sourceLine" id="cb4-37" data-line-number="37">      start a new strongly connected component</a>
<a class="sourceLine" id="cb4-38" data-line-number="38">      repeat</a>
<a class="sourceLine" id="cb4-39" data-line-number="39">        w := S.pop()</a>
<a class="sourceLine" id="cb4-40" data-line-number="40">        w.onStack := false</a>
<a class="sourceLine" id="cb4-41" data-line-number="41">        add w to current strongly connected component</a>
<a class="sourceLine" id="cb4-42" data-line-number="42">      while (w != v)</a>
<a class="sourceLine" id="cb4-43" data-line-number="43">      output the current strongly connected component</a>
<a class="sourceLine" id="cb4-44" data-line-number="44">    end if</a>
<a class="sourceLine" id="cb4-45" data-line-number="45">  end function</a></code></pre></div>
<p>and here’s what that looks like in Haskell:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Array</span> <span class="kw">as</span> <span class="dt">A</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph</span> <span class="kw">as</span> <span class="dt">G</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Control.Monad</span>       (forM_, when)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.STRef</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Vector.Mutable</span> (<span class="dt">STVector</span>, read, replicate, write)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span>      (read, replicate)</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">tarjan graph <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    index    <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    stack    <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    stackSet <span class="ot">&lt;-</span> replicate size <span class="dt">False</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">    indices  <span class="ot">&lt;-</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">    lowlinks <span class="ot">&lt;-</span> replicate size <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb5-16" data-line-number="16">    output   <span class="ot">&lt;-</span> newSTRef []</a>
<a class="sourceLine" id="cb5-17" data-line-number="17"></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    forM_ (G.vertices graph) <span class="fu">$</span> \v <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">        vIndex <span class="ot">&lt;-</span> read indices v</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">        when (vIndex <span class="fu">==</span> <span class="dt">Nothing</span>) <span class="fu">$</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">            strongConnect v graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb5-22" data-line-number="22"></a>
<a class="sourceLine" id="cb5-23" data-line-number="23">    reverse <span class="fu">&lt;$&gt;</span> readSTRef output</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">    <span class="kw">where</span> size <span class="fu">=</span> snd (A.bounds graph) <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-25" data-line-number="25"></a>
<a class="sourceLine" id="cb5-26" data-line-number="26">strongConnect v graph index stack stackSet indices lowlinks output <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-27" data-line-number="27">    i <span class="ot">&lt;-</span> readSTRef index</a>
<a class="sourceLine" id="cb5-28" data-line-number="28">    write indices  v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">    write lowlinks v (<span class="dt">Just</span> i)</a>
<a class="sourceLine" id="cb5-30" data-line-number="30">    modifySTRef' index (<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-31" data-line-number="31">    push v</a>
<a class="sourceLine" id="cb5-32" data-line-number="32"></a>
<a class="sourceLine" id="cb5-33" data-line-number="33">    forM_ (graph <span class="fu">A.!</span> v) <span class="fu">$</span> \w <span class="ot">-&gt;</span> read indices w <span class="fu">&gt;&gt;=</span> \found <span class="ot">-&gt;</span> <span class="kw">case</span> found <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-34" data-line-number="34">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-35" data-line-number="35">            strongConnect w graph index stack stackSet indices lowlinks output</a>
<a class="sourceLine" id="cb5-36" data-line-number="36">            write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read lowlinks w)</a>
<a class="sourceLine" id="cb5-37" data-line-number="37">        <span class="dt">Just</span>{}  <span class="ot">-&gt;</span> read stackSet w <span class="fu">&gt;&gt;=</span> \wOnStack <span class="ot">-&gt;</span> when wOnStack <span class="fu">$</span></a>
<a class="sourceLine" id="cb5-38" data-line-number="38">            write lowlinks v <span class="fu">=&lt;&lt;</span> (min <span class="fu">&lt;$&gt;</span> read lowlinks v <span class="fu">&lt;*&gt;</span> read indices  w)</a>
<a class="sourceLine" id="cb5-39" data-line-number="39"></a>
<a class="sourceLine" id="cb5-40" data-line-number="40">    vLowLink <span class="ot">&lt;-</span> read lowlinks v</a>
<a class="sourceLine" id="cb5-41" data-line-number="41">    vIndex   <span class="ot">&lt;-</span> read indices  v</a>
<a class="sourceLine" id="cb5-42" data-line-number="42">    when (vLowLink <span class="fu">==</span> vIndex) <span class="fu">$</span> modifySTRef' output <span class="fu">.</span> (<span class="fu">:</span>) <span class="fu">=&lt;&lt;</span> addSCC v []</a>
<a class="sourceLine" id="cb5-43" data-line-number="43">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-44" data-line-number="44">        addSCC v scc <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-45" data-line-number="45">            w <span class="ot">&lt;-</span> pop</a>
<a class="sourceLine" id="cb5-46" data-line-number="46">            <span class="kw">let</span> scc' <span class="fu">=</span> w<span class="fu">:</span>scc</a>
<a class="sourceLine" id="cb5-47" data-line-number="47">            <span class="kw">if</span> w <span class="fu">==</span> v <span class="kw">then</span> return scc' <span class="kw">else</span> addSCC v scc'</a>
<a class="sourceLine" id="cb5-48" data-line-number="48"></a>
<a class="sourceLine" id="cb5-49" data-line-number="49">        push e <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-50" data-line-number="50">            modifySTRef' stack (e<span class="fu">:</span>)</a>
<a class="sourceLine" id="cb5-51" data-line-number="51">            write stackSet e <span class="dt">True</span></a>
<a class="sourceLine" id="cb5-52" data-line-number="52"></a>
<a class="sourceLine" id="cb5-53" data-line-number="53">        pop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-54" data-line-number="54">            e <span class="ot">&lt;-</span> head <span class="fu">&lt;$&gt;</span> readSTRef stack</a>
<a class="sourceLine" id="cb5-55" data-line-number="55">            modifySTRef' stack tail</a>
<a class="sourceLine" id="cb5-56" data-line-number="56">            write stackSet e <span class="dt">False</span></a>
<a class="sourceLine" id="cb5-57" data-line-number="57">            return e</a></code></pre></div>
<p>Aside from explicitly declaring our variables and passing them around, I think this looks pretty close.</p>
<p>How do we square this with Haskell’s reputation for purity and referential transparency? That’s the subject of <a href="https://www.microsoft.com/en-us/research/publication/lazy-functional-state-threads/">the paper mentioned above</a> that you don’t have to read (but totally can if you want)! They figured out a way to provide a principled pure interface to mutable state by passing the references as arguments into each function that makes use of them and leveraging the type system to make sure any impurity is well contained. The correctness of this approach was <a href="http://iris-project.org/pdfs/2017-icfp-runST-submission.pdf">very recently verified</a>. If desired, we can replace any of the functions with purer and more idiomatic definitions without changing the output, and that satisfies the definition of referential transparency!</p>
<p>Why don’t we do this all the time, when Haskell is at least a serviceable imperative language? Because writing imperative programs is hard! They don’t compose as well, have less useful type signatures, and are harder to reason about. Getting away from those things is why we have Haskell to begin with! The real question should be: how can we avoid doing things this way as much as possible?</p>
<p>Before I discovered this part of Haskell, I had this perception of Haskell (and declarative programming more generally) as “imperative programming but less” from a practical perspective. I thought that although writing declarative code in Python was purely (heh) a matter of discipline, writing imperative code in Haskell required completely reconceptualising the algorithm. Thanks to <code>ST</code>, I now know that this not the case, which is a huge relief. If required, I can do a literal translation of the algorithm, and clean it up (or not) later. In fact Haskell is “imperative programming and more”, and that’s awesome!</p>
<p>Thanks to <a href="http://blog.podsnap.com/">Peter Fraenkel</a>, <a href="https://jvns.ca/">Julia Evans</a>, and <a href="http://msteigerwalt.com/">Michelle Steigerwalt</a> for feedback.</p>
<p><em>If you’d rather try to make sense of the <a href="https://github.com/vaibhavsagar/presentations/tree/master/imperative-haskell">set of disconnected files</a> that constitutes my slides for that presentation, you can do that instead, although I wouldn’t recommend it.</em></p>

        </div>
        <div id="footer">
            <div class="rc-scout">
                <script async defer src="https://www.recurse-scout.com/loader.js?t=5ac465e5d3396a7e491e42afac4c5c90"></script>
            </div>
        </div>
    </body>
</html>
